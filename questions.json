{
  "unit1": [
    {
      "id": "m1",
      "type": "mcq",
      "question": "다음 중 유효한 자바 변수 선언은 무엇인가?",
      "options": {
        "A": "int 1number = 10;",
        "B": "int number = 10;",
        "C": "int number 10;",
        "D": "int number: 10;"
      },
      "correctAnswer": "B"
    },
    {
      "id": "m2",
      "type": "mcq",
      "question": "다음 코드에서 int a = 5; double b = 2.0; 일 때, a/b의 결과 타입은?",
      "options": {
        "A": "int",
        "B": "double",
        "C": "float",
        "D": "long"
      },
      "correctAnswer": "B"
    },
    {
      "id": "m3",
      "type": "mcq",
      "question": "명시적 형변환이 필요한 경우는 어느 상황인가?",
      "options": {
        "A": "int에서 double로 변환할 때",
        "B": "double에서 int로 변환할 때",
        "C": "int에서 long으로 변환할 때",
        "D": "char에서 int로 변환할 때"
      },
      "correctAnswer": "B"
    },
    {
      "id": "m4",
      "type": "mcq",
      "question": "다음 중 올바른 배열 선언은?",
      "options": {
        "A": "int[] arr = new int[10];",
        "B": "int arr = new int[10];",
        "C": "int arr[] = new int(10);",
        "D": "int[] arr = int[10];"
      },
      "correctAnswer": "A"
    },
    {
      "id": "m5",
      "type": "mcq",
      "question": "자바에서 객체 생성을 위해 사용하는 키워드는?",
      "options": {
        "A": "build",
        "B": "create",
        "C": "new",
        "D": "init"
      },
      "correctAnswer": "C"
    },
    {
      "id": "m6",
      "type": "mcq",
      "question": "double d = 9.99; int i = (int)d; 의 결과는?",
      "options": {
        "A": "9.99",
        "B": "10",
        "C": "9.",
        "D": "에러"
      },
      "correctAnswer": "C"
    },
    {
      "id": "m7",
      "type": "mcq",
      "question": "자바에서 배열의 길이를 반환하는 프로퍼티는?",
      "options": {
        "A": "count",
        "B": "size()",
        "C": "length",
        "D": "length()"
      },
      "correctAnswer": "C"
    },
    {
      "id": "m8",
      "type": "mcq",
      "question": "2차원 배열 선언 시 올바른 표현은?",
      "options": {
        "A": "int[][] arr = new int[3][4];",
        "B": "int[][] arr = new int[3];",
        "C": "int arr[][] = new int[3,4];",
        "D": "int[][] arr = new int[3][];"
      },
      "correctAnswer": "A"
    },
    {
      "id": "m9",
      "type": "mcq",
      "question": "자바에서 int형 변수의 기본값(인스턴스 변수 기준)은?",
      "options": {
        "A": "쓰레기 값",
        "B": "null",
        "C": "정의되지 않음",
        "D": "D"
      },
      "correctAnswer": "A"
    },
    {
      "id": "m10",
      "type": "mcq",
      "question": "자바에서 상수를 선언하는 올바른 방법은?",
      "options": {
        "A": "int CONSTANT = 10;",
        "B": "const int CONSTANT = 10;",
        "C": "final int CONSTANT = 10;",
        "D": "static int CONSTANT = 10;"
      },
      "correctAnswer": "C"
    },
    {
      "id": "m11",
      "type": "mcq",
      "question": "System.out.println((char)65)의 출력 결과는?",
      "options": {
        "A": "A",
        "B": "65",
        "C": "에러",
        "D": "a"
      },
      "correctAnswer": "A"
    },
    {
      "id": "m12",
      "type": "mcq",
      "question": "다음 중 유효하지 않은 변수명은?",
      "options": {
        "A": "_number",
        "B": "$number",
        "C": "number1",
        "D": "1number"
      },
      "correctAnswer": "D"
    },
    {
      "id": "m13",
      "type": "mcq",
      "question": "자바에서 int 변수의 크기는?",
      "options": {
        "A": "4바이트",
        "B": "2바이트",
        "C": "8바이트",
        "D": "플랫폼에 따라 다름"
      },
      "correctAnswer": "A"
    },
    {
      "id": "m14",
      "type": "mcq",
      "question": "double 변수의 크기는?",
      "options": {
        "A": "8바이트",
        "B": "4바이트",
        "C": "16바이트",
        "D": "플랫폼에 따라 다름"
      },
      "correctAnswer": "A"
    },
    {
      "id": "m15",
      "type": "mcq",
      "question": "자바에서 상수를 선언하는 올바른 방법은?",
      "options": {
        "A": "final int CONSTANT = 10;",
        "B": "const int CONSTANT = 10;",
        "C": "int CONSTANT = 10;",
        "D": "static int CONSTANT = 10;"
      },
      "correctAnswer": "A"
    },
    {
      "id": "m16",
      "type": "mcq",
      "question": "System.out.println(5 + 2 * 3)의 출력 결과는?",
      "options": {
        "A": "21",
        "B": "11",
        "C": "15",
        "D": "7"
      },
      "correctAnswer": "B"
    },
    {
      "id": "m17",
      "type": "mcq",
      "question": "다음 중 암시적 형변환의 예는?",
      "options": {
        "A": "int에서 double로",
        "B": "double에서 int로",
        "C": "float에서 int로",
        "D": "char에서 String으로"
      },
      "correctAnswer": "A"
    },
    {
      "id": "m18",
      "type": "mcq",
      "question": "(int)'A'의 결과는?",
      "options": {
        "A": "65",
        "B": "'A'",
        "C": "에러",
        "D": "0"
      },
      "correctAnswer": "A"
    },
    {
      "id": "m19",
      "type": "mcq",
      "question": "자바 배열에 관한 설명으로 옳은 것은?",
      "options": {
        "A": "배열은 고정 크기를 가진다.",
        "B": "배열은 동적 크기 조절이 가능하다.",
        "C": "배열은 Collections 프레임워크의 일부이다.",
        "D": "배열은 불변이다."
      },
      "correctAnswer": "A"
    },
    {
      "id": "m20",
      "type": "mcq",
      "question": "자바에서 배열을 초기화하는 올바른 방법은?",
      "options": {
        "A": "int[] arr = {1,2,3};",
        "B": "int arr[] = new int[]{1,2,3};",
        "C": "A와 B 모두",
        "D": "없음"
      },
      "correctAnswer": "C"
    },
    {
      "id": "m21",
      "type": "mcq",
      "question": "System.out.println(10/3)의 출력 결과는?",
      "options": {
        "A": "3",
        "B": "3.33",
        "C": "3.0",
        "D": "3.3333"
      },
      "correctAnswer": "A"
    },
    {
      "id": "m22",
      "type": "mcq",
      "question": "자바 형변환에 관한 설명 중 옳은 것은?",
      "options": {
        "A": "암시적 변환 시 데이터 손실이 발생할 수 있다.",
        "B": "명시적 변환은 항상 안전하다.",
        "C": "작은 타입에서 큰 타입으로의 변환은 암시적으로 이루어진다.",
        "D": "명시적 변환은 자동으로 이루어진다."
      },
      "correctAnswer": "C"
    },
    {
      "id": "m23",
      "type": "mcq",
      "question": "boolean 배열의 미초기화 요소의 기본값은?",
      "options": {
        "A": "false",
        "B": "true",
        "C": "0",
        "D": "null"
      },
      "correctAnswer": "A"
    },
    {
      "id": "m24",
      "type": "mcq",
      "question": "문자열을 정수로 변환하는 메서드는?",
      "options": {
        "A": "Integer.parseInt()",
        "B": "(int) string",
        "C": "String.toInt()",
        "D": "parseInt()"
      },
      "correctAnswer": "A"
    },
    {
      "id": "m25",
      "type": "mcq",
      "question": "'final' 키워드의 효과는 무엇인가?",
      "options": {
        "A": "초기화 후 값 변경 불가",
        "B": "상수가 된다",
        "C": "A와 B 모두",
        "D": "없음"
      },
      "correctAnswer": "C"
    },
    {
      "id": "m26",
      "type": "mcq",
      "question": "지역 변수에 대한 설명으로 틀린 것은?",
      "options": {
        "A": "자동 초기화된다.",
        "B": "메서드 내에서 선언된다.",
        "C": "스코프가 블록 단위이다.",
        "D": "스택 영역에 저장된다."
      },
      "correctAnswer": "A"
    },
    {
      "id": "m27",
      "type": "mcq",
      "question": "다음 코드의 결과는:\nint[] arr = new int[3];\nSystem.out.println(arr[1]);",
      "options": {
        "A": "0",
        "B": "null",
        "C": "undefined",
        "D": "에러"
      },
      "correctAnswer": "A"
    },
    {
      "id": "m28",
      "type": "mcq",
      "question": "System.out.println((int)3.9)의 출력 결과는?",
      "options": {
        "A": "3",
        "B": "4",
        "C": "3.9",
        "D": "에러"
      },
      "correctAnswer": "A"
    },
    {
      "id": "m29",
      "type": "mcq",
      "question": "3차원 배열 선언 시 올바른 구문은?",
      "options": {
        "A": "int[][][] arr = new int[2][3][4];",
        "B": "int arr[][][] = new int[2][3][4];",
        "C": "A와 B 모두",
        "D": "없음"
      },
      "correctAnswer": "C"
    },
    {
      "id": "m30",
      "type": "mcq",
      "question": "세 개의 문자열을 초기화하는 올바른 배열 선언은?",
      "options": {
        "A": "String[] arr = [\"a\", \"b\", \"c\"];",
        "B": "String[] arr = {\"a\", \"b\", \"c\"};",
        "C": "String arr[] = new String[\"a\",\"b\",\"c\"];",
        "D": "String arr = new String[]{\"a\", \"b\", \"c\"};"
      },
      "correctAnswer": "B"
    },
    {
      "id": "m31",
      "type": "mcq",
      "question": "정수를 0으로 나누면 발생하는 현상은?",
      "options": {
        "A": "ArithmeticException",
        "B": "Infinity",
        "C": "0",
        "D": "정의되지 않음"
      },
      "correctAnswer": "A"
    },
    {
      "id": "m32",
      "type": "mcq",
      "question": "Object에서 String으로의 형변환 올바른 구문은?",
      "options": {
        "A": "(String) obj",
        "B": "String(obj)",
        "C": "obj as String",
        "D": "cast(String, obj)"
      },
      "correctAnswer": "A"
    },
    {
      "id": "m33",
      "type": "mcq",
      "question": "자바에서 배열은 어느 영역에 할당되는가?",
      "options": {
        "A": "힙(heap)",
        "B": "스택(stack)",
        "C": "String Pool",
        "D": "Permanent Generation"
      },
      "correctAnswer": "A"
    },
    {
      "id": "m34",
      "type": "mcq",
      "question": "System.out.println(3 + \"5\")의 결과는?",
      "options": {
        "A": "8",
        "B": "35",
        "C": "에러",
        "D": "3 5"
      },
      "correctAnswer": "B"
    },
    {
      "id": "m35",
      "type": "mcq",
      "question": "자바 배열의 인덱스는 몇부터 시작하는가?",
      "options": {
        "A": "0",
        "B": "1",
        "C": "-1",
        "D": "임의의 수"
      },
      "correctAnswer": "A"
    },
    {
      "id": "m36",
      "type": "mcq",
      "question": "객체의 참조 비교에 사용되는 연산자는?",
      "options": {
        "A": "==",
        "B": "equals()",
        "C": "compareTo()",
        "D": "==="
      },
      "correctAnswer": "A"
    },
    {
      "id": "m37",
      "type": "mcq",
      "question": "'instanceof' 키워드의 역할은?",
      "options": {
        "A": "객체의 타입 검사",
        "B": "형변환 수행",
        "C": "객체 비교",
        "D": "클래스 반환"
      },
      "correctAnswer": "A"
    },
    {
      "id": "m38",
      "type": "mcq",
      "question": "자바의 타입 시스템에 대한 설명 중 옳은 것은?",
      "options": {
        "A": "정적 타입",
        "B": "동적 타입",
        "C": "정적과 동적 혼합",
        "D": "약한 타입"
      },
      "correctAnswer": "A"
    },
    {
      "id": "m39",
      "type": "mcq",
      "question": "System.out.println((double)5/2)의 출력 결과는?",
      "options": {
        "A": "2.5",
        "B": "2",
        "C": "2.0",
        "D": "3"
      },
      "correctAnswer": "A"
    },
    {
      "id": "m40",
      "type": "mcq",
      "question": "다차원 배열을 선언하는 올바른 방법은?",
      "options": {
        "A": "int[][] matrix = new int[3][4];",
        "B": "int matrix[][] = new int[3,4];",
        "C": "int matrix = new int[3][4];",
        "D": "int[] matrix = new int[3][4];"
      },
      "correctAnswer": "A"
    },
    {
      "id": "m41",
      "type": "mcq",
      "question": "다음 코드의 결과는:\nint[] a = {1,2,3};\nint[] b = a;\nb[0] = 10;\nSystem.out.println(a[0]);",
      "options": {
        "A": "10",
        "B": "1",
        "C": "0",
        "D": "에러"
      },
      "correctAnswer": "A"
    },
    {
      "id": "m42",
      "type": "mcq",
      "question": "다음 중 오토박싱의 예는?",
      "options": {
        "A": "Integer i = 5;",
        "B": "int i = new Integer(5);",
        "C": "Integer i = new Integer(5);",
        "D": "없음"
      },
      "correctAnswer": "A"
    },
    {
      "id": "m43",
      "type": "mcq",
      "question": "System.out.println(1 + 2 + \"3\")의 출력 결과는?",
      "options": {
        "A": "33",
        "B": "123",
        "C": "6 3",
        "D": "3 3"
      },
      "correctAnswer": "B"
    },
    {
      "id": "m44",
      "type": "mcq",
      "question": "자바에서 변수 섀도잉(shadowing)에 대한 올바른 설명은?",
      "options": {
        "A": "지역변수가 인스턴스 변수를 가릴 수 있다.",
        "B": "인스턴스 변수가 지역변수를 가린다.",
        "C": "섀도잉은 허용되지 않는다.",
        "D": "컴파일 에러를 발생시킨다."
      },
      "correctAnswer": "A"
    },
    {
      "id": "m45",
      "type": "mcq",
      "question": "System.out.println('A' + 1)의 결과는?",
      "options": {
        "A": "66",
        "B": "'B'",
        "C": "에러",
        "D": "65"
      },
      "correctAnswer": "A"
    },
    {
      "id": "m46",
      "type": "mcq",
      "question": "다음 중 자바의 기본 자료형이 아닌 것은?",
      "options": {
        "A": "String",
        "B": "int",
        "C": "double",
        "D": "boolean"
      },
      "correctAnswer": "A"
    },
    {
      "id": "m47",
      "type": "mcq",
      "question": "다음 코드의 출력 결과는:\nint a = 10;\na += 5;\nSystem.out.println(a);",
      "options": {
        "A": "15",
        "B": "10",
        "C": "5",
        "D": "105"
      },
      "correctAnswer": "A"
    },
    {
      "id": "m48",
      "type": "mcq",
      "question": "큰 타입을 작은 타입으로 캐스팅할 때 주의할 점은?",
      "options": {
        "A": "정밀도 손실이 발생할 수 있다.",
        "B": "항상 안전하다.",
        "C": "값이 그대로 유지된다.",
        "D": "불가능하다."
      },
      "correctAnswer": "A"
    },
    {
      "id": "m49",
      "type": "mcq",
      "question": "메소드 오버라이딩을 방지하는 키워드는?",
      "options": {
        "A": "final",
        "B": "static",
        "C": "private",
        "D": "abstract"
      },
      "correctAnswer": "A"
    },
    {
      "id": "m50",
      "type": "mcq",
      "question": "System.out.println(3 * (2 + 4))의 출력 결과는?",
      "options": {
        "A": "18",
        "B": "20",
        "C": "24",
        "D": "12"
      },
      "correctAnswer": "A"
    },
    {
      "id": "c1",
      "type": "code",
      "question": "길이가 10인 int형 배열을 선언하는 코드를 완성하세요.",
      "codeSnippet": "int[] arr = new int[__];",
      "answers": ["10"]
    },
    {
      "id": "c2",
      "type": "code",
      "question": "double형 변수 d를 int형으로 명시적 형변환하여 변수 i에 저장하는 코드를 완성하세요.",
      "codeSnippet": "int i = (__d);",
      "answers": ["(int)"]
    },
    {
      "id": "c3",
      "type": "code",
      "question": "배열 arr의 길이를 출력하는 코드를 완성하세요.",
      "codeSnippet": "System.out.println(arr.__);",
      "answers": ["length"]
    },
    {
      "id": "c4",
      "type": "code",
      "question": "문자열 \"hello\"를 저장하는 변수를 선언하는 코드를 완성하세요.",
      "codeSnippet": "String s = __(\"hello\");",
      "answers": ["new String"]
    },
    {
      "id": "c5",
      "type": "code",
      "question": "int형 배열 nums의 첫 번째 요소에 100을 대입하는 코드를 완성하세요.",
      "codeSnippet": "nums[__] = 100;",
      "answers": ["0"]
    },
    {
      "id": "c6",
      "type": "code",
      "question": "3행 4열의 int형 2차원 배열을 선언하는 코드를 완성하세요.",
      "codeSnippet": "int[][] matrix = new int[__][__];",
      "answers": ["3", "4"]
    },
    {
      "id": "c7",
      "type": "code",
      "question": "정수형 배열 arr의 두 번째 요소에 접근하는 코드를 완성하세요.",
      "codeSnippet": "int x = arr[__];",
      "answers": ["1"]
    },
    {
      "id": "c8",
      "type": "code",
      "question": "문자열 s를 정수로 변환하는 코드를 완성하세요.",
      "codeSnippet": "int num = __(s);",
      "answers": ["Integer.parseInt"]
    },
    {
      "id": "c9",
      "type": "code",
      "question": "값 3.14를 가진 상수 PI를 선언하는 코드를 완성하세요.",
      "codeSnippet": "final double PI = __;",
      "answers": ["3.14"]
    },
    {
      "id": "c10",
      "type": "code",
      "question": "정수 변수 count를 0으로 초기화하는 코드를 완성하세요.",
      "codeSnippet": "int count = __;",
      "answers": ["0"]
    },
    {
      "id": "c11",
      "type": "code",
      "question": "정수 변수 i를 1 증가시키는 코드를 완성하세요.",
      "codeSnippet": "i__;",
      "answers": ["++"]
    },
    {
      "id": "c12",
      "type": "code",
      "question": "문자 'A'를 값으로 갖는 char 변수를 선언하는 코드를 완성하세요.",
      "codeSnippet": "char ch = __;",
      "answers": ["'A'"]
    },
    {
      "id": "c13",
      "type": "code",
      "question": "boolean 변수 flag를 true로 선언하는 코드를 완성하세요.",
      "codeSnippet": "boolean flag = __;",
      "answers": ["true"]
    },
    {
      "id": "c14",
      "type": "code",
      "question": "float형 변수 f를 int형으로 명시적 형변환하는 코드를 완성하세요.",
      "codeSnippet": "int num = (__f);",
      "answers": ["(int)"]
    },
    {
      "id": "c15",
      "type": "code",
      "question": "new 연산자를 사용하여 \"hello\"를 값으로 갖는 String 객체를 생성하는 코드를 완성하세요.",
      "codeSnippet": "String s = ____;",
      "answers": ["new","String(\"hello\")"]
    },
    {
      "id": "c16",
      "type": "code",
      "question": "문자열 변수 a와 b를 연결하는 코드를 완성하세요.",
      "codeSnippet": "String result = a __ b;",
      "answers": ["+"]
    },
    {
      "id": "c17",
      "type": "code",
      "question": "두 문자열 s1과 s2의 동등 비교를 수행하는 코드를 완성하세요.",
      "codeSnippet": "boolean eq = s1.__(s2);",
      "answers": ["equals"]
    },
    {
      "id": "c18",
      "type": "code",
      "question": "값 5.5를 가진 double형 변수 d를 선언하는 코드를 완성하세요.",
      "codeSnippet": "double d = __;",
      "answers": ["5.5"]
    },
    {
      "id": "c19",
      "type": "code",
      "question": "int형 배열 arr의 두 번째 요소를 변수 x에 저장하는 코드를 완성하세요.",
      "codeSnippet": "int x = arr[__];",
      "answers": ["1"]
    },
    {
      "id": "c20",
      "type": "code",
      "question": "크기 5인 int형 배열 nums를 생성하는 코드를 완성하세요.",
      "codeSnippet": "int[] nums = new int[__];",
      "answers": ["5"]
    },
    {
      "id": "c21",
      "type": "code",
      "question": "2행 3열의 int형 다차원 배열을 선언하는 코드를 완성하세요.",
      "codeSnippet": "int[][] matrix = new int[__][__];",
      "answers": ["2", "3"]
    },
    {
      "id": "c22",
      "type": "code",
      "question": "문자열 str의 첫 번째 문자를 반환하는 코드를 완성하세요.",
      "codeSnippet": "char firstChar = str.__(0);",
      "answers": ["charAt"]
    },
    {
      "id": "c23",
      "type": "code",
      "question": "정수 n을 문자열로 변환하는 코드를 완성하세요.",
      "codeSnippet": "String s = Integer.__(n);",
      "answers": ["toString"]
    },
    {
      "id": "c24",
      "type": "code",
      "question": "StringBuilder를 사용하여 문자열 a와 b를 연결하는 코드를 완성하세요.",
      "codeSnippet": "StringBuilder sb = new StringBuilder(); sb.__(a).append(b);",
      "answers": ["append"]
    },
    {
      "id": "c25",
      "type": "code",
      "question": "크기 3인 boolean형 배열을 선언하는 코드를 완성하세요.",
      "codeSnippet": "boolean[] flags = new boolean[__];",
      "answers": ["3"]
    },
    {
      "id": "s1",
      "type": "subjective",
      "question": "자바에서 변수 타입 선언이 메모리 할당에 미치는 영향을 설명하시오.",
      "correctAnswer": "변수의 타입은 저장되는 데이터의 크기와 형태를 결정하며, 이에 따라 필요한 메모리 공간이 할당된다."
    },
    {
      "id": "s2",
      "type": "subjective",
      "question": "명시적 형변환이 필요한 이유와 예제를 설명하시오.",
      "correctAnswer": "명시적 형변환은 데이터 손실의 가능성이 있는 변환 시 개발자가 의도적으로 변환하도록 하여 예기치 않은 결과를 방지하기 위함이다. 예를 들어, double을 int로 변환할 때 사용된다."
    },
    {
      "id": "s3",
      "type": "subjective",
      "question": "객체와 기본 자료형의 메모리 저장 방식 차이를 설명하시오.",
      "correctAnswer": "기본 자료형은 스택에 직접 저장되고, 객체는 힙에 저장되며 참조를 통해 접근된다."
    },
    {
      "id": "s4",
      "type": "subjective",
      "question": "오토박싱(autoboxing)의 개념과 장점을 설명하시오.",
      "correctAnswer": "오토박싱은 기본형 데이터를 자동으로 해당하는 래퍼 객체로 변환하여, 코드의 간결성과 컬렉션 사용의 편리함을 제공한다."
    },
    {
      "id": "s5",
      "type": "subjective",
      "question": "배열의 고정 크기가 가지는 한계와 이를 극복하기 위한 자료구조를 설명하시오.",
      "correctAnswer": "배열은 한 번 선언하면 크기를 변경할 수 없기 때문에 동적 데이터 처리에 한계가 있으며, 이를 극복하기 위해 ArrayList와 같은 동적 자료구조를 사용한다."
    },
    {
      "id": "s6",
      "type": "subjective",
      "question": "자바에서 배열이 힙 영역에 저장되는 이유와 그 장점을 설명하시오.",
      "correctAnswer": "배열이 힙에 저장되면 동적 메모리 할당과 가비지 컬렉션의 혜택을 받아, 프로그램의 메모리 관리가 효율적이다."
    },
    {
      "id": "s7",
      "type": "subjective",
      "question": "'final' 키워드가 변수에 미치는 영향에 대해 설명하시오.",
      "correctAnswer": "final 키워드를 사용하면 변수의 값을 한 번 초기화한 후 변경할 수 없게 되어, 상수로 사용된다."
    },
    {
      "id": "s8",
      "type": "subjective",
      "question": "자바에서 암시적 형변환이 이루어지는 상황과 그 이유를 설명하시오.",
      "correctAnswer": "암시적 형변환은 작은 데이터 타입을 큰 데이터 타입으로 자동 변환할 때 발생하며, 데이터 손실 없이 안전하게 변환할 수 있기 때문이다."
    },
    {
      "id": "s9",
      "type": "subjective",
      "question": "정수와 실수의 나눗셈 결과가 다른 이유에 대해 설명하시오.",
      "correctAnswer": "정수끼리의 나눗셈은 정수 결과만 반환하고 소수점 이하를 버리지만, 실수 연산은 소수점 이하까지 계산한다."
    },
    {
      "id": "s10",
      "type": "subjective",
      "question": "얕은 복사(shallow copy)와 깊은 복사(deep copy)의 차이를 설명하시오.",
      "correctAnswer": "얕은 복사는 객체의 참조만 복사하여 같은 객체를 공유하고, 깊은 복사는 객체 내부의 데이터를 모두 복사하여 독립적인 객체를 생성한다."
    },
    {
      "id": "s11",
      "type": "subjective",
      "question": "변수의 스코프(scope)가 프로그램에 미치는 영향을 논하시오.",
      "correctAnswer": "변수의 스코프는 해당 변수가 유효한 범위를 결정하며, 메모리 사용과 네임스페이스 충돌을 관리하는 데 중요한 역할을 한다."
    },
    {
      "id": "s12",
      "type": "subjective",
      "question": "명시적 형변환 시 발생할 수 있는 문제점과 이를 방지하는 방법을 설명하시오.",
      "correctAnswer": "명시적 형변환은 데이터 손실이나 ClassCastException을 발생시킬 수 있으므로, 타입 확인과 범위 검사를 통해 주의해야 한다."
    },
    {
      "id": "s13",
      "type": "subjective",
      "question": "'=='와 'equals()'의 차이점을 논하시오.",
      "correctAnswer": "'=='는 객체의 참조(주소) 비교를 수행하고, equals()는 객체의 내용을 비교한다."
    },
    {
      "id": "s14",
      "type": "subjective",
      "question": "자바에서 String의 불변성이 왜 중요한지 설명하시오.",
      "correctAnswer": "String이 불변하면 여러 곳에서 안전하게 공유할 수 있고, 해시코드 캐싱 등 성능 최적화 및 보안 측면에서 이점을 제공한다."
    },
    {
      "id": "s15",
      "type": "subjective",
      "question": "자바의 가비지 컬렉션이 메모리 관리에 미치는 긍정적 효과에 대해 논하시오.",
      "correctAnswer": "가비지 컬렉션은 사용되지 않는 객체를 자동으로 회수하여 메모리 누수를 방지하고, 개발자가 메모리 해제에 신경쓰지 않아도 되게 한다."
    },
    {
      "id": "s16",
      "type": "subjective",
      "question": "배열의 인덱스가 0부터 시작하는 이유와 그 장점을 설명하시오.",
      "correctAnswer": "인덱스가 0부터 시작하면 주소 산술이 단순해지고, 메모리 오프셋 계산이 효율적으로 이루어진다."
    },
    {
      "id": "s17",
      "type": "subjective",
      "question": "자바에서 컴파일 시 타입 검사가 중요한 이유를 설명하시오.",
      "correctAnswer": "컴파일 시 타입 검사를 통해 잘못된 타입 사용을 사전에 방지하여 런타임 오류를 줄이고, 코드 안정성을 높인다."
    },
    {
      "id": "s18",
      "type": "subjective",
      "question": "문자열을 기본형으로 변환하는 과정에서 주의할 점에 대해 논하시오.",
      "correctAnswer": "문자열이 올바른 숫자 형식인지 확인하지 않으면 NumberFormatException이 발생할 수 있으므로, 사전 검증이 필요하다."
    },
    {
      "id": "s19",
      "type": "subjective",
      "question": "JVM이 변수와 배열의 메모리를 관리하는 방식을 설명하시오.",
      "correctAnswer": "JVM은 기본형은 스택에, 객체와 배열은 힙에 할당하며, 가비지 컬렉션을 통해 메모리를 자동 관리한다."
    },
    {
      "id": "s20",
      "type": "subjective",
      "question": "유효하지 않은 형변환 시 발생하는 예외와 그 처리 방법을 설명하시오.",
      "correctAnswer": "잘못된 형변환은 ClassCastException을 발생시키며, instanceof 연산자나 try-catch 구문으로 사전에 검사 및 처리가 필요하다."
    },
    {
      "id": "s21",
      "type": "subjective",
      "question": "자바에서 배열의 인덱스 범위 검사가 중요한 이유에 대해 설명하시오.",
      "correctAnswer": "인덱스 범위 검사를 통해 배열의 경계를 넘어선 접근을 막아 ArrayIndexOutOfBoundsException 등의 런타임 오류를 예방할 수 있다."
    },
    {
      "id": "s22",
      "type": "subjective",
      "question": "'static' 키워드가 변수에 미치는 영향에 대해 논하시오.",
      "correctAnswer": "static 변수는 클래스에 속해 모든 인스턴스가 공유되며, 객체 생성 없이 접근 가능해 메모리 사용 효율성을 높인다."
    },
    {
      "id": "s23",
      "type": "subjective",
      "question": "배열의 한계를 극복하기 위해 자바에서 제공하는 컬렉션 프레임워크의 장점을 설명하시오.",
      "correctAnswer": "컬렉션은 동적 크기 조절, 다양한 메서드, 제네릭 지원 등으로 배열의 고정 크기 한계를 극복할 수 있다."
    },
    {
      "id": "s24",
      "type": "subjective",
      "question": "얕은 비교와 깊은 비교의 차이를 배열 비교에 적용하여 설명하시오.",
      "correctAnswer": "얕은 비교는 배열 객체의 참조만 비교하고, 깊은 비교는 배열 내부 요소까지 비교하여 동일성을 판단한다."
    },
    {
      "id": "s25",
      "type": "subjective",
      "question": "혼합된 자료형의 산술 연산 시 자바가 수행하는 타입 변환 과정을 설명하시오.",
      "correctAnswer": "연산 시 피연산자들이 가장 큰 타입으로 자동 승격되어 연산되므로 정밀도가 보장된다."
    }
  ],
  "unit2": [
    {
      "id": "u2m1",
      "type": "mcq",
      "question": "자바의 객체지향 프로그래밍(OOP)의 4대 원칙 중 하나가 아닌 것은 무엇인가?",
      "options": {
        "A": "캡슐화",
        "B": "상속",
        "C": "다형성",
        "D": "함수형 프로그래밍"
      },
      "correctAnswer": "D"
    },
    {
      "id": "u2m2",
      "type": "mcq",
      "question": "클래스의 생성자는 반드시 클래스 이름과 동일해야 한다.",
      "options": {
        "A": "맞다",
        "B": "틀리다",
        "C": "경우에 따라 다르다",
        "D": "상속 시 변경된다"
      },
      "correctAnswer": "A"
    },
    {
      "id": "u2m3",
      "type": "mcq",
      "question": "생성자의 주요 역할은 무엇인가?",
      "options": {
        "A": "메모리 해제",
        "B": "객체 초기화",
        "C": "메서드 호출",
        "D": "변수 선언"
      },
      "correctAnswer": "B"
    },
    {
      "id": "u2m4",
      "type": "mcq",
      "question": "this 키워드의 용도는 무엇인가?",
      "options": {
        "A": "정적 메서드를 호출한다",
        "B": "부모 객체를 참조한다",
        "C": "현재 객체의 인스턴스를 참조한다",
        "D": "생성자를 호출한다"
      },
      "correctAnswer": "C"
    },
    {
      "id": "u2m5",
      "type": "mcq",
      "question": "생성자 오버로딩에 대해 올바른 설명은 무엇인가?",
      "options": {
        "A": "오버로딩된 생성자는 상속된다",
        "B": "생성자 오버로딩은 불가능하다",
        "C": "오버로딩된 생성자는 자동 호출된다",
        "D": "동일한 이름의 생성자를 매개변수로 구분하여 여러 개 정의할 수 있다"
      },
      "correctAnswer": "D"
    },
    {
      "id": "u2m6",
      "type": "mcq",
      "question": "메서드 오버로딩과 오버라이딩의 차이점은 무엇인가?",
      "options": {
        "A": "오버로딩은 같은 이름의 메서드를 매개변수로 구분하여 정의하는 것이고, 오버라이딩은 상속받은 메서드를 재정의하는 것이다",
        "B": "두 개념은 동일하다",
        "C": "오버로딩은 컴파일 타임 다형성, 오버라이딩은 런타임 다형성을 구현한다",
        "D": "A와 C 모두"
      },
      "correctAnswer": "D"
    },
    {
      "id": "u2m7",
      "type": "mcq",
      "question": "정적(static) 메서드는 객체 생성 없이 호출이 가능한가?",
      "options": {
        "A": "맞다",
        "B": "틀리다",
        "C": "객체 생성 후 호출해야 한다",
        "D": "추상 클래스에서만 가능하다"
      },
      "correctAnswer": "A"
    },
    {
      "id": "u2m8",
      "type": "mcq",
      "question": "메서드 오버라이딩 시, 부모 메서드의 접근제한자보다 좁은 접근제한자를 사용할 수 있는가?",
      "options": {
        "A": "가능하다",
        "B": "아니다",
        "C": "일부 경우 가능하다",
        "D": "컴파일러가 자동 조정한다"
      },
      "correctAnswer": "B"
    },
    {
      "id": "u2m9",
      "type": "mcq",
      "question": "생성자 내부에서 다른 생성자를 호출할 때 사용하는 키워드는 무엇인가?",
      "options": {
        "A": "new()",
        "B": "super()",
        "C": "this()",
        "D": "call()"
      },
      "correctAnswer": "C"
    },
    {
      "id": "u2m10",
      "type": "mcq",
      "question": "반환형이 void인 메서드는 값을 반환하는가?",
      "options": {
        "A": "빈 문자열을 반환한다",
        "B": "null을 반환한다",
        "C": "0을 반환한다",
        "D": "아무것도 반환하지 않는다"
      },
      "correctAnswer": "D"
    },
    {
      "id": "u2m11",
      "type": "mcq",
      "question": "객체지향 프로그래밍에서 캡슐화(encapsulation)의 의미는 무엇인가?",
      "options": {
        "A": "데이터를 보호하고 은닉하는 것이다",
        "B": "상속을 가능하게 하는 것이다",
        "C": "메서드 오버로딩이다",
        "D": "클래스의 확장이다"
      },
      "correctAnswer": "A"
    },
    {
      "id": "u2m12",
      "type": "mcq",
      "question": "메서드 오버라이딩 시, 부모 클래스의 메서드를 호출하기 위해 사용하는 키워드는 무엇인가?",
      "options": {
        "A": "this",
        "B": "super",
        "C": "parent",
        "D": "base"
      },
      "correctAnswer": "B"
    },
    {
      "id": "u2m13",
      "type": "mcq",
      "question": "자바의 생성자는 반환값을 가지는가?",
      "options": {
        "A": "null을 반환한다",
        "B": "0을 반환한다",
        "C": "아니다",
        "D": "컴파일러가 자동 생성한다"
      },
      "correctAnswer": "C"
    },
    {
      "id": "u2m14",
      "type": "mcq",
      "question": "생성자 내에서 다른 생성자를 호출할 때, 그 호출은 반드시 생성자의 첫 번째 문장에 작성되어야 한다.",
      "options": {
        "A": "무관하다",
        "B": "틀리다",
        "C": "상황에 따라 다르다",
        "D": "맞다"
      },
      "correctAnswer": "D"
    },
    {
      "id": "u2m15",
      "type": "mcq",
      "question": "메서드 오버로딩이 가능한 이유는 무엇인가?",
      "options": {
        "A": "매개변수의 타입이나 개수로 구분되기 때문",
        "B": "반환형으로 구분되기 때문",
        "C": "접근제한자로 구분되기 때문",
        "D": "예외 선언으로 구분된다"
      },
      "correctAnswer": "A"
    },
    {
      "id": "u2m16",
      "type": "mcq",
      "question": "객체 생성 시, 부모 클래스의 생성자가 먼저 호출되는 이유는 무엇인가?",
      "options": {
        "A": "객체 초기화를 위해서",
        "B": "메모리 할당을 위해서",
        "C": "자식 클래스의 생성자 호출 전에 반드시 실행되어야 하기 때문",
        "D": "접근제한자 때문"
      },
      "correctAnswer": "C"
    },
    {
      "id": "u2m17",
      "type": "mcq",
      "question": "자바에서 메서드 시그니처에 포함되지 않는 것은 무엇인가?",
      "options": {
        "A": "메서드 이름",
        "B": "매개변수 목록",
        "C": "반환형",
        "D": "예외 선언"
      },
      "correctAnswer": "C"
    },
    {
      "id": "u2m18",
      "type": "mcq",
      "question": "메서드 내에서 선언된 지역 변수의 유효 범위는 어디인가?",
      "options": {
        "A": "해당 메서드 내",
        "B": "클래스 전체",
        "C": "패키지 전체",
        "D": "전역 변수와 동일하다"
      },
      "correctAnswer": "A"
    },
    {
      "id": "u2m19",
      "type": "mcq",
      "question": "객체지향 프로그래밍에서 다형성이란 무엇을 의미하는가?",
      "options": {
        "A": "객체의 내부 구조 및 데이터를 캡슐처럼 감싸 외부에서 직접 볼 수 없게 은닉하여 보호하는 것",
        "B": "동일한 인터페이스로 다양한 구현을 제공하는 것",
        "C": "기존의 클래스를 재활용하여 새로운 클래스를 작성하는 자바의 문법 요소",
        "D": "객체의 공통적인 특성을 추출하여 인터페이스나 추상 클래스로 정의하는 것"
      },
      "correctAnswer": "B"
    },
    {
      "id": "u2m20",
      "type": "mcq",
      "question": "메서드 호출 시, 인자의 값은 어떤 방식으로 전달되는가?",
      "options": {
        "A": "전역 변수 사용",
        "B": "참조에 의한 전달",
        "C": "포인터 전달",
        "D": "값에 의한 전달"
      },
      "correctAnswer": "D"
    },
    {
      "id": "u2m21",
      "type": "mcq",
      "question": "생성자 오버로딩 시, 기본 생성자가 자동으로 생성되는 조건은 무엇인가?",
      "options": {
        "A": "상속 관계에 있을 때",
        "B": "항상 자동 생성된다",
        "C": "클래스에 다른 생성자가 없을 때",
        "D": "정적 생성자가 있을 때"
      },
      "correctAnswer": "C"
    },
    {
      "id": "u2m22",
      "type": "mcq",
      "question": "반환형이 void인 메서드는 어떤 값을 반환하는가?",
      "options": {
        "A": "false",
        "B": "null",
        "C": "0",
        "D": "아무것도 반환하지 않는다"
      },
      "correctAnswer": "D"
    },
    {
      "id": "u2m23",
      "type": "mcq",
      "question": "객체지향 프로그래밍에서 추상화(abstraction)의 의미는 무엇인가?",
      "options": {
        "A": "복잡한 시스템을 단순한 모델로 표현하는 것",
        "B": "데이터를 암호화하는 것",
        "C": "메서드 오버라이딩",
        "D": "상속을 의미한다"
      },
      "correctAnswer": "A"
    },
    {
      "id": "u2m24",
      "type": "mcq",
      "question": "메서드 호출 시, 여러 개의 매개변수를 구분하는 기준은 무엇인가?",
      "options": {
        "A": "반환형",
        "B": "매개변수의 개수와 타입",
        "C": "메서드 이름",
        "D": "접근제한자"
      },
      "correctAnswer": "B"
    },
    {
      "id": "u2m25",
      "type": "mcq",
      "question": "생성자 내에서 멤버 변수를 초기화할 때 this 키워드를 사용하는 이유는 무엇인가?",
      "options": {
        "A": "정적 변수를 호출하기 위함",
        "B": "부모 변수를 호출하기 위함",
        "C": "이름 충돌을 피하기 위함",
        "D": "메서드를 호출하기 위함"
      },
      "correctAnswer": "C"
    },
    {
      "id": "u2m26",
      "type": "mcq",
      "question": "상속이란 무엇을 의미하는가?",
      "options": {
        "A": "변수 복사",
        "B": "두 객체를 연결하는 것",
        "C": "메서드 오버로딩",
        "D": "기존 클래스로부터 새로운 클래스를 만드는 것"
      },
      "correctAnswer": "D"
    },
    {
      "id": "u2m27",
      "type": "mcq",
      "question": "자바에서 기본 생성자가 자동으로 생성되는 경우는 언제인가?",
      "options": {
        "A": "클래스에 생성자가 정의되어 있지 않을 때",
        "B": "클래스에 하나 이상의 생성자가 있을 때",
        "C": "항상",
        "D": "상속 관계에서만"
      },
      "correctAnswer": "A"
    },
    {
      "id": "u2m28",
      "type": "mcq",
      "question": "반환형이 void인 메서드의 특징은 무엇인가?",
      "options": {
        "A": "null을 반환하다",
        "B": "값을 반환하지 않는다",
        "C": "0을 반환한다",
        "D": "빈 문자열을 반환한다"
      },
      "correctAnswer": "B"
    },
    {
      "id": "u2m29",
      "type": "mcq",
      "question": "객체지향 프로그래밍에서 다형성을 구현하는 한 가지 방법은 무엇인가?",
      "options": {
        "A": "변수 재선언",
        "B": "생성자 오버로딩",
        "C": "메서드 오버로딩과 오버라이딩",
        "D": "인터페이스 사용"
      },
      "correctAnswer": "C"
    },
    {
      "id": "u2m30",
      "type": "mcq",
      "question": "객체 생성 시 부모 클래스의 생성자가 먼저 호출되는 이유는 무엇에 기반하는가?",
      "options": {
        "A": "접근제한자",
        "B": "객체 초기화",
        "C": "메모리 할당",
        "D": "클래스 상속 구조"
      },
      "correctAnswer": "D"
    },
    {
      "id": "u2m31",
      "type": "mcq",
      "question": "자바에서 메서드 시그니처에 포함되는 요소는 무엇인가?",
      "options": {
        "A": "메서드 이름과 매개변수 목록",
        "B": "반환형",
        "C": "접근제한자",
        "D": "예외 목록"
      },
      "correctAnswer": "A"
    },
    {
      "id": "u2m32",
      "type": "mcq",
      "question": "정적 메서드는 인스턴스 변수에 접근할 수 있는가?",
      "options": {
        "A": "가능하다",
        "B": "아니다",
        "C": "조건부로 가능하다",
        "D": "컴파일러가 결정한다"
      },
      "correctAnswer": "B"
    },
    {
      "id": "u2m33",
      "type": "mcq",
      "question": "객체지향 프로그래밍에서 캡슐화의 주요 목적은 무엇인가?",
      "options": {
        "A": "다형성 구현",
        "B": "코드 재사용",
        "C": "데이터 보호와 은닉",
        "D": "상속 촉진"
      },
      "correctAnswer": "C"
    },
    {
      "id": "u2m34",
      "type": "mcq",
      "question": "메서드 오버라이딩 시 부모 클래스의 메서드와 자식 클래스의 메서드 시그니처는 어떻게 되어야 하는가?",
      "options": {
        "A": "접근제한자만 동일하면 된다",
        "B": "반환형만 동일하면 된다",
        "C": "매개변수만 동일하면 된다",
        "D": "동일해야 한다"
      },
      "correctAnswer": "D"
    },
    {
      "id": "u2m35",
      "type": "mcq",
      "question": "자바에서 모든 클래스의 최상위 클래스는 무엇인가?",
      "options": {
        "A": "Object",
        "B": "Class",
        "C": "String",
        "D": "System"
      },
      "correctAnswer": "A"
    },
    {
      "id": "u2m36",
      "type": "mcq",
      "question": "객체 생성 시, 생성자가 호출되는 순서는 어떻게 결정되는가?",
      "options": {
        "A": "자식부터 호출된다",
        "B": "상속 구조에 따라 부모부터 호출된다",
        "C": "임의로 호출된다",
        "D": "동시에 호출된다"
      },
      "correctAnswer": "B"
    },
    {
      "id": "u2m37",
      "type": "mcq",
      "question": "this 키워드와 super 키워드의 차이는 무엇인가?",
      "options": {
        "A": "super는 정적 메서드를 호출한다",
        "B": "둘은 동일하다",
        "C": "this는 현재 객체, super는 부모 객체를 참조한다",
        "D": "this는 생성자에서만 사용된다"
      },
      "correctAnswer": "C"
    },
    {
      "id": "u2m38",
      "type": "mcq",
      "question": "메서드 오버로딩은 컴파일 타임 다형성의 한 예이다. 이 설명은 옳은가?",
      "options": {
        "A": "적용되지 않는다",
        "B": "틀리다",
        "C": "일부 경우 옳다",
        "D": "옳다"
      },
      "correctAnswer": "D"
    },
    {
      "id": "u2m39",
      "type": "mcq",
      "question": "생성자에서 멤버 변수를 초기화하는 또 다른 방법으로 올바른 것은 무엇인가?",
      "options": {
        "A": "초기화 블록을 사용하는 것",
        "B": "메서드 오버로딩을 사용하는 것",
        "C": "정적 메서드를 호출하는 것",
        "D": "super()를 호출하는 것"
      },
      "correctAnswer": "A"
    },
    {
      "id": "u2m40",
      "type": "mcq",
      "question": "여러 생성자 중 호출될 생성자는 어떻게 결정되는가?",
      "options": {
        "A": "항상 기본 생성자가 호출된다",
        "B": "인자의 개수와 타입에 따라 결정된다",
        "C": "임의로 결정된다",
        "D": "마지막에 정의된 생성자가 호출된다"
      },
      "correctAnswer": "B"
    },
    {
      "id": "u2m41",
      "type": "mcq",
      "question": "자바에서 메서드의 파라미터 전달 방식은 무엇인가?",
      "options": {
        "A": "포인터 전달",
        "B": "참조에 의한 전달",
        "C": "값에 의한 전달",
        "D": "복사 전달"
      },
      "correctAnswer": "C"
    },
    {
      "id": "u2m42",
      "type": "mcq",
      "question": "객체지향 프로그래밍에서 캡슐화의 개념은 무엇을 의미하는가?",
      "options": {
        "A": "다형성 구현",
        "B": "상속을 통한 코드 재사용",
        "C": "메서드 오버로딩",
        "D": "데이터와 메서드를 하나의 객체로 묶는 것"
      },
      "correctAnswer": "D"
    },
    {
      "id": "u2m43",
      "type": "mcq",
      "question": "메서드 오버라이딩 시, 부모 클래스의 메서드를 재정의할 때 반드시 포함되어야 하는 것은 무엇인가?",
      "options": {
        "A": "메서드 이름과 매개변수 목록",
        "B": "반환형",
        "C": "접근제한자",
        "D": "예외 선언"
      },
      "correctAnswer": "A"
    },
    {
      "id": "u2m44",
      "type": "mcq",
      "question": "정적 메서드에서 인스턴스 변수에 접근할 수 없는 이유는 무엇인가?",
      "options": {
        "A": "인스턴스 변수가 private이기 때문",
        "B": "정적 메서드는 객체와 무관하기 때문",
        "C": "메모리 부족",
        "D": "컴파일러 오류 때문이다"
      },
      "correctAnswer": "B"
    },
    {
      "id": "u2m45",
      "type": "mcq",
      "question": "생성자와 메서드의 차이점은 무엇인가?",
      "options": {
        "A": "생성자는 반환값이 있다",
        "B": "둘은 동일하다",
        "C": "생성자는 객체 초기화, 메서드는 기능 수행",
        "D": "메서드는 클래스 이름과 동일하다"
      },
      "correctAnswer": "C"
    },
    {
      "id": "u2m46",
      "type": "mcq",
      "question": "메서드 오버로딩 시, 매개변수의 순서도 중요한 구분 요소에 포함되는가?",
      "options": {
        "A": "접근제한자에 따라 다르다",
        "B": "아니다",
        "C": "반환형에 따라 다르다",
        "D": "예, 순서도 구분된다"
      },
      "correctAnswer": "D"
    },
    {
      "id": "u2m47",
      "type": "mcq",
      "question": "자바에서 생성자와 일반 메서드는 어떻게 구분되는가?",
      "options": {
        "A": "생성자는 클래스 이름과 동일하며 반환형이 없다",
        "B": "둘은 구분되지 않는다",
        "C": "생성자는 static이다",
        "D": "메서드는 항상 void이다"
      },
      "correctAnswer": "A"
    },
    {
      "id": "u2m48",
      "type": "mcq",
      "question": "객체지향 프로그래밍에서 상속의 주요 이점은 무엇인가?",
      "options": {
        "A": "메모리 절약",
        "B": "코드 재사용과 확장",
        "C": "성능 향상",
        "D": "보안 강화"
      },
      "correctAnswer": "B"
    },
    {
      "id": "u2m49",
      "type": "mcq",
      "question": "자바에서 모든 클래스의 최상위 클래스는 무엇인가?",
      "options": {
        "A": "String",
        "B": "Class",
        "C": "Object",
        "D": "System"
      },
      "correctAnswer": "C"
    },
    {
      "id": "u2m50",
      "type": "mcq",
      "question": "메서드 오버라이딩 시, 자식 클래스의 메서드 반환형은 부모 클래스의 메서드 반환형과 어떻게 되어야 하는가?",
      "options": {
        "A": "공변 반환형을 사용할 수 있다",
        "B": "반드시 동일해야 한다",
        "C": "전혀 상관없다",
        "D": "자식 메서드가 더 넓어야 한다"
      },
      "correctAnswer": "A"
    },
    {
      "id": "q1",
      "type": "code",
      "question": "매개변수가 없는 생성자를 사용하여 MyClass 객체를 생성하는 코드를 완성하시오.",
      "codeSnippet": "MyClass obj = new __();",
      "answers": ["MyClass"]
    },
    {
      "id": "q2",
      "type": "code",
      "question": "두 개의 정수 매개변수를 받아 인스턴스 변수 a와 b를 초기화하는 생성자를 정의하는 코드를 완성하시오.",
      "codeSnippet": "public MyClass(__ a, __ b) { this.a = a; this.b = b; }",
      "answers": ["int", "int"]
    },
    {
      "id": "q3",
      "type": "code",
      "question": "매개변수 value를 인스턴스 변수 value에 대입할 때, this 키워드를 사용하여 코드를 완성하시오.",
      "codeSnippet": "public void setValue(int value) { __ = value; }",
      "answers": ["this.value"]
    },
    {
      "id": "q4",
      "type": "code",
      "question": "기본 생성자에서 매개변수가 하나인 생성자를 호출하는 생성자 체이닝 코드를 완성하시오. (기본 값은 0)",
      "codeSnippet": "public MyClass() { __(0); }",
      "answers": ["this"]
    },
    {
      "id": "q5",
      "type": "code",
      "question": "클래스 내부에서 올바른 생성자 이름을 사용하여 MyClass의 생성자를 선언하는 코드를 완성하시오.",
      "codeSnippet": "class MyClass { public __() { } }",
      "answers": ["MyClass"]
    },
    {
      "id": "q6",
      "type": "code",
      "question": "콘솔에 \"Hello\"를 출력하고 반환값이 없는 메서드 display를 선언하는 코드를 완성하시오.",
      "codeSnippet": "public __ display() { System.out.println(\"Hello\"); }",
      "answers": ["void"]
    },
    {
      "id": "q7",
      "type": "code",
      "question": "정수 매개변수 하나를 받는 compute 메서드를 선언할 때, 매개변수의 자료형을 완성하시오.",
      "codeSnippet": "public void compute(__ a) { }",
      "answers": ["int"]
    },
    {
      "id": "q8",
      "type": "code",
      "question": "매개변수 a를 인스턴스 변수 a에 대입할 때 this 키워드를 사용하여 코드를 완성하시오.",
      "codeSnippet": "public void setA(int a) { __ = a; }",
      "answers": ["this.a"]
    },
    {
      "id": "q9",
      "type": "code",
      "question": "정수 매개변수를 받는 생성자 내부에서 다른 생성자(두 개의 매개변수를 받는)를 호출하여 a와 0으로 초기화하는 코드를 완성하시오.",
      "codeSnippet": "public MyClass(int a) { __(a, 0); }",
      "answers": ["this"]
    },
    {
      "id": "q10",
      "type": "code",
      "question": "인스턴스 변수 a의 값을 반환하는 getter 메서드 getA를 완성하시오.",
      "codeSnippet": "public int getA() { return __; }",
      "answers": ["a"]
    },
    {
      "id": "q11",
      "type": "code",
      "question": "정적 메서드 main 내부에서 클래스 이름을 사용하여 정적 메서드 method를 호출하는 코드를 완성하시오.",
      "codeSnippet": "public static void main(String[] args) { __.method(); }",
      "answers": ["MyClass"]
    },
    {
      "id": "q12",
      "type": "code",
      "question": "클래스 변수 count에 접근하기 위해 클래스 이름을 사용하여 값을 출력하는 코드를 완성하시오.",
      "codeSnippet": "System.out.println(__.count);",
      "answers": ["MyClass"]
    },
    {
      "id": "q13",
      "type": "code",
      "question": "정수를 출력하는 print 메서드를 선언할 때, 매개변수의 자료형을 완성하시오.",
      "codeSnippet": "public void print(__ x) { System.out.println(x); }",
      "answers": ["int"]
    },
    {
      "id": "q14",
      "type": "code",
      "question": "기본 생성자에서 다른 생성자를 호출하는 생성자 체이닝 예제를 완성하시오.",
      "codeSnippet": "public MyClass() { __(); }",
      "answers": ["this"]
    },
    {
      "id": "q15",
      "type": "code",
      "question": "MyClass 객체를 10개 담을 수 있는 배열을 선언하는 코드를 완성하시오.",
      "codeSnippet": "MyClass[] arr = new MyClass[__];",
      "answers": ["10"]
    },
    {
      "id": "q16",
      "type": "code",
      "question": "인스턴스 변수 value를 반환하는 getter 메서드 getValue를 완성하시오.",
      "codeSnippet": "public __ getValue() { return value; }",
      "answers": ["int"]
    },
    {
      "id": "q17",
      "type": "code",
      "question": "정적 팩토리 메서드 getInstance를 선언할 때, 반환형을 올바르게 지정하여 코드를 완성하시오.",
      "codeSnippet": "public static __ getInstance() { return instance; }",
      "answers": ["MyClass"]
    },
    {
      "id": "q18",
      "type": "code",
      "question": "this 키워드를 사용하여 인스턴스 변수 value에 100을 대입하는 코드를 완성하시오.",
      "codeSnippet": "this.__ = 100;",
      "answers": ["value"]
    },
    {
      "id": "q19",
      "type": "code",
      "question": "객체 obj의 display 메서드를 호출하는 코드를 완성하시오.",
      "codeSnippet": "obj.__();",
      "answers": ["display"]
    },
    {
      "id": "q20",
      "type": "code",
      "question": "문자열 인스턴스 변수 name을 반환하는 getName 메서드를 완성하시오.",
      "codeSnippet": "public String getName() { return __; }",
      "answers": ["name"]
    },
    {
      "id": "q21",
      "type": "code",
      "question": "생성자 내부에서 매개변수 a를 인스턴스 변수 a에 대입할 때, 모호성을 해결하기 위해 올바른 키워드를 사용하여 코드를 완성하시오.",
      "codeSnippet": "public MyClass(int a) { __ = a; }",
      "answers": ["this.a"]
    },
    {
      "id": "q22",
      "type": "code",
      "question": "메서드 오버로딩의 예제로, 하나는 정수 하나를 받고 다른 하나는 정수 두 개를 받는 compute 메서드를 선언할 때, 두 번째 메서드의 매개변수 자료형을 완성하시오.",
      "codeSnippet": "public void compute(int a) { } public void compute(__ a, __ b) { }",
      "answers": ["int", "int"]
    },
    {
      "id": "q23",
      "type": "code",
      "question": "매개변수 value를 인스턴스 변수 value에 대입할 때, this 키워드를 사용하여 코드를 완성하시오.",
      "codeSnippet": "public void setValue(int value) { __ = value; }",
      "answers": ["this.value"]
    },
    {
      "id": "q24",
      "type": "code",
      "question": "정수 매개변수 5를 전달하여 MyClass 객체를 생성하는 코드를 완성하시오.",
      "codeSnippet": "MyClass obj = new __(5);",
      "answers": ["MyClass"]
    },
    {
      "id": "q25",
      "type": "code",
      "question": "인스턴스 변수 result를 반환하는 getResult 메서드를 완성하시오.",
      "codeSnippet": "public __ getResult() { return result; }",
      "answers": ["int"]
    },
    {
      "id": "u2s1",
      "type": "subjective",
      "question": "객체지향 프로그래밍의 4대 원칙(캡슐화, 상속, 다형성, 추상화)에 대해 설명하시오.",
      "correctAnswer": "객체지향 프로그래밍은 캡슐화, 상속, 다형성, 추상화의 네 가지 원칙을 기반으로 하며, 이를 통해 복잡한 시스템을 단순화하고 재사용성을 높인다."
    },
    {
      "id": "u2s2",
      "type": "subjective",
      "question": "생성자의 역할과 필요성에 대해 서술하시오.",
      "correctAnswer": "생성자는 객체가 생성될 때 멤버 변수를 초기화하고, 필요한 초기 설정을 수행하는 특별한 메서드로, 객체의 상태를 올바르게 구성하는 데 필요하다."
    },
    {
      "id": "u2s3",
      "type": "subjective",
      "question": "this 키워드의 역할과 사용법에 대해 설명하시오.",
      "correctAnswer": "this 키워드는 현재 객체의 인스턴스를 참조하는 데 사용되며, 주로 매개변수와 멤버 변수의 이름이 충돌할 때 구분하여 사용한다."
    },
    {
      "id": "u2s4",
      "type": "subjective",
      "question": "메서드 오버로딩과 오버라이딩의 차이에 대해 서술하시오.",
      "correctAnswer": "오버로딩은 같은 이름의 메서드를 매개변수로 구분하여 여러 개 정의하는 것이며, 오버라이딩은 상속받은 메서드를 자식 클래스에서 재정의하는 것이다."
    },
    {
      "id": "u2s5",
      "type": "subjective",
      "question": "생성자 체이닝(this() 호출)의 장단점에 대해 설명하시오.",
      "correctAnswer": "생성자 체이닝은 중복 코드를 줄여 초기화를 일관되게 관리할 수 있지만, 코드 가독성이 떨어질 수 있다는 단점이 있다."
    },
    {
      "id": "u2s6",
      "type": "subjective",
      "question": "정적 메서드와 인스턴스 메서드의 차이점에 대해 설명하시오.",
      "correctAnswer": "정적 메서드는 객체 생성 없이 클래스 이름으로 호출되며, 인스턴스 메서드는 객체의 상태에 의존하여 동작한다."
    },
    {
      "id": "u2s7",
      "type": "subjective",
      "question": "객체 생성 시 메모리 할당 과정에 대해 설명하시오.",
      "correctAnswer": "객체는 new 연산자를 통해 힙 영역에 생성되며, 생성자에 의해 초기화된다. 이후 가비지 컬렉션에 의해 관리된다."
    },
    {
      "id": "u2s8",
      "type": "subjective",
      "question": "메서드 오버라이딩 시 접근제한자 규칙에 대해 설명하시오.",
      "correctAnswer": "오버라이딩된 메서드는 부모 메서드의 접근제한자보다 좁은 접근제한자를 사용할 수 없으며, 보통 부모와 동일하거나 더 넓은 범위로 선언되어야 한다."
    },
    {
      "id": "u2s9",
      "type": "subjective",
      "question": "캡슐화의 개념과 그 장점에 대해 서술하시오.",
      "correctAnswer": "캡슐화는 데이터와 메서드를 하나의 객체로 묶어 외부로부터 데이터를 보호하고, 인터페이스를 통해 접근하도록 하여 유지보수와 보안 측면에서 유리하다."
    },
    {
      "id": "u2s10",
      "type": "subjective",
      "question": "상속이 객체지향 프로그래밍에서 중요한 이유는 무엇인지 설명하시오.",
      "correctAnswer": "상속은 기존 클래스의 기능을 재사용하고 확장할 수 있게 하여 코드의 중복을 줄이고, 유지보수를 쉽게 한다."
    },
    {
      "id": "u2s11",
      "type": "subjective",
      "question": "다형성의 개념과 이를 활용한 예제에 대해 설명하시오.",
      "correctAnswer": "다형성은 동일한 인터페이스를 사용해 여러 형태의 객체가 서로 다른 동작을 할 수 있도록 하는 개념으로, 예를 들어 부모 타입의 참조변수로 자식 객체들을 다루는 경우를 들 수 있다."
    },
    {
      "id": "u2s12",
      "type": "subjective",
      "question": "생성자와 일반 메서드의 차이점에 대해 설명하시오.",
      "correctAnswer": "생성자는 객체 생성 시 초기화를 담당하며 반환형이 없고, 일반 메서드는 객체의 기능을 수행하며 반환형을 가진다."
    },
    {
      "id": "u2s13",
      "type": "subjective",
      "question": "자바에서 생성자 오버로딩이 가능한 이유에 대해 서술하시오.",
      "correctAnswer": "생성자 오버로딩은 매개변수의 개수와 타입에 따라 서로 다른 생성자를 정의할 수 있어, 다양한 방식으로 객체를 초기화할 수 있게 해준다."
    },
    {
      "id": "u2s14",
      "type": "subjective",
      "question": "객체지향 설계 원칙 중 SOLID 원칙 중 하나를 선택하여 간략히 설명하시오.",
      "correctAnswer": "예를 들어, 단일 책임 원칙(Single Responsibility Principle)은 클래스가 하나의 책임만 가져야 한다는 원칙으로, 이를 통해 코드의 유지보수성과 재사용성을 높일 수 있다."
    },
    {
      "id": "u2s15",
      "type": "subjective",
      "question": "메서드 내에서 지역 변수와 인스턴스 변수의 차이에 대해 설명하시오.",
      "correctAnswer": "지역 변수는 메서드 내부에서 선언되어 그 메서드 내에서만 유효하고, 인스턴스 변수는 클래스의 각 객체에 속하며 객체 전체에서 사용된다."
    },
    {
      "id": "u2s16",
      "type": "subjective",
      "question": "this 키워드를 사용함으로써 얻는 이점에 대해 논하시오.",
      "correctAnswer": "this 키워드는 현재 객체를 명확하게 참조함으로써, 매개변수와 멤버 변수의 이름 충돌을 방지하고 객체의 상태를 올바르게 다룰 수 있게 해준다."
    },
    {
      "id": "u2s17",
      "type": "subjective",
      "question": "생성자 내부에서 다른 생성자를 호출하는 이유와 그 장점을 설명하시오.",
      "correctAnswer": "생성자 체이닝을 통해 중복되는 초기화 코드를 줄이고, 여러 생성자 간의 일관성을 유지할 수 있다."
    },
    {
      "id": "u2s18",
      "type": "subjective",
      "question": "재귀 호출(recursion)의 개념과 활용에 대해 설명하시오.",
      "correctAnswer": "재귀 호출은 메서드가 자기 자신을 호출하는 것으로, 문제를 작은 단위로 분할하여 해결하는 데 유용하지만, 종료 조건이 반드시 필요하다."
    },
    {
      "id": "u2s19",
      "type": "subjective",
      "question": "메서드 오버로딩이 컴파일 타임 다형성에 미치는 영향을 설명하시오.",
      "correctAnswer": "메서드 오버로딩은 컴파일러가 호출할 메서드를 결정하므로, 컴파일 타임 다형성을 구현하는 한 방법이다."
    },
    {
      "id": "u2s20",
      "type": "subjective",
      "question": "객체지향 프로그래밍에서 추상화의 중요성에 대해 서술하시오.",
      "correctAnswer": "추상화는 복잡한 시스템을 단순화하여 핵심 개념에 집중할 수 있게 하며, 코드의 이해와 유지보수를 용이하게 한다."
    },
    {
      "id": "u2s21",
      "type": "subjective",
      "question": "메서드 오버라이딩을 사용할 때 주의해야 할 사항은 무엇인지 설명하시오.",
      "correctAnswer": "부모 클래스의 메서드와 동일한 시그니처를 유지해야 하며, 접근제한자 및 예외 선언에도 주의를 기울여야 한다."
    },
    {
      "id": "u2s22",
      "type": "subjective",
      "question": "정적 메서드와 인스턴스 메서드의 용도 차이에 대해 논하시오.",
      "correctAnswer": "정적 메서드는 객체 생성 없이 클래스 수준에서 사용되며, 인스턴스 메서드는 각 객체의 상태에 따라 동작한다."
    },
    {
      "id": "u2s23",
      "type": "subjective",
      "question": "객체 생성 시 생성자 호출 순서가 중요한 이유에 대해 설명하시오.",
      "correctAnswer": "부모 클래스의 생성자가 먼저 호출되어 기본적인 초기화가 이루어진 후 자식 클래스의 생성자가 호출되므로, 상속 관계에 따른 초기화 순서를 보장한다."
    },
    {
      "id": "u2s24",
      "type": "subjective",
      "question": "자바에서 생성자 없이 객체를 생성할 수 있는 경우에 대해 설명하시오.",
      "correctAnswer": "생성자를 명시적으로 정의하지 않으면 컴파일러가 기본 생성자를 자동으로 생성하므로, 개발자가 별도로 생성자를 작성하지 않아도 객체를 생성할 수 있다."
    },
    {
      "id": "u2s25",
      "type": "subjective",
      "question": "객체지향 프로그래밍에서 상속의 단점과 이를 극복하는 방법에 대해 논하시오.",
      "correctAnswer": "상속은 강한 결합을 초래할 수 있어 코드 변경 시 영향이 클 수 있으며, 이를 극복하기 위해 인터페이스나 구성(composition) 방식을 사용할 수 있다."
    }
  ],
  "unit3": [
    {
      "id": "u3m1",
      "type": "mcq",
      "question": "상속의 개념에 대해 올바른 설명은 무엇인가?",
      "options": {
        "A": "자식 클래스가 부모 클래스의 멤버와 메서드를 상속받는다.",
        "B": "부모 클래스가 자식 클래스의 멤버를 상속받는다.",
        "C": "모든 클래스는 서로 독립적이다.",
        "D": "상속은 단순히 메모리 절약을 위한 것이다."
      },
      "correctAnswer": "A"
    },
    {
      "id": "u3m2",
      "type": "mcq",
      "question": "메서드 재정의(오버라이딩) 시, 부모 메서드와 자식 메서드의 조건으로 올바른 것은 무엇인가?",
      "options": {
        "A": "메서드 이름이 다르면 오버라이딩이다.",
        "B": "메서드 이름, 매개변수, 반환형이 모두 동일해야 한다.",
        "C": "반환형은 달라도 오버라이딩이 가능하다.",
        "D": "접근제한자는 무시된다."
      },
      "correctAnswer": "B"
    },
    {
      "id": "u3m3",
      "type": "mcq",
      "question": "부모 클래스의 private 멤버는 자식 클래스에 어떻게 상속되는가?",
      "options": {
        "A": "자식 클래스에서 직접 접근할 수 있다.",
        "B": "상속되지만 자식 클래스에서 직접 접근할 수 없다.",
        "C": "상속되지 않는다.",
        "D": "자동으로 protected로 변경되어 상속된다."
      },
      "correctAnswer": "B"
    },
    {
      "id": "u3m4",
      "type": "mcq",
      "question": "메서드 오버라이딩 시, 부모 메서드와 자식 메서드의 접근제한자 규칙에 대해 올바른 설명은 무엇인가?",
      "options": {
        "A": "자식 메서드는 부모 메서드보다 좁은 접근제한자를 사용할 수 있다.",
        "B": "부모 메서드와 자식 메서드는 동일한 접근제한자만 사용할 수 있다.",
        "C": "자식 메서드는 부모 메서드보다 넓은 접근제한자를 사용해야 한다.",
        "D": "접근제한자는 오버라이딩에 영향을 주지 않는다."
      },
      "correctAnswer": "C"
    },
    {
      "id": "u3m5",
      "type": "mcq",
      "question": "상속에서 'super' 키워드의 역할은 무엇인가?",
      "options": {
        "A": "자식 클래스의 멤버를 호출한다.",
        "B": "현재 객체를 참조한다.",
        "C": "부모 클래스의 생성자나 메서드를 호출한다.",
        "D": "클래스의 정적 메서드를 호출한다."
      },
      "correctAnswer": "C"
    },
    {
      "id": "u3m6",
      "type": "mcq",
      "question": "공변 반환형(covariant return type)이란 무엇을 의미하는가?",
      "options": {
        "A": "자식 클래스 타입의 객체를 반환할 수 있다.",
        "B": "부모 클래스 타입의 객체만 반환할 수 있다.",
        "C": "반환형은 오버라이딩 시 변경할 수 없다.",
        "D": "자식 클래스의 메서드는 부모의 반환형의 하위 타입을 반환할 수 있다."
      },
      "correctAnswer": "D"
    },
    {
      "id": "u3m7",
      "type": "mcq",
      "question": "메서드 오버라이딩 시, 부모 클래스의 메서드와 자식 클래스의 메서드가 동일한 시그니처를 가져야 하는 이유는 무엇인가?",
      "options": {
        "A": "메서드 이름만 같으면 충분하다.",
        "B": "메서드 이름, 매개변수, 그리고 반환형이 동일해야 정확한 바인딩이 가능하다.",
        "C": "반환형은 달라도 상관없다.",
        "D": "접근제한자만 동일하면 된다."
      },
      "correctAnswer": "B"
    },
    {
      "id": "u3m8",
      "type": "mcq",
      "question": "상속을 사용하면 코드 재사용성이 높아지는 이유는 무엇인가?",
      "options": {
        "A": "모든 멤버 변수가 공유되기 때문이다.",
        "B": "자식 클래스가 부모 클래스의 모든 메서드를 오버라이딩하기 때문이다.",
        "C": "부모 클래스의 기능을 물려받아 중복 코드를 줄일 수 있기 때문이다.",
        "D": "객체 생성 속도가 빨라지기 때문이다."
      },
      "correctAnswer": "C"
    },
    {
      "id": "u3m9",
      "type": "mcq",
      "question": "메서드 오버로딩과 오버라이딩의 차이점중 옳지 않은 것은?",
      "options": {
        "A": "오버로딩은 같은 이름의 메서드를 매개변수로 구분하여 여러 개 정의하는 것이다.",
        "B": "오버라이딩은 부모 클래스의 메서드를 재정의하는 것이다.",
        "C": "오버라이딩은 부모 클래스의 메서드를 재정의하여 다형성을 구현하는 것이다.",
        "D": "두 개념은 동일하다."
      },
      "correctAnswer": "D"
    },
    {
      "id": "u3m10",
      "type": "mcq",
      "question": "부모 클래스의 final 메서드는 자식 클래스에서 어떻게 되는가?",
      "options": {
        "A": "자식 클래스에서 재정의할 수 없다.",
        "B": "자식 클래스에서 접근은 가능하지만 재정의할 수 없다.",
        "C": "자식 클래스에서 오버라이딩이 가능하다.",
        "D": "부모 클래스의 메서드가 숨겨진다."
      },
      "correctAnswer": "A"
    },
    {
      "id": "u3m11",
      "type": "mcq",
      "question": "자바에서 @Override 어노테이션의 주된 역할은 무엇인가?",
      "options": {
        "A": "부모 클래스의 메서드를 오버라이딩하는 의도를 명시한다.",
        "B": "컴파일러에게 오버라이딩 여부를 확인하도록 지시한다.",
        "C": "메서드의 이름을 변경한다.",
        "D": "메서드를 정적으로 만든다."
      },
      "correctAnswer": "B"
    },
    {
      "id": "u3m12",
      "type": "mcq",
      "question": "자식 클래스에서 부모 클래스의 protected 멤버는 어디서 접근 가능한가?",
      "options": {
        "A": "오직 자식 클래스에서만 접근 가능하다.",
        "B": "같은 패키지 내에서만 접근 가능하다.",
        "C": "같은 패키지와 자식 클래스에서 접근 가능하다.",
        "D": "모든 클래스에서 접근 가능하다."
      },
      "correctAnswer": "C"
    },
    {
      "id": "u3m13",
      "type": "mcq",
      "question": "메서드 오버라이딩 시 반환형에 공변 반환형을 허용하는 이유는 무엇인가?",
      "options": {
        "A": "자식 클래스는 부모 클래스와 완전히 다른 반환형을 사용할 수 있다.",
        "B": "반환형은 오버라이딩 시 고려되지 않는다.",
        "C": "자식 클래스의 메서드는 부모의 반환형과 반드시 동일해야 한다.",
        "D": "자식 클래스의 메서드는 부모의 반환형의 하위 타입을 반환할 수 있다."
      },
      "correctAnswer": "D"
    },
    {
      "id": "u3m14",
      "type": "mcq",
      "question": "부모 클래스의 메서드를 오버라이딩할 때, 부모의 메서드를 호출하려면 어떻게 해야 하는가?",
      "options": {
        "A": "super.method()",
        "B": "this.method()",
        "C": "parent.method()",
        "D": "직접 호출할 수 없다."
      },
      "correctAnswer": "A"
    },
    {
      "id": "u3m15",
      "type": "mcq",
      "question": "메서드 오버로딩은 어느 다형성의 형태에 속하는가?",
      "options": {
        "A": "런타임 다형성",
        "B": "컴파일 타임 다형성",
        "C": "동적 다형성",
        "D": "정적 다형성"
      },
      "correctAnswer": "B"
    },
    {
      "id": "u3m16",
      "type": "mcq",
      "question": "자식 클래스에서 부모 클래스의 메서드를 재정의할 때, 반드시 지켜져야 하는 규칙은 무엇인가?",
      "options": {
        "A": "모든 요소가 동일해야 한다.",
        "B": "메서드 이름과 매개변수만 동일하면 된다.",
        "C": "메서드 이름, 매개변수, 접근제한자 및 예외 선언이 동일해야 한다.",
        "D": "메서드 이름만 동일하면 된다."
      },
      "correctAnswer": "C"
    },
    {
      "id": "u3m17",
      "type": "mcq",
      "question": "상속을 통한 코드 재사용의 단점은 무엇인가?",
      "options": {
        "A": "상속은 항상 장점만 있다.",
        "B": "코드 재사용성이 낮아진다.",
        "C": "객체 생성 속도가 느려진다.",
        "D": "상속 관계가 과도하게 복잡해지면 유지보수가 어려워진다."
      },
      "correctAnswer": "D"
    },
    {
      "id": "u3m18",
      "type": "mcq",
      "question": "자바에서 super() 호출은 주로 언제 사용되는가?",
      "options": {
        "A": "부모 클래스의 생성자를 명시적으로 호출할 때",
        "B": "현재 객체의 생성자를 호출할 때",
        "C": "정적 메서드를 호출할 때",
        "D": "메서드 오버로딩 시 사용된다"
      },
      "correctAnswer": "A"
    },
    {
      "id": "u3m19",
      "type": "mcq",
      "question": "부모 클래스의 메서드를 오버라이딩할 때, 자식 클래스에서 허용되는 반환형 변경은 무엇인가?",
      "options": {
        "A": "전혀 변경할 수 없다.",
        "B": "부모의 반환형과 동일하거나 그 하위 타입이어야 한다.",
        "C": "반환형은 임의로 변경할 수 있다.",
        "D": "오버라이딩 시 반환형은 고려되지 않는다."
      },
      "correctAnswer": "B"
    },
    {
      "id": "u3m20",
      "type": "mcq",
      "question": "메서드 오버로딩 시 구분 기준은 무엇인가?",
      "options": {
        "A": "메서드 이름과 매개변수의 개수, 타입, 순서가 모두 고려된다.",
        "B": "반환형만 고려된다.",
        "C": "접근제한자만 고려된다.",
        "D": "예외 선언만 고려된다."
      },
      "correctAnswer": "A"
    },
    {
      "id": "u3m21",
      "type": "mcq",
      "question": "자식 클래스에서 부모 클래스의 멤버에 접근할 수 없는 경우는 언제인가?",
      "options": {
        "A": "부모 클래스의 public 멤버인 경우",
        "B": "부모 클래스의 protected 멤버인 경우",
        "C": "부모 클래스의 private 멤버인 경우",
        "D": "부모 클래스의 default 멤버인 경우"
      },
      "correctAnswer": "C"
    },
    {
      "id": "u3m22",
      "type": "mcq",
      "question": "메서드 오버라이딩 시, 자식 메서드가 선언할 수 있는 예외 범위에 관한 올바른 설명은 무엇인가?",
      "options": {
        "A": "자식 메서드는 부모 메서드가 선언한 예외보다 좁은 범위의 예외만 선언할 수 있다.",
        "B": "자식 메서드는 부모 메서드와 동일한 예외를 반드시 선언해야 한다.",
        "C": "자식 메서드는 부모 메서드보다 더 많은 예외를 선언할 수 있다.",
        "D": "예외 선언은 오버라이딩에 영향을 주지 않는다."
      },
      "correctAnswer": "A"
    },
    {
      "id": "u3m23",
      "type": "mcq",
      "question": "상속을 통한 코드 재사용의 장점은 무엇인가?",
      "options": {
        "A": "상속은 코드 재사용이 어렵다.",
        "B": "상속을 통해 기존 코드를 재사용하여 개발 시간을 단축할 수 있다.",
        "C": "상속은 코드 재사용과는 무관하다.",
        "D": "상속은 메모리 효율성을 높인다."
      },
      "correctAnswer": "B"
    },
    {
      "id": "u3m24",
      "type": "mcq",
      "question": "메서드 오버라이딩과 오버로딩의 차이점은 무엇인가?",
      "options": {
        "A": "오버로딩은 같은 이름의 메서드를 매개변수로 구분하여 여러 개 정의하는 것이고, 오버라이딩은 부모 클래스의 메서드를 재정의하는 것이다.",
        "B": "오버로딩은 부모 클래스의 메서드를 재정의하는 것이다.",
        "C": "오버라이딩은 메서드 이름이 다르면 발생한다.",
        "D": "오버라이딩은 부모 클래스의 메서드를 재정의하여 다형성을 구현하는 것이다."
      },
      "correctAnswer": "C"
    },
    {
      "id": "u3m25",
      "type": "mcq",
      "question": "자식 클래스에서 부모 클래스의 멤버를 재정의할 때 지켜져야 하는 규칙은 무엇인가?",
      "options": {
        "A": "시그니처는 중요하지 않다.",
        "B": "메서드 이름, 매개변수, 그리고 접근제한자가 동일해야 한다.",
        "C": "반환형은 자유롭게 변경할 수 있다.",
        "D": "오버라이딩은 자동으로 이루어진다."
      },
      "correctAnswer": "B"
    },
    {
      "id": "u3m26",
      "type": "mcq",
      "question": "상속 관계에서 부모 클래스의 생성자가 먼저 호출되는 이유는 무엇인가?",
      "options": {
        "A": "부모 클래스의 초기화가 먼저 이루어져야 하기 때문이다.",
        "B": "자식 클래스의 생성자가 없기 때문이다.",
        "C": "객체 생성 순서에 따라 임의로 결정된다.",
        "D": "컴파일러가 부모 클래스를 먼저 처리하기 때문이다."
      },
      "correctAnswer": "A"
    },
    {
      "id": "u3m27",
      "type": "mcq",
      "question": "자바에서 메서드 시그니처에 포함되는 요소는 무엇인가?",
      "options": {
        "A": "메서드 이름, 매개변수, 반환형, 접근제한자 모두 포함된다.",
        "B": "메서드 이름과 매개변수의 타입 및 순서가 시그니처를 결정한다.",
        "C": "반환형만 포함된다.",
        "D": "예외 선언만 포함된다."
      },
      "correctAnswer": "B"
    },
    {
      "id": "u3m28",
      "type": "mcq",
      "question": "자바에서 정적 메서드의 특징은 무엇인가?",
      "options": {
        "A": "정적 메서드는 항상 객체를 통해 호출된다.",
        "B": "정적 메서드는 인스턴스 변수에 반드시 의존한다.",
        "C": "정적 메서드는 클래스 이름으로 직접 호출할 수 있으며, 모든 인스턴스가 공유한다.",
        "D": "정적 메서드는 컴파일 시에만 호출된다."
      },
      "correctAnswer": "C"
    },
    {
      "id": "u3m29",
      "type": "mcq",
      "question": "상속에서 부모 클래스의 멤버가 자식 클래스에 전달되는 현상을 무엇이라 하는가?",
      "options": {
        "A": "캡슐화",
        "B": "다형성",
        "C": "추상화",
        "D": "상속"
      },
      "correctAnswer": "D"
    },
    {
      "id": "u3m30",
      "type": "mcq",
      "question": "메서드 오버로딩은 어느 다형성의 형태에 해당하는가?",
      "options": {
        "A": "컴파일 타임 다형성",
        "B": "런타임 다형성",
        "C": "동적 다형성",
        "D": "정적 다형성"
      },
      "correctAnswer": "A"
    },
    {
      "id": "u3m31",
      "type": "mcq",
      "question": "자바에서 private 멤버에 접근하기 위한 일반적인 방법은 무엇인가?",
      "options": {
        "A": "직접 접근할 수 있다.",
        "B": "getter와 setter 메서드를 사용한다.",
        "C": "상속받아 오버라이딩해야 한다.",
        "D": "무조건 public으로 변경해야 한다."
      },
      "correctAnswer": "B"
    },
    {
      "id": "u3m32",
      "type": "mcq",
      "question": "상속 관계에서 생성자의 호출 순서에 관한 올바른 설명은 무엇인가?",
      "options": {
        "A": "자식 클래스의 생성자가 먼저 호출된다.",
        "B": "부모 클래스의 생성자가 먼저 호출되어야 한다.",
        "C": "부모 생성자 호출 후 자식 생성자가 호출된다.",
        "D": "생성자 호출 순서는 임의이다."
      },
      "correctAnswer": "C"
    },
    {
      "id": "u3m33",
      "type": "mcq",
      "question": "메서드 오버라이딩에서 공변 반환형(covariant return type)이란 무엇을 의미하는가?",
      "options": {
        "A": "자식 클래스의 메서드가 부모의 반환형과 완전히 달라질 수 있다.",
        "B": "반환형은 오버라이딩 시 변경할 수 없다.",
        "C": "자식 클래스의 메서드가 반드시 void여야 한다.",
        "D": "자식 클래스의 메서드는 부모의 반환형의 하위 타입을 반환할 수 있다."
      },
      "correctAnswer": "D"
    },
    {
      "id": "u3m34",
      "type": "mcq",
      "question": "메서드 오버로딩은 어떤 요소에 의해 구분되는가?",
      "options": {
        "A": "메서드 이름과 매개변수의 개수, 타입, 순서",
        "B": "반환형",
        "C": "접근제한자",
        "D": "예외 선언"
      },
      "correctAnswer": "A"
    },
    {
      "id": "u3m35",
      "type": "mcq",
      "question": "자식 클래스에서 부모 클래스의 멤버를 재정의할 때 필수적으로 지켜져야 하는 것은 무엇인가?",
      "options": {
        "A": "시그니처는 중요하지 않다.",
        "B": "메서드 이름, 매개변수, 접근제한자가 동일해야 한다.",
        "C": "반환형은 자유롭게 변경할 수 있다.",
        "D": "오버라이딩은 컴파일러에 의해 자동 처리된다."
      },
      "correctAnswer": "B"
    },
    {
      "id": "u3m36",
      "type": "mcq",
      "question": "상속 관계에서 부모 클래스의 생성자가 먼저 호출되는 이유는 무엇인가?",
      "options": {
        "A": "부모 클래스의 초기화가 선행되어야 하기 때문이다.",
        "B": "자식 클래스의 생성자가 없기 때문이다.",
        "C": "객체 생성 순서에 따라 임의로 결정된다.",
        "D": "컴파일러가 부모를 먼저 처리한다."
      },
      "correctAnswer": "A"
    },
    {
      "id": "u3m37",
      "type": "mcq",
      "question": "this와 super 키워드의 차이는 무엇인가?",
      "options": {
        "A": "this는 현재 객체, super는 부모 객체의 생성자와 메서드를 호출한다.",
        "B": "둘은 동일하다.",
        "C": "super는 자식 객체를 참조한다.",
        "D": "this는 생성자에서만 사용된다."
      },
      "correctAnswer": "A"
    },
    {
      "id": "u3m38",
      "type": "mcq",
      "question": "메서드 오버로딩은 어떤 다형성을 구현하는가?",
      "options": {
        "A": "런타임 다형성",
        "B": "동적 다형성",
        "C": "정적 다형성",
        "D": "컴파일 타임 다형성"
      },
      "correctAnswer": "D"
    },
    {
      "id": "u3m39",
      "type": "mcq",
      "question": "부모 클래스의 private 멤버는 자식 클래스에서 어떻게 처리되는가?",
      "options": {
        "A": "자식 클래스에서 직접 접근할 수 있다.",
        "B": "getter/setter를 통해 간접적으로 접근해야 한다.",
        "C": "오버라이딩하여 사용할 수 있다.",
        "D": "자동으로 protected로 변경된다."
      },
      "correctAnswer": "B"
    },
    {
      "id": "u3m40",
      "type": "mcq",
      "question": "자식 클래스에서 부모 클래스의 메서드를 오버라이딩할 때, 부모의 메서드를 호출하려면 어떻게 해야 하는가?",
      "options": {
        "A": "this.method()",
        "B": "parent.method()",
        "C": "super.method()",
        "D": "직접 호출할 수 없다."
      },
      "correctAnswer": "C"
    },
    {
      "id": "u3m41",
      "type": "mcq",
      "question": "상속을 통한 코드 재사용의 주요 장점은 무엇인가?",
      "options": {
        "A": "상속은 코드 중복을 줄여준다.",
        "B": "메모리 사용량이 줄어든다.",
        "C": "컴파일 속도가 빨라진다.",
        "D": "객체 생성 시간이 단축된다."
      },
      "correctAnswer": "A"
    },
    {
      "id": "u3m42",
      "type": "mcq",
      "question": "자식 클래스에서 부모 클래스의 private 멤버에 접근하려면 어떤 방법을 사용해야 하는가?",
      "options": {
        "A": "직접 접근할 수 있다.",
        "B": "super 키워드를 사용한다.",
        "C": "getter/setter 메서드를 사용한다.",
        "D": "오버라이딩하여 접근한다."
      },
      "correctAnswer": "C"
    },
    {
      "id": "u3m43",
      "type": "mcq",
      "question": "@Override 어노테이션의 주요 목적은 무엇인가?",
      "options": {
        "A": "부모 메서드를 오버라이딩하는 의도를 명시하는 것이다.",
        "B": "메서드 오버로딩을 수행한다.",
        "C": "클래스의 상속 관계를 표시한다.",
        "D": "메서드 이름을 변경한다."
      },
      "correctAnswer": "A"
    },
    {
      "id": "u3m44",
      "type": "mcq",
      "question": "부모 클래스의 멤버에 접근할 때, 접근제한자에 따른 올바른 규칙은 무엇인가?",
      "options": {
        "A": "모든 부모 멤버는 자식에서 접근할 수 있다.",
        "B": "부모의 private 멤버는 자식에서 접근할 수 없다.",
        "C": "부모의 protected 멤버는 오직 자식에서만 접근 가능하다.",
        "D": "부모의 default 멤버는 항상 public이다."
      },
      "correctAnswer": "B"
    },
    {
      "id": "u3m45",
      "type": "mcq",
      "question": "메서드 오버라이딩과 오버로딩의 차이는 무엇인가?",
      "options": {
        "A": "오버로딩은 같은 이름의 메서드를 여러 개 정의하는 것이고, 오버라이딩은 부모 클래스의 메서드를 재정의하는 것이다.",
        "B": "두 개념은 동일하다.",
        "C": "오버로딩은 런타임 다형성, 오버라이딩은 컴파일 타임 다형성이다.",
        "D": "오버라이딩은 단지 접근제한자 변경만을 의미한다."
      },
      "correctAnswer": "A"
    },
    {
      "id": "u3m46",
      "type": "mcq",
      "question": "정적 메서드는 인스턴스 변수에 접근할 수 있는가?",
      "options": {
        "A": "예, 항상 접근할 수 있다.",
        "B": "아니요, 인스턴스 생성 없이 호출되므로 접근할 수 없다.",
        "C": "조건부로 접근할 수 있다.",
        "D": "컴파일러가 자동으로 조정한다."
      },
      "correctAnswer": "B"
    },
    {
      "id": "u3m47",
      "type": "mcq",
      "question": "메서드 오버라이딩 시, 부모 메서드와 시그니처가 다르면 어떻게 되는가?",
      "options": {
        "A": "오버로딩으로 간주된다.",
        "B": "컴파일 오류가 발생한다.",
        "C": "런타임 오류가 발생한다.",
        "D": "부모 메서드가 호출된다."
      },
      "correctAnswer": "B"
    },
    {
      "id": "u3m48",
      "type": "mcq",
      "question": "부모 클래스의 final 메서드는 자식 클래스에서 재정의할 수 있는가?",
      "options": {
        "A": "재정의할 수 있다.",
        "B": "조건부로 재정의할 수 있다.",
        "C": "오버로딩은 가능하나 재정의는 불가능하다.",
        "D": "재정의할 수 없다."
      },
      "correctAnswer": "D"
    },
    {
      "id": "u3m49",
      "type": "mcq",
      "question": "메서드 오버라이딩 시, 올바른 문법 규칙은 무엇인가?",
      "options": {
        "A": "메서드 이름은 변경해도 된다.",
        "B": "반환형은 반드시 동일해야 한다.",
        "C": "매개변수는 자유롭게 변경할 수 있다.",
        "D": "자식 클래스의 메서드는 부모 클래스의 반환형 하위 타입을 반환할 수 있다."
      },
      "correctAnswer": "D"
    },
    {
      "id": "u3m50",
      "type": "mcq",
      "question": "상속, 메서드 재정의, 제한자와 관련하여 객체지향 프로그래밍의 핵심 개념은 무엇인가?",
      "options": {
        "A": "상속, 오버라이딩, 제한자는 객체지향 프로그래밍의 핵심 개념으로, 코드 재사용과 다형성을 구현한다.",
        "B": "이들은 단지 부가적인 기능에 불과하다.",
        "C": "이들은 메모리 관리를 위한 것이다.",
        "D": "이들은 컴파일러에 의해 자동 처리된다."
      },
      "correctAnswer": "A"
    },
      {
        "id": "u3c1",
        "type": "code",
        "question": "【가정】부모 클래스의 이름은 Parent, 자식 클래스의 이름은 Child입니다.\n다음 코드를 완성하여 Child 클래스가 Parent 클래스를 상속받도록 하시오.",
        "codeSnippet": "class Child __ Parent { }",
        "answers": ["extends"]
      },
      {
        "id": "u3c2",
        "type": "code",
        "question": "【가정】부모 클래스(Parent)에 display() 메서드가 정의되어 있습니다.\n자식 클래스(Child)에서 display() 메서드를 오버라이딩하면서, 부모 클래스의 display() 메서드를 호출하는 코드를 완성하시오.",
        "codeSnippet": "public void display() { return __.display(); }",
        "answers": ["super"]
      },
      {
        "id": "u3c3",
        "type": "code",
        "question": "【가정】Parent 클래스에 int형 멤버 변수 value와 getValue() 메서드가 정의되어 있습니다.\n자식 클래스(Child)에서, 부모 클래스의 private 멤버에 직접 접근할 수 없으므로 getter를 통해 값을 읽어오는 코드를 완성하시오.",
        "codeSnippet": "public int fetchValue() { return __; }",
        "answers": ["super.getValue()"]
      },
      {
        "id": "u3c4",
        "type": "code",
        "question": "【가정】자식 클래스(Child)의 생성자에서 부모 클래스(Parent)의 기본 생성자를 명시적으로 호출하여 초기화를 수행하고자 합니다.\n아래 코드의 빈칸을 채워 넣으시오.",
        "codeSnippet": "public Child() { __(); }",
        "answers": ["super"]
      },
      {
        "id": "u3c5",
        "type": "code",
        "question": "【가정】Parent 클래스에 final 메서드 display()가 정의되어 있습니다.\n다음 코드는 Child 클래스에서 display() 메서드를 오버라이딩하려 할 때 발생하는 컴파일 오류를 보여줍니다.\n빈칸에 올바른 메서드 이름을 채워 넣으시오.",
        "codeSnippet": "class Parent {\n    public final void display() { }\n}\n\nclass Child extends Parent {\n    public void __() { }\n}",
        "answers": ["display"]
      },
      {
        "id": "u3c6",
        "type": "code",
        "question": "【가정】Parent 클래스에 int형 멤버 변수 number가 정의되어 있습니다.\nChild 클래스에서, 동일한 이름의 멤버 변수를 선언하여 부모의 변수를 숨기는(shadowing) 예제를 완성하시오.",
        "codeSnippet": "class Child extends Parent {\n    private int __ = 10;\n}",
        "answers": ["number"]
      },
      {
        "id": "u3c7",
        "type": "code",
        "question": "【가정】Parent 클래스에 오버라이딩 가능한 compute() 메서드가 정의되어 있습니다.\nChild 클래스에서 compute() 메서드를 재정의하여, 부모 메서드의 결과에 5를 더한 값을 반환하는 코드를 완성하시오.",
        "codeSnippet": "public int compute() { return __+__; }",
        "answers": ["super.compute()","5"]
      },
      {
        "id": "u3c8",
        "type": "code",
        "question": "Child 클래스에서 생성자 체이닝을 사용하여, 같은 클래스 내의 다른 생성자를 호출하는 예제를 완성하시오.",
        "codeSnippet": "public Child(int num) { __(num); }",
        "answers": ["this"]
      },
      {
        "id": "u3c9",
        "type": "code",
        "question": "【가정】Parent 클래스에 정적 메서드 staticMethod()가 정의되어 있습니다.\nParent 클래스의 정적 메서드를 클래스 이름을 사용하여 호출하는 코드를 완성하시오.",
        "codeSnippet": "Parent.__();",
        "answers": ["staticMethod"]
      },
      {
        "id": "u3c10",
        "type": "code",
        "question": "【가정】Parent 클래스에 process() 메서드가 정의되어 있습니다.\nChild 클래스에서 @Override 어노테이션을 사용하여 process() 메서드를 오버라이딩하는 예제를 완성하시오.",
        "codeSnippet": "@Override\npublic void __() { System.out.println(\"오버라이딩\"); }",
        "answers": ["process"]
      },
      {
        "id": "u3c11",
        "type": "code",
        "question": "【가정】부모 클래스는 Parent, 자식 클래스는 Child입니다.\n부모 타입의 참조변수에 자식 객체를 할당하는 업캐스팅 예제를 완성하시오.",
        "codeSnippet": "Parent p = new __();",
        "answers": ["Child"]
      },
      {
        "id": "u3c12",
        "type": "code",
        "question": "【가정】Parent 클래스에 protected로 선언된 display() 메서드가 존재합니다.\nChild 클래스에서 해당 메서드를 오버라이딩하는 예제를 완성하시오.",
        "codeSnippet": "protected void __() { System.out.println(\"재정의\"); }",
        "answers": ["display"]
      },
      {
        "id": "u3c13",
        "type": "code",
        "question": "Child 클래스의 생성자에서 자신의 멤버 변수를 초기화할 때, 명확한 식별을 위해 사용하는 키워드를 채워 넣으시오.",
        "codeSnippet": "public Child(int num) { __.num = num; }",
        "answers": ["this"]
      },
      {
        "id": "u3c14",
        "type": "code",
        "question": "【가정】Parent 클래스에 정의된 getValue() 메서드를 재사용하여, Child 클래스에서 값을 반환하는 코드를 완성하시오.",
        "codeSnippet": "public int fetchParentValue() { return __.__; }",
        "answers": ["super","getValue()"]
      },
      {
        "id": "u3c15",
        "type": "code",
        "question": "【가정】Parent 클래스에 show() 메서드가 정의되어 있습니다.\nChild 클래스에서 부모의 show() 메서드를 오버라이딩하지 않고 그대로 호출하기 위해, 올바른 코드를 완성하시오.",
        "codeSnippet": "public void callShow() { __.show(); }",
        "answers": ["super"]
      },
      {
        "id": "u3c16",
        "type": "code",
        "question": "【가정】Parent 클래스의 생성자가 int형 매개변수를 받습니다.\nChild 클래스의 생성자에서, 부모 클래스의 해당 생성자에 매개변수를 전달하여 호출하는 코드를 완성하시오.",
        "codeSnippet": "public Child(int num) { __(num); }",
        "answers": ["super"]
      },
      {
        "id": "u3c17",
        "type": "code",
        "question": "【가정】Parent 클래스의 process() 메서드는 throws Exception을 선언합니다.\nChild 클래스에서 이 메서드를 오버라이딩할 때, 부모와 동일하거나 좁은 범위의 예외를 선언하는 예제를 완성하시오.",
        "codeSnippet": "public void process() throws __ { }",
        "answers": ["Exception"]
      },
      {
        "id": "u3c18",
        "type": "code",
        "question": "【가정】Parent 클래스에 정의된 getInstance() 메서드의 반환형은 Parent입니다.\nChild 클래스에서 공변 반환형을 활용하여, getInstance() 메서드를 재정의하고 Child 타입의 객체를 반환하는 코드를 완성하시오.",
        "codeSnippet": "public __ getInstance() { return new Child(); }",
        "answers": ["Child"]
      },
      {
        "id": "u3c19",
        "type": "code",
        "question": "Child 클래스에서 getNumber() 메서드를 재정의하여, 항상 42를 반환하도록 구현하는 예제를 완성하시오.",
        "codeSnippet": "public int getNumber() { return __; }",
        "answers": ["42"]
      },
      {
        "id": "u3c20",
        "type": "code",
        "question": "Child 클래스에서 오버라이딩하지 않고, Parent 클래스에 정의된 compute() 메서드를 그대로 호출하여 그 결과를 반환하는 코드를 완성하시오.",
        "codeSnippet": "public int compute() { return __.__; }",
        "answers": ["super","compute()"]
      },
      {
        "id": "u3c21",
        "type": "code",
        "question": "메서드 오버로딩을 통해, 동일한 이름의 calculate() 메서드를 서로 다른 매개변수로 정의하는 예제를 완성하시오.\n(예: 첫 번째 calculate()는 int 하나를, 두 번째 calculate()는 int 두 개를 매개변수로 받음)",
        "codeSnippet": "public int calculate(int a) { return a * 2; }\npublic int calculate(__ b, int c) { return b + c; }",
        "answers": ["int"]
      },
      {
        "id": "u3c22",
        "type": "code",
        "question": "【가정】Parent 클래스에 정적 메서드 staticMethod()가 정의되어 있습니다.\nChild 클래스에서 오버라이딩 없이, Parent 클래스의 정적 메서드를 클래스 이름을 사용하여 호출하는 코드를 완성하시오.",
        "codeSnippet": "Parent.__();",
        "answers": ["staticMethod"]
      },
      {
        "id": "u3c23",
        "type": "code",
        "question": "【가정】Parent 클래스에 protected 또는 public으로 선언된 int형 필드 data가 있습니다.\nChild 클래스에서 동일한 이름의 필드를 선언하여 부모의 필드를 숨기는(shadowing) 상황에서, 부모 클래스의 data 값을 참조하는 코드를 완성하시오.",
        "codeSnippet": "public int getParentData() { return __.__; }",
        "answers": ["super","data"]
      },
      {
        "id": "u3c24",
        "type": "code",
        "question": "Child 클래스에서 부모 클래스(Parent)의 멤버 메서드를 재정의하지 않고 그대로 호출하기 위해 사용하는 키워드를 코드에 채워 넣으시오.",
        "codeSnippet": "public void invokeParent() { __.method(); }",
        "answers": ["super"]
      },
      {
        "id": "u3c25",
        "type": "code",
        "question": "【가정】Child 클래스에는 기본 생성자와 int형 매개변수를 받는 생성자가 있습니다.\n아래 예제에서, 기본 생성자에서는 Parent 클래스의 기본 생성자를 호출하고, 매개변수 생성자에서는 Child 클래스의 기본 생성자를 호출하여 초기화를 수행하는 코드를 완성하시오.",
        "codeSnippet": "public Child() {\n    __(); // 부모 클래스의 기본 생성자 호출\n    // 추가 초기화 코드\n}\n\npublic Child(int num) {\n    __( ); // 자식 클래스의 기본 생성자 호출\n    this.num = num;\n}",
        "answers": ["super", "this"]
      }    
    ,
    {
      "id": "u3s1",
      "type": "subjective",
      "question": "상속의 장단점에 대해 구체적인 예를 들어 설명하시오.",
      "correctAnswer": "상속은 기존 클래스의 기능을 재사용하여 코드 중복을 줄이고 유지보수를 용이하게 하지만, 과도한 상속은 결합도를 높여 유연성을 떨어뜨릴 수 있다."
    },
    {
      "id": "u3s2",
      "type": "subjective",
      "question": "메서드 오버라이딩의 개념과 필요성에 대해 서술하시오.",
      "correctAnswer": "오버라이딩은 부모 클래스의 메서드를 자식 클래스에서 재정의함으로써, 런타임 다형성을 구현하고 객체마다 다른 동작을 수행할 수 있게 한다."
    },
    {
      "id": "u3s3",
      "type": "subjective",
      "question": "부모 클래스의 private 멤버에 접근하는 방법에 대해 설명하시오.",
      "correctAnswer": "private 멤버는 직접 상속되지는 않으므로, getter와 setter 메서드를 통해 간접적으로 접근해야 한다."
    },
    {
      "id": "u3s4",
      "type": "subjective",
      "question": "super 키워드의 사용법과 그 중요성에 대해 설명하시오.",
      "correctAnswer": "super 키워드는 자식 클래스에서 부모 클래스의 생성자나 메서드를 호출할 때 사용되어, 부모의 초기화나 기본 동작을 유지할 수 있게 한다."
    },
    {
      "id": "u3s5",
      "type": "subjective",
      "question": "메서드 오버라이딩과 오버로딩의 차이를 예제를 들어 설명하시오.",
      "correctAnswer": "오버로딩은 같은 이름의 메서드를 매개변수로 구분하여 여러 개 정의하는 것이고, 오버라이딩은 부모 클래스의 메서드를 자식 클래스에서 재정의하여 다형성을 구현하는 것이다."
    },
    {
      "id": "u3s6",
      "type": "subjective",
      "question": "공변 반환형의 개념과 그 필요성에 대해 설명하시오.",
      "correctAnswer": "공변 반환형은 자식 클래스의 메서드가 부모 클래스의 반환형의 하위 타입을 반환할 수 있게 하여, 보다 구체적인 객체를 반환하고 다형성을 강화한다."
    },
    {
      "id": "u3s7",
      "type": "subjective",
      "question": "상속을 통한 코드 재사용의 이점과 단점에 대해 논하시오.",
      "correctAnswer": "상속은 기존 코드를 재사용하여 개발 시간을 단축하고 유지보수를 용이하게 하지만, 잘못 설계하면 클래스 간 결합도가 높아져 유연성이 떨어질 수 있다."
    },
    {
      "id": "u3s8",
      "type": "subjective",
      "question": "메서드 오버라이딩 시 접근제한자 규칙에 대해 설명하시오.",
      "correctAnswer": "자식 클래스에서 오버라이딩하는 메서드는 부모 클래스의 접근제한자보다 좁은 범위로 설정할 수 없으며, 보통 동일하거나 더 넓은 범위로 선언해야 한다."
    },
    {
      "id": "u3s9",
      "type": "subjective",
      "question": "자식 클래스에서 부모 클래스의 멤버를 숨기는(섀도잉) 현상의 원인과 그 결과에 대해 서술하시오.",
      "correctAnswer": "섀도잉은 자식 클래스에서 동일한 이름의 멤버를 재선언하여 부모 클래스의 멤버를 가리는 현상으로, 혼란을 야기할 수 있으므로 주의해야 한다."
    },
    {
      "id": "u3s10",
      "type": "subjective",
      "question": "상속 관계에서 생성자 호출 순서의 중요성에 대해 설명하시오.",
      "correctAnswer": "부모 클래스의 생성자가 먼저 호출되어 기본적인 초기화가 완료된 후 자식 클래스의 생성자가 호출되므로, 상속 관계의 올바른 초기화 순서를 보장한다."
    },
    {
      "id": "u3s11",
      "type": "subjective",
      "question": "메서드 오버라이딩이 다형성 구현에 미치는 영향을 구체적인 예와 함께 설명하시오.",
      "correctAnswer": "부모 클래스 참조변수로 자식 객체를 다루면, 런타임에 자식 클래스에서 재정의한 메서드가 호출되어 다양한 동작을 구현할 수 있다."
    },
    {
      "id": "u3s12",
      "type": "subjective",
      "question": "부모 클래스의 final 메서드가 가지는 의미와 사용 사례에 대해 설명하시오.",
      "correctAnswer": "final 메서드는 재정의가 불가능하여 부모 클래스의 기본 기능을 보호하는 용도로 사용되며, 보안이나 안정성이 중요한 경우에 유용하다."
    },
    {
      "id": "u3s13",
      "type": "subjective",
      "question": "상속과 컴포지션의 차이점과 각각의 장단점에 대해 비교하시오.",
      "correctAnswer": "상속은 코드 재사용과 확장을 가능하게 하지만 강한 결합을 초래할 수 있으며, 컴포지션은 객체를 구성하여 유연성을 제공하지만 인터페이스 설계가 복잡해질 수 있다."
    },
    {
      "id": "u3s14",
      "type": "subjective",
      "question": "자바에서 접근제한자(private, protected, public)의 역할과 상속에서의 적용에 대해 설명하시오.",
      "correctAnswer": "접근제한자는 클래스 멤버의 노출 범위를 결정하며, 이를 통해 캡슐화가 이루어지고 상속 시 불필요한 외부 접근을 제한할 수 있다."
    },
    {
      "id": "u3s15",
      "type": "subjective",
      "question": "메서드 시그니처의 정의와 오버라이딩, 오버로딩에서의 역할에 대해 설명하시오.",
      "correctAnswer": "메서드 시그니처는 메서드 이름과 매개변수의 타입 및 순서를 의미하며, 오버로딩과 오버라이딩을 구분하는 핵심 요소이다."
    },
    {
      "id": "u3s16",
      "type": "subjective",
      "question": "상속을 통한 코드 재사용이 유지보수에 미치는 긍정적, 부정적 영향을 설명하시오.",
      "correctAnswer": "상속은 중복 코드를 줄여 유지보수를 쉽게 하지만, 과도한 상속은 클래스 간 결합도를 높여 변경에 따른 영향을 크게 할 수 있다."
    },
    {
      "id": "u3s17",
      "type": "subjective",
      "question": "오버라이딩된 메서드 내에서 부모 클래스의 메서드를 호출하는 이유와 그 방법에 대해 설명하시오.",
      "correctAnswer": "부모의 기본 동작을 유지하거나 확장하기 위해 super 키워드를 사용하여 부모의 메서드를 호출한다."
    },
    {
      "id": "u3s18",
      "type": "subjective",
      "question": "자식 클래스에서 부모 클래스의 생성자를 호출하는 방식과 그 필요성에 대해 설명하시오.",
      "correctAnswer": "자식 클래스의 생성자에서 super()를 호출하여 부모 클래스의 초기화를 먼저 수행함으로써, 올바른 객체 구성이 가능하다."
    },
    {
      "id": "u3s19",
      "type": "subjective",
      "question": "메서드 오버로딩이 컴파일 타임 다형성을 구현하는 방법에 대해 설명하시오.",
      "correctAnswer": "오버로딩은 같은 이름의 메서드를 매개변수로 구분하여 여러 개 정의함으로써, 컴파일 시 호출할 메서드를 결정하는 방식으로 다형성을 구현한다."
    },
    {
      "id": "u3s20",
      "type": "subjective",
      "question": "상속을 이용한 클래스 확장이 시스템 설계에 미치는 장단점에 대해 논하시오.",
      "correctAnswer": "상속은 기존 기능을 재사용하여 개발을 단축시키지만, 잘못 사용하면 강한 결합과 복잡한 계층 구조로 인해 유지보수가 어려워질 수 있다."
    },
    {
      "id": "u3s21",
      "type": "subjective",
      "question": "상속 관계를 통해 구현할 수 있는 다형성의 예를 구체적으로 설명하시오.",
      "correctAnswer": "예를 들어, 부모 클래스 타입의 참조변수에 자식 객체를 할당하여, 런타임에 자식 클래스의 재정의된 메서드가 호출되는 경우가 있다."
    },
    {
      "id": "u3s22",
      "type": "subjective",
      "question": "메서드 오버라이딩 시 발생할 수 있는 문제점과 이를 해결하기 위한 방법에 대해 논하시오.",
      "correctAnswer": "부모와 자식의 메서드 시그니처 불일치나 예외 처리 차이 등이 문제를 일으킬 수 있으며, 이를 해결하기 위해 @Override 어노테이션과 엄격한 시그니처 준수가 필요하다."
    },
    {
      "id": "u3s23",
      "type": "subjective",
      "question": "부모 클래스의 멤버에 접근하기 위해 사용하는 getter와 setter 메서드의 역할에 대해 설명하시오.",
      "correctAnswer": "getter와 setter는 private 멤버에 대한 간접 접근을 제공하여, 데이터 은닉과 캡슐화를 유지하면서 외부 접근을 가능하게 한다."
    },
    {
      "id": "u3s24",
      "type": "subjective",
      "question": "상속, 오버라이딩, 제한자가 협력하여 객체지향 프로그래밍을 구현하는 방식을 설명하시오.",
      "correctAnswer": "이들 개념은 함께 작동하여 코드 재사용과 다형성을 구현하며, 클래스 간의 계층 구조를 통해 복잡한 시스템을 단순화한다."
    },
    {
      "id": "u3s25",
      "type": "subjective",
      "question": "자식 클래스에서 부모 클래스의 메서드를 재정의할 때 고려해야 할 핵심 사항에 대해 설명하시오.",
      "correctAnswer": "부모의 메서드와 동일한 시그니처, 접근제한자, 예외 선언 등을 준수해야 하며, 이를 통해 올바른 오버라이딩과 다형성이 구현된다."
    }
  ],
  "unit4": [
    {
      "id": "u4m1",
      "type": "mcq",
      "question": "자바에서 public 접근제한자는 어떤 의미인가?",
      "options": {
        "A": "모든 클래스에서 접근 가능하다.",
        "B": "같은 패키지 내에서만 접근 가능하다.",
        "C": "오직 해당 클래스 내부에서만 접근 가능하다.",
        "D": "자식 클래스에서만 접근 가능하다."
      },
      "correctAnswer": "A"
    },
    {
      "id": "u4m2",
      "type": "mcq",
      "question": "자바에서 default 접근제한자는 무엇을 의미하는가?",
      "options": {
        "A": "모든 곳에서 접근 가능하다.",
        "B": "명시적 제한자가 없을 경우, 같은 패키지 내에서만 접근 가능하다.",
        "C": "클래스 내부에서만 접근 가능하다.",
        "D": "자식 클래스에서만 접근 가능하다."
      },
      "correctAnswer": "B"
    },
    {
      "id": "u4m3",
      "type": "mcq",
      "question": "protected 접근제한자는 어느 범위까지 접근을 허용하는가?",
      "options": {
        "A": "오직 클래스 내부에서만",
        "B": "같은 패키지 내에서만",
        "C": "같은 패키지 및 자식 클래스에서",
        "D": "모든 곳에서"
      },
      "correctAnswer": "C"
    },
    {
      "id": "u4m4",
      "type": "mcq",
      "question": "private 접근제한자의 의미는 무엇인가?",
      "options": {
        "A": "자식 클래스에서 접근 가능하다.",
        "B": "같은 패키지 내에서 접근 가능하다.",
        "C": "모든 클래스에서 접근 가능하다.",
        "D": "해당 클래스 내부에서만 접근 가능하다."
      },
      "correctAnswer": "D"
    },
    {
      "id": "u4m5",
      "type": "mcq",
      "question": "자바에서 static 멤버의 주요 특징은 무엇인가?",
      "options": {
        "A": "클래스 이름으로 직접 접근 가능하다.",
        "B": "객체 생성 후에만 접근 가능하다.",
        "C": "인스턴스 메서드에서만 사용된다.",
        "D": "생성자 내에서만 접근할 수 있다."
      },
      "correctAnswer": "A"
    },
    {
      "id": "u4m6",
      "type": "mcq",
      "question": "다형성이란 무엇을 의미하는가?",
      "options": {
        "A": "하나의 클래스에서 여러 개의 변수를 선언하는 것이다.",
        "B": "하나의 인터페이스로 다양한 구현을 제공하는 것이다.",
        "C": "메서드 오버로딩만을 의미한다.",
        "D": "상속을 통한 클래스 확장을 의미한다."
      },
      "correctAnswer": "B"
    },
    {
      "id": "u4m7",
      "type": "mcq",
      "question": "객체의 형변환에서 업캐스팅(upcasting)이란 무엇을 의미하는가?",
      "options": {
        "A": "부모 클래스로의 변환",
        "B": "자식 클래스로의 변환",
        "C": "자식 객체를 부모 타입으로 변환하는 것",
        "D": "객체를 기본형으로 변환하는 것"
      },
      "correctAnswer": "C"
    },
    {
      "id": "u4m8",
      "type": "mcq",
      "question": "객체의 형변환에서 다운캐스팅(downcasting)이란 무엇을 의미하는가?",
      "options": {
        "A": "부모 타입에서 자식 타입으로의 자동 형변환",
        "B": "자식 타입에서 부모 타입으로의 변환",
        "C": "동일한 클래스 간의 형변환",
        "D": "부모 타입의 객체를 자식 타입으로 명시적으로 변환하는 것"
      },
      "correctAnswer": "D"
    },
    {
      "id": "u4m9",
      "type": "mcq",
      "question": "접근제한자를 사용하는 주된 목적은 무엇인가?",
      "options": {
        "A": "데이터 보호와 캡슐화",
        "B": "메모리 사용량 감소",
        "C": "코드 실행 속도 향상",
        "D": "객체 생성 시간 단축"
      },
      "correctAnswer": "A"
    },
    {
      "id": "u4m10",
      "type": "mcq",
      "question": "다형성을 구현하기 위한 한 가지 방법은 무엇인가?",
      "options": {
        "A": "모든 메서드를 static으로 선언한다.",
        "B": "부모 클래스 타입의 참조변수로 자식 객체를 다룬다.",
        "C": "모든 메서드를 final로 선언한다.",
        "D": "객체를 복제한다."
      },
      "correctAnswer": "B"
    },
    {
      "id": "u4m11",
      "type": "mcq",
      "question": "업캐스팅은 어떤 상황에서 유용하게 사용되는가?",
      "options": {
        "A": "자식 클래스의 고유 메서드를 사용하려 할 때",
        "B": "객체의 메모리 주소를 확인할 때",
        "C": "부모 클래스의 공통 기능을 활용할 때",
        "D": "객체를 문자열로 변환할 때"
      },
      "correctAnswer": "C"
    },
    {
      "id": "u4m12",
      "type": "mcq",
      "question": "다운캐스팅 시 주의해야 할 점은 무엇인가?",
      "options": {
        "A": "항상 자동으로 이루어진다.",
        "B": "업캐스팅 후에만 명시적 형변환을 사용할 수 있다.",
        "C": "형변환 후 객체는 자동으로 변경된다.",
        "D": "잘못된 형변환은 ClassCastException을 발생시킬 수 있다."
      },
      "correctAnswer": "D"
    },
    {
      "id": "u4m13",
      "type": "mcq",
      "question": "protected 접근제한자의 주요 특징은 무엇인가?",
      "options": {
        "A": "같은 패키지 및 자식 클래스에서 접근 가능하다.",
        "B": "오직 클래스 내부에서만 접근 가능하다.",
        "C": "모든 곳에서 접근 가능하다.",
        "D": "private와 동일하다."
      },
      "correctAnswer": "A"
    },
    {
      "id": "u4m14",
      "type": "mcq",
      "question": "다형성의 이점 중 올바른 설명은 무엇인가?",
      "options": {
        "A": "코드가 간결해진다.",
        "B": "동일한 인터페이스로 다양한 객체를 처리할 수 있다.",
        "C": "메모리 사용량이 크게 줄어든다.",
        "D": "컴파일 속도가 향상된다."
      },
      "correctAnswer": "B"
    },
    {
      "id": "u4m15",
      "type": "mcq",
      "question": "자바에서 형변환 시 명시적 형변환이 필요한 경우는 언제인가?",
      "options": {
        "A": "부모 타입에서 자식 타입으로 변환할 때",
        "B": "자식 타입에서 부모 타입으로 변환할 때",
        "C": "동일 타입 간의 변환 시",
        "D": "모든 형변환은 자동으로 이루어진다."
      },
      "correctAnswer": "A"
    },
    {
      "id": "u4m16",
      "type": "mcq",
      "question": "instanceof 연산자의 역할은 무엇인가?",
      "options": {
        "A": "객체를 특정 타입으로 자동 변환한다.",
        "B": "객체의 메모리 주소를 반환한다.",
        "C": "객체의 클래스 이름을 출력한다.",
        "D": "객체가 특정 타입의 인스턴스인지 확인한다."
      },
      "correctAnswer": "D"
    },
    {
      "id": "u4m17",
      "type": "mcq",
      "question": "접근제한자가 올바르게 사용되었을 때 얻을 수 있는 주요 이점은 무엇인가?",
      "options": {
        "A": "데이터 보호와 보안 강화",
        "B": "메모리 최적화",
        "C": "코드 실행 속도 향상",
        "D": "객체 생성 시간 단축"
      },
      "correctAnswer": "A"
    },
    {
      "id": "u4m18",
      "type": "mcq",
      "question": "다형성을 구현하기 위해 부모 클래스의 참조변수에 자식 객체를 할당하는 이유는 무엇인가?",
      "options": {
        "A": "메모리 절약을 위해",
        "B": "다형성을 통해 다양한 객체를 한 인터페이스로 다루기 위해",
        "C": "객체의 복제를 위해",
        "D": "컴파일 속도를 높이기 위해"
      },
      "correctAnswer": "B"
    },
    {
      "id": "u4m19",
      "type": "mcq",
      "question": "자바에서 기본형과 참조형 간의 형변환에 대해 올바른 설명은 무엇인가?",
      "options": {
        "A": "기본형과 참조형은 서로 자동으로 변환된다.",
        "B": "기본형은 참조형으로, 참조형은 기본형으로 변환할 수 없다.",
        "C": "기본형과 참조형은 직접 변환할 수 없으며, 별도의 메서드를 사용해야 한다.",
        "D": "기본형과 참조형은 서로 자동 형변환되지 않는다."
      },
      "correctAnswer": "D"
    },
    {
      "id": "u4m20",
      "type": "mcq",
      "question": "다운캐스팅 시 안전성을 보장하기 위한 일반적인 방법은 무엇인가?",
      "options": {
        "A": "자동 형변환을 사용한다.",
        "B": "형변환 후 객체가 변경된다.",
        "C": "항상 부모 클래스로 업캐스팅한다.",
        "D": "instanceof 연산자로 타입을 확인한 후 명시적 형변환을 수행한다."
      },
      "correctAnswer": "D"
    },
    {
      "id": "u4m21",
      "type": "mcq",
      "question": "private 멤버의 주요 특징은 무엇인가?",
      "options": {
        "A": "오직 해당 클래스 내부에서만 접근 가능하다.",
        "B": "같은 패키지 내에서도 접근 가능하다.",
        "C": "자식 클래스에서도 접근 가능하다.",
        "D": "모든 클래스에서 접근 가능하다."
      },
      "correctAnswer": "A"
    },
    {
      "id": "u4m22",
      "type": "mcq",
      "question": "protected 멤버는 어느 범위에서 접근할 수 있는가?",
      "options": {
        "A": "오직 클래스 내부에서만",
        "B": "같은 패키지 및 자식 클래스에서",
        "C": "모든 곳에서",
        "D": "자식 클래스에서만"
      },
      "correctAnswer": "B"
    },
    {
      "id": "u4m23",
      "type": "mcq",
      "question": "자바에서 객체의 업캐스팅이 자동으로 이루어지는 이유는 무엇인가?",
      "options": {
        "A": "자식 객체가 부모 클래스의 메서드를 항상 포함하기 때문이다.",
        "B": "명시적 형변환이 불필요하기 때문이다.",
        "C": "부모 타입으로의 변환은 컴파일러가 자동으로 처리하기 때문이다.",
        "D": "다운캐스팅은 항상 자동이다."
      },
      "correctAnswer": "C"
    },
    {
      "id": "u4m24",
      "type": "mcq",
      "question": "객체의 형변환 시, 명시적 형변환을 하는 주된 이유는 무엇인가?",
      "options": {
        "A": "컴파일러가 자동으로 변환해주기 때문이다.",
        "B": "타입 정보를 잃지 않고 강제로 변환하기 위함이다.",
        "C": "객체를 기본형으로 변환하기 위함이다.",
        "D": "메모리 사용량을 줄이기 위함이다."
      },
      "correctAnswer": "B"
    },
    {
      "id": "u4m25",
      "type": "mcq",
      "question": "정적 메서드의 주요 특징은 무엇인가?",
      "options": {
        "A": "객체 생성 없이 클래스 이름으로 직접 호출 가능하다.",
        "B": "인스턴스 변수에 직접 접근할 수 있다.",
        "C": "오버라이딩이 가능하다.",
        "D": "모든 메서드가 abstract이다."
      },
      "correctAnswer": "A"
    },
    {
      "id": "u4m26",
      "type": "mcq",
      "question": "다형성(polymorphism)이 객체지향 프로그래밍에서 중요한 이유는 무엇인가?",
      "options": {
        "A": "객체 생성 속도를 향상시킨다.",
        "B": "코드 재사용성과 확장성을 높인다.",
        "C": "메모리 사용량을 최적화한다.",
        "D": "컴파일러 오류를 줄인다."
      },
      "correctAnswer": "B"
    },
    {
      "id": "u4m27",
      "type": "mcq",
      "question": "객체 형변환 시, 다운캐스팅이 실패하면 발생하는 예외는 무엇인가?",
      "options": {
        "A": "NullPointerException",
        "B": "ArrayIndexOutOfBoundsException",
        "C": "ClassCastException",
        "D": "IllegalArgumentException"
      },
      "correctAnswer": "C"
    },
    {
      "id": "u4m28",
      "type": "mcq",
      "question": "접근제한자를 통해 캡슐화를 구현하면 얻을 수 있는 효과는 무엇인가?",
      "options": {
        "A": "코드 실행 속도가 빨라진다.",
        "B": "데이터 보호와 보안이 강화된다.",
        "C": "메모리 사용량이 줄어든다.",
        "D": "객체 생성 비용이 감소한다."
      },
      "correctAnswer": "B"
    },
    {
      "id": "u4m29",
      "type": "mcq",
      "question": "자바에서 형변환 시 사용하는 명시적 형변환의 문법은 무엇인가?",
      "options": {
        "A": "(타입) 객체",
        "B": "타입(객체)",
        "C": "객체 as 타입",
        "D": "타입 객체"
      },
      "correctAnswer": "A"
    },
    {
      "id": "u4m30",
      "type": "mcq",
      "question": "다형성을 구현하기 위한 중요한 키워드 중 하나인 instanceof의 주된 용도는 무엇인가?",
      "options": {
        "A": "객체를 특정 타입으로 자동 변환한다.",
        "B": "객체가 특정 타입의 인스턴스인지 확인한다.",
        "C": "객체의 메모리 주소를 반환한다.",
        "D": "객체를 복제한다."
      },
      "correctAnswer": "B"
    },
    {
      "id": "u4m31",
      "type": "mcq",
      "question": "업캐스팅은 일반적으로 어떤 경우에 사용되는가?",
      "options": {
        "A": "자식 객체의 고유 기능 호출 시",
        "B": "부모 클래스의 공통 기능 사용 시",
        "C": "객체를 문자열로 변환할 때",
        "D": "메모리 할당을 최적화할 때"
      },
      "correctAnswer": "B"
    },
    {
      "id": "u4m32",
      "type": "mcq",
      "question": "자바에서 다형성을 구현하기 위해 가장 많이 사용되는 개념은 무엇인가?",
      "options": {
        "A": "캡슐화",
        "B": "상속",
        "C": "메서드 오버로딩",
        "D": "메서드 오버라이딩"
      },
      "correctAnswer": "D"
    },
    {
      "id": "u4m33",
      "type": "mcq",
      "question": "객체의 형변환에서 명시적 형변환을 사용할 때 주의해야 할 점은 무엇인가?",
      "options": {
        "A": "반드시 자동 형변환이 이루어진다.",
        "B": "실제 객체 타입과 일치하는지 확인해야 한다.",
        "C": "형변환 후 객체의 값이 변경된다.",
        "D": "형변환은 컴파일러가 임의로 처리한다."
      },
      "correctAnswer": "B"
    },
    {
      "id": "u4m34",
      "type": "mcq",
      "question": "접근제한자, 다형성, 객체의 형변환과 관련하여, 올바른 형변환 예제는 무엇인가?",
      "options": {
        "A": "자식 객체를 부모 타입으로 변환하는 업캐스팅",
        "B": "부모 객체를 자식 타입으로 변환하는 다운캐스팅",
        "C": "같은 클래스 간의 형변환",
        "D": "기본형과 참조형 간의 형변환"
      },
      "correctAnswer": "A"
    },
    {
      "id": "u4m35",
      "type": "mcq",
      "question": "접근제한자가 없는(default) 멤버는 어느 범위에서 접근 가능한가?",
      "options": {
        "A": "같은 클래스 내부에서만",
        "B": "같은 패키지 내에서만",
        "C": "모든 곳에서",
        "D": "자식 클래스에서만"
      },
      "correctAnswer": "B"
    },
    {
      "id": "u4m36",
      "type": "mcq",
      "question": "자바에서 형변환이 실패할 때 발생하는 예외는 무엇인가?",
      "options": {
        "A": "NullPointerException",
        "B": "ArithmeticException",
        "C": "ClassCastException",
        "D": "IllegalArgumentException"
      },
      "correctAnswer": "C"
    },
    {
      "id": "u4m37",
      "type": "mcq",
      "question": "객체 형변환 시, 부모 타입의 참조변수에 자식 객체를 할당하는 것을 무엇이라 하는가?",
      "options": {
        "A": "다운캐스팅",
        "B": "업캐스팅",
        "C": "명시적 형변환",
        "D": "자동 형변환"
      },
      "correctAnswer": "B"
    },
    {
      "id": "u4m38",
      "type": "mcq",
      "question": "다형성 구현 시, 부모 클래스 참조변수를 통해 자식 클래스의 재정의된 메서드를 호출하는 이유는 무엇인가?",
      "options": {
        "A": "컴파일 타임 다형성을 구현하기 위해",
        "B": "런타임 다형성을 구현하기 위해",
        "C": "메모리 할당을 줄이기 위해",
        "D": "객체의 복제를 위해"
      },
      "correctAnswer": "B"
    },
    {
      "id": "u4m39",
      "type": "mcq",
      "question": "객체의 형변환 시, 부모 클래스의 참조변수가 자식 객체를 가리킬 수 있는 이유는 무엇인가?",
      "options": {
        "A": "자식 객체는 부모 클래스의 모든 멤버를 포함하기 때문이다.",
        "B": "자식 객체는 별도의 메모리 영역을 갖는다.",
        "C": "부모 객체는 항상 자식 객체보다 작다.",
        "D": "형변환은 자동으로 이루어진다."
      },
      "correctAnswer": "C"
    },
    {
      "id": "u4m40",
      "type": "mcq",
      "question": "접근제한자와 관련하여, private 멤버는 어디에서 접근 가능한가?",
      "options": {
        "A": "모든 클래스에서",
        "B": "같은 패키지 내에서",
        "C": "자식 클래스에서",
        "D": "해당 클래스 내부에서만"
      },
      "correctAnswer": "D"
    },
    {
      "id": "u4m41",
      "type": "mcq",
      "question": "객체 형변환 시, 명시적 형변환 문법의 기본 구조는 무엇인가?",
      "options": {
        "A": "(타입) 객체",
        "B": "타입(객체)",
        "C": "객체 as 타입",
        "D": "타입 객체"
      },
      "correctAnswer": "A"
    },
    {
      "id": "u4m42",
      "type": "mcq",
      "question": "자바에서 static 키워드가 붙은 메서드는 어떤 방식으로 호출되는가?",
      "options": {
        "A": "객체 생성 후 호출한다.",
        "B": "클래스 이름으로 직접 호출한다.",
        "C": "반드시 인스턴스 메서드를 통해 호출한다.",
        "D": "생성자 내에서만 호출된다."
      },
      "correctAnswer": "B"
    },
    {
      "id": "u4m43",
      "type": "mcq",
      "question": "접근제한자를 사용하여 멤버의 외부 노출을 제한할 때, 가장 강력한 제한자는 무엇인가?",
      "options": {
        "A": "public",
        "B": "protected",
        "C": "default",
        "D": "private"
      },
      "correctAnswer": "D"
    },
    {
      "id": "u4m44",
      "type": "mcq",
      "question": "다형성을 구현하는 데 있어 메서드 오버라이딩의 역할은 무엇인가?",
      "options": {
        "A": "동일한 이름의 메서드를 여러 개 정의한다.",
        "B": "부모 클래스의 메서드를 재정의하여 자식 클래스의 동작을 구현한다.",
        "C": "메서드 호출 시 컴파일 타임에 결정된다.",
        "D": "메서드의 접근제한자를 변경한다."
      },
      "correctAnswer": "B"
    },
    {
      "id": "u4m45",
      "type": "mcq",
      "question": "객체 형변환 시, 명시적 형변환이 필요한 이유는 무엇인가?",
      "options": {
        "A": "컴파일러가 자동 변환하지 않기 때문이다.",
        "B": "객체의 실제 타입을 변경하기 위해서이다.",
        "C": "반드시 업캐스팅 후에만 필요하다.",
        "D": "형변환은 런타임에만 이루어진다."
      },
      "correctAnswer": "A"
    },
    {
      "id": "u4m46",
      "type": "mcq",
      "question": "접근제한자 중, 같은 패키지 내에서만 접근 가능한 것은 무엇인가?",
      "options": {
        "A": "public",
        "B": "protected",
        "C": "default",
        "D": "private"
      },
      "correctAnswer": "C"
    },
    {
      "id": "u4m47",
      "type": "mcq",
      "question": "다형성의 개념을 통해 얻을 수 있는 주요 이점은 무엇인가?",
      "options": {
        "A": "코드 재사용성 향상",
        "B": "메모리 절약",
        "C": "컴파일 속도 증가",
        "D": "객체 생성 시간 단축"
      },
      "correctAnswer": "A"
    },
    {
      "id": "u4m48",
      "type": "mcq",
      "question": "자바에서 다운캐스팅 시 주의할 점은 무엇인가?",
      "options": {
        "A": "반드시 업캐스팅을 먼저 수행해야 한다.",
        "B": "자동 형변환이 이루어진다.",
        "C": "형변환 후 객체의 타입은 변경되지 않는다.",
        "D": "잘못된 형변환은 ClassCastException을 발생시킨다."
      },
      "correctAnswer": "D"
    },
    {
      "id": "u4m49",
      "type": "mcq",
      "question": "객체 형변환 시, 부모 클래스의 참조변수에 자식 객체를 할당하는 것을 무엇이라 하는가?",
      "options": {
        "A": "다운캐스팅",
        "B": "업캐스팅",
        "C": "명시적 형변환",
        "D": "자동 형변환"
      },
      "correctAnswer": "B"
    },
    {
      "id": "u4m50",
      "type": "mcq",
      "question": "접근제한자, 다형성, 객체의 형변환 관련 개념을 종합할 때, 올바른 설명은 무엇인가?",
      "options": {
        "A": "접근제한자는 데이터 은닉, 다형성은 코드 재사용, 형변환은 객체 간 호환성을 제공한다.",
        "B": "접근제한자는 캡슐화를, 다형성은 상속을, 형변환은 메서드 오버로딩을 의미한다.",
        "C": "모든 객체는 자동으로 형변환되며, 접근제한자는 중요하지 않다.",
        "D": "접근제한자와 형변환은 다형성 구현에 아무런 영향을 주지 않는다."
      },
      "correctAnswer": "A"
    },
      {
        "id": "u4c1",
        "type": "code",
        "question": "싱글턴 디자인 패턴에서 객체 생성을 제한하기 위해, instance 필드의 접근제한자로 적절한 키워드를 채워 넣으시오.",
        "codeSnippet": "public class Singleton {\n    __ static Singleton instance = new Singleton();\n    \n    private Singleton() { }\n    \n    public static Singleton getInstance() {\n        return instance;\n    }\n}",
        "answers": ["private"]
      },
      {
        "id": "u4c2",
        "type": "code",
        "question": "싱글턴 디자인 패턴에서 생성자의 접근제한자를 설정하여 외부에서 직접 객체 생성을 방지하기 위해, 생성자 선언에 적절한 접근제한자를 채워 넣으시오.",
        "codeSnippet": "public class Singleton {\n    private static Singleton instance = new Singleton();\n    \n    __ Singleton() {\n        // 초기화 작업\n    }\n    \n    public static Singleton getInstance() {\n        return instance;\n    }\n}",
        "answers": ["private"]
      },
      {
        "id": "u4c3",
        "type": "code",
        "question": "데이터 은닉을 위해, 다음 코드에서 멤버 변수에 사용해야 하는 접근제한자를 채워 넣으시오.",
        "codeSnippet": "public class Person {\n    __ String name;\n    \n    public Person(String name) {\n        this.name = name;\n    }\n    \n    public String getName() {\n        return name;\n    }\n}",
        "answers": ["private"]
      },
      {
        "id": "u4c4",
        "type": "code",
        "question": "다음 코드에서, 입력받은 잔액을 멤버 변수에 저장하기 위한 올바른 할당문을 채워 넣으시오.",
        "codeSnippet": "public class Account {\n    private double balance;\n    \n    public double getBalance() {\n        return balance;\n    }\n    \n    public void setBalance(double balance) {\n        if (balance < 0) {\n            throw new IllegalArgumentException(\"잔액은 음수가 될 수 없습니다.\");\n        }\n        __.__ = __;\n    }\n}",
        "answers": ["this", "balance", "balance"]
      },      
      {
        "id": "u4c5",
        "type": "code",
        "question": "다음 코드에서 상수를 정의하기 위해, MAX_SIZE 변수 선언에 추가되어야 하는 키워드를 채워 넣으시오.",
        "codeSnippet": "public class Constants {\n    public static __ int MAX_SIZE = 100;\n}",
        "answers": ["final"]
      },
      {
        "id": "u4c6",
        "type": "code",
        "question": "다형성을 활용하여 Animal 타입의 변수 a를 Dog 객체로 형변환 후, Dog 클래스에만 있는 메서드를 호출하는 코드에서 빈칸에 들어갈 메서드 이름을 채워 넣으시오.",
        "codeSnippet": "class Animal {\n    public void sound() {\n        System.out.println(\"Animal sound\");\n    }\n}\n\nclass Dog extends Animal {\n    public void sound() {\n        System.out.println(\"Bark\");\n    }\n    \n    public void wagTail() {\n        System.out.println(\"Wagging tail\");\n    }\n}\n\npublic class Test {\n    public static void main(String[] args) {\n        Animal a = new Dog();\n        a.sound();\n        ((Dog) a).__();\n    }\n}",
        "answers": ["wagTail"]
      },
      {
        "id": "u4c7",
        "type": "code",
        "question": "다음 코드에서 instanceof 연산자를 이용하여, Vehicle 타입의 변수 v가 Car 객체임을 확인 후, Car 클래스의 메서드를 호출하는 빈칸에 들어갈 메서드 이름을 채워 넣으시오.",
        "codeSnippet": "class Vehicle {}\nclass Car extends Vehicle {\n    public void drive() {\n        System.out.println(\"Driving\");\n    }\n}\n\npublic class Test {\n    public static void main(String[] args) {\n        Vehicle v = new Car();\n        if (v instanceof Car) {\n            Car c = (Car) v;\n            c.__();\n        }\n    }\n}",
        "answers": ["drive"]
      },
      {
        "id": "u4c8",
        "type": "code",
        "question": "다음 코드에서, 정적 메서드를 선언할 때 반드시 사용해야 하는 키워드를 채워 넣으시오.",
        "codeSnippet": "class Parent {\n    public static void display() {\n        System.out.println(\"Parent display\");\n    }\n}\n\nclass Child extends Parent {\n    public __ void display() {\n        System.out.println(\"Child display\");\n    }\n}",
        "answers": ["static"]
      },
      {
        "id": "u4c9",
        "type": "code",
        "question": "명시적 형변환을 사용하여 Object 타입의 변수 obj를 String 타입으로 변환하는 코드에서, 빈칸에 들어갈 타입 이름을 채워 넣으시오.",
        "codeSnippet": "Object obj = \"Hello\";\nString str = ( __ ) obj;\nSystem.out.println(str);",
        "answers": ["String"]
      },
      {
        "id": "u4c10",
        "type": "code",
        "question": "다형성을 활용한 메서드 호출 예제에서, 참조 변수 s를 통해 호출되는 실제 메서드 이름을 채워 넣으시오.",
        "codeSnippet": "class Shape {\n    public void draw() {\n        System.out.println(\"Drawing Shape\");\n    }\n}\n\nclass Circle extends Shape {\n    @Override\n    public void draw() {\n        System.out.println(\"Drawing Circle\");\n    }\n}\n\npublic class Test {\n    public static void main(String[] args) {\n        Shape s = new Circle();\n        s.__();\n    }\n}",
        "answers": ["draw"]
      },
      {
        "id": "u4c11",
        "type": "code",
        "question": "다음 코드에서, 멤버 변수를 외부에서 직접 접근하지 못하도록 하기 위해 적절한 접근제한자를 채워 넣으시오.",
        "codeSnippet": "public class Bank {\n    __ int accountNumber;\n    \n    public Bank(int accountNumber) {\n        this.accountNumber = accountNumber;\n    }\n}",
        "answers": ["private"]
      },
      {
        "id": "u4c12",
        "type": "code",
        "question": "다음 코드에서, lazy initialization을 위한 조건문에서 instance가 아직 생성되지 않았음을 확인하기 위해, 빈칸에 들어갈 연산자를 채워 넣으시오.",
        "codeSnippet": "public class LazySingleton {\n    private static LazySingleton instance;\n    \n    private LazySingleton() { }\n    \n    public static LazySingleton getInstance() {\n        if (instance __ null) {\n            instance = new LazySingleton();\n        }\n        return instance;\n    }\n}",
        "answers": ["=="]
      },
      {
        "id": "u4c13",
        "type": "code",
        "question": "다음 코드에서, 캡슐화 원칙을 적용하여, private 멤버 변수 id의 값을 반환하는 getter 메서드를 완성하시오.",
        "codeSnippet": "public class Student {\n    private String id;\n    \n    public Student(String id) {\n        this.id = id;\n    }\n    \n    public String getId() {\n        return __;\n    }\n}",
        "answers": ["id"]
      },
      {
        "id": "u4c14",
        "type": "code",
        "question": "다음 코드에서, 온도를 설정하기 위한 setter 메서드 내에서 멤버 변수를 올바르게 할당하기 위해 빈칸에 들어갈 변수명을 채워 넣으시오.",
        "codeSnippet": "public class Temperature {\n    private double celsius;\n    \n    public void setCelsius(double celsius) {\n        if (celsius < -273.15) {\n            throw new IllegalArgumentException(\"온도는 절대 영도보다 낮을 수 없습니다.\");\n        }\n        this.__ = celsius;\n    }\n}",
        "answers": ["celsius"]
      },
      {
        "id": "u4c15",
        "type": "code",
        "question": "다음 코드에서, 자식 클래스에서 부모 클래스의 protected 메서드를 호출하기 위해, 빈칸에 들어갈 메서드 이름을 채워 넣으시오.",
        "codeSnippet": "class Parent {\n    protected void display() {\n        System.out.println(\"Parent display\");\n    }\n}\n\nclass Child extends Parent {\n    public void show() {\n        __();\n    }\n}",
        "answers": ["display"]
      },
      {
        "id": "u4c16",
        "type": "code",
        "question": "다음 코드에서, 객체 생성 없이 클래스 이름을 통해 정적 메서드를 호출하기 위해, 빈칸에 들어갈 메서드 이름을 채워 넣으시오.",
        "codeSnippet": "public class MathUtil {\n    public static int add(int a, int b) {\n        return a + b;\n    }\n}\n\npublic class Test {\n    public static void main(String[] args) {\n        int sum = MathUtil.__(3, 4);\n        System.out.println(sum);\n    }\n}",
        "answers": ["add"]
      },
      {
        "id": "u4c17",
        "type": "code",
        "question": "다음 코드에서, 다형성을 활용하여 자식 클래스의 오버라이딩된 메서드가 호출되도록 하기 위해, 빈칸에 들어갈 메서드 이름을 채워 넣으시오.",
        "codeSnippet": "class Vehicle {\n    public void move() {\n        System.out.println(\"Vehicle moves\");\n    }\n}\n\nclass Bike extends Vehicle {\n    @Override\n    public void move() {\n        System.out.println(\"Bike moves\");\n    }\n}\n\npublic class Test {\n    public static void main(String[] args) {\n        Vehicle v = new Bike();\n        v.__();\n    }\n}",
        "answers": ["move"]
      },
      {
        "id": "u4c18",
        "type": "code",
        "question": "다음 코드에서, instanceof 연산자를 사용하여 obj가 Integer 타입임을 확인하기 위해, 빈칸에 들어갈 타입명을 채워 넣으시오.",
        "codeSnippet": "public class Test {\n    public static void main(String[] args) {\n        Object obj = new Integer(10);\n        if (obj instanceof __) {\n            Integer num = (Integer) obj;\n            System.out.println(num);\n        }\n    }\n}",
        "answers": ["Integer"]
      },
      {
        "id": "u4c19",
        "type": "code",
        "question": "다음 코드에서, 다형성을 활용하여 부모 클래스 타입의 변수 f를 통해 호출되는 메서드 이름을 채워 넣으시오.",
        "codeSnippet": "class Fruit {\n    public void taste() {\n        System.out.println(\"Generic fruit taste\");\n    }\n}\n\nclass Apple extends Fruit {\n    @Override\n    public void taste() {\n        System.out.println(\"Sweet apple\");\n    }\n}\n\npublic class Test {\n    public static void main(String[] args) {\n        Apple a = new Apple();\n        Fruit f = a; // upcasting\n        f.__();\n    }\n}",
        "answers": ["taste"]
      },
      {
        "id": "u4c20",
        "type": "code",
        "question": "다음 Singleton 패턴 구현 예제에서, 멤버 변수 SIZE의 초기화 순서를 보장하기 위해, 빈칸에 들어갈 키워드를 채워 넣으시오.",
        "codeSnippet": "public class Singleton {\n    public __ static int SIZE = 10;\n    private int[] array;\n    \n    private static Singleton instance = new Singleton();\n    \n    private Singleton() {\n        array = new int[SIZE];\n    }\n    \n    public static Singleton getInstance() {\n        return instance;\n    }\n    \n    public int getArrayLength() {\n        return array.length;\n    }\n}",
        "answers": ["final"]
      },
      {
        "id": "u4c21",
        "type": "code",
        "question": "다음 생성자에서, 멤버 변수와 매개변수를 구분하기 위해 빈칸에 들어갈 키워드를 채워 넣으시오.",
        "codeSnippet": "public class Person {\n    private String name;\n    \n    public Person(String name) {\n        __.name = name;\n    }\n}",
        "answers": ["this"]
      },
      {
        "id": "u4c22",
        "type": "code",
        "question": "데이터 보호를 위해, 멤버 변수 password의 접근제한자로 적절한 키워드를 채워 넣으시오.",
        "codeSnippet": "public class User {\n    __ String password;\n    \n    public String getPassword() {\n        return password;\n    }\n}",
        "answers": ["private"]
      },
      {
        "id": "u4c23",
        "type": "code",
        "question": "JDK 16부터 도입된 instanceof 패턴 매칭 문법을 사용하여, obj가 String 타입일 때 변수를 s로 선언하는 코드에서 빈칸에 들어갈 내용을 채워 넣으시오.",
        "codeSnippet": "public class Test {\n    public static void main(String[] args) {\n        Object obj = \"Hello\";\n        if (obj instanceof __) {\n            System.out.println(s.length());\n        }\n    }\n}",
        "answers": ["String s"]
      },
      {
        "id": "u4c24",
        "type": "code",
        "question": "다음 코드에서, 자식 클래스 Dog의 생성자에서 부모 클래스의 생성자를 호출하기 위해, 빈칸에 들어갈 키워드를 채워 넣으시오.",
        "codeSnippet": "class Animal {\n    public Animal(String name) {\n        System.out.println(\"Animal: \" + name);\n    }\n}\n\nclass Dog extends Animal {\n    public Dog(String name) {\n        __(name);\n    }\n}",
        "answers": ["super"]
      },
      {
        "id": "u4c25",
        "type": "code",
        "question": "다음 코드에서, 메서드 오버라이딩 시 부모 클래스보다 접근 제한자를 축소할 수 없음을 보이기 위해, 빈칸에 들어갈 키워드를 채워 넣으시오.",
        "codeSnippet": "class Base {\n    public void perform() {\n        System.out.println(\"Base perform\");\n    }\n}\n\nclass Derived extends Base {\n    __ void perform() {\n        System.out.println(\"Derived perform\");\n    }\n}",
        "answers": ["public"]
      }
    ,    
    {
      "id": "u4s1",
      "type": "subjective",
      "question": "자바의 접근제한자(public, protected, default, private)의 차이점과 각각의 용도를 설명하시오.",
      "correctAnswer": "public: 모든 곳에서 접근 가능, protected: 같은 패키지와 자식 클래스에서 접근 가능, default: 같은 패키지 내에서만, private: 클래스 내부에서만 접근 가능하다."
    },
    {
      "id": "u4s2",
      "type": "subjective",
      "question": "다형성(polymorphism)의 개념과 이를 활용한 객체지향 프로그래밍의 장점을 설명하시오.",
      "correctAnswer": "다형성은 하나의 인터페이스로 여러 종류의 객체를 처리할 수 있게 하여 코드 재사용성과 확장성을 높인다."
    },
    {
      "id": "u4s3",
      "type": "subjective",
      "question": "객체 형변환(upcasting과 downcasting)의 차이점과 주의할 점에 대해 서술하시오.",
      "correctAnswer": "업캐스팅은 자동으로 이루어지며 안정적이지만, 다운캐스팅은 명시적으로 수행해야 하며 실제 객체 타입과 일치하지 않으면 ClassCastException이 발생할 수 있다."
    },
    {
      "id": "u4s4",
      "type": "subjective",
      "question": "접근제한자를 활용하여 캡슐화를 구현하는 방법과 그 장점을 설명하시오.",
      "correctAnswer": "멤버 변수를 private으로 선언하고 public getter/setter를 제공하여 데이터 보호와 내부 구현 변경에 따른 외부 영향 최소화를 이룬다."
    },
    {
      "id": "u4s5",
      "type": "subjective",
      "question": "다형성을 통해 객체를 다루는 방법과 그로 인한 코드 확장성의 이점을 설명하시오.",
      "correctAnswer": "부모 클래스 타입의 참조변수로 자식 객체를 다루면, 새로운 객체 추가 시 기존 코드를 수정할 필요 없이 다형성을 활용하여 유연하게 처리할 수 있다."
    },
    {
      "id": "u4s6",
      "type": "subjective",
      "question": "객체 형변환 시 명시적 형변환의 문법과 주의사항에 대해 서술하시오.",
      "correctAnswer": "명시적 형변환은 (타입) 객체 형태로 사용하며, 실제 객체 타입과 일치하지 않으면 ClassCastException이 발생할 수 있으므로 instanceof 연산자로 안전성을 확인해야 한다."
    },
    {
      "id": "u4s7",
      "type": "subjective",
      "question": "정적 메서드와 인스턴스 메서드의 차이점과 사용 목적에 대해 설명하시오.",
      "correctAnswer": "정적 메서드는 클래스 수준에서 호출되며 객체 상태에 의존하지 않고, 인스턴스 메서드는 객체별로 호출되어 해당 객체의 상태를 처리한다."
    },
    {
      "id": "u4s8",
      "type": "subjective",
      "question": "객체 형변환이 다형성 구현에 미치는 역할과 그 중요성에 대해 논하시오.",
      "correctAnswer": "형변환을 통해 부모 클래스 참조변수로 자식 객체를 다루면 런타임 다형성이 구현되어 다양한 객체의 동작을 통일적으로 처리할 수 있다."
    },
    {
      "id": "u4s9",
      "type": "subjective",
      "question": "접근제한자를 올바르게 사용함으로써 얻을 수 있는 보안상의 이점에 대해 서술하시오.",
      "correctAnswer": "접근제한자는 내부 데이터에 대한 직접 접근을 막아 데이터 무결성과 보안을 강화하며, 외부의 잘못된 접근으로부터 객체를 보호한다."
    },
    {
      "id": "u4s10",
      "type": "subjective",
      "question": "업캐스팅과 다운캐스팅의 사용 시 주의사항 및 그 필요성에 대해 설명하시오.",
      "correctAnswer": "업캐스팅은 자동으로 이루어지지만, 다운캐스팅은 명시적으로 수행해야 하며 실제 객체 타입을 확인하여 안전하게 형변환해야 한다."
    },
    {
      "id": "u4s11",
      "type": "subjective",
      "question": "다형성이 소프트웨어 유지보수에 미치는 긍정적 효과에 대해 설명하시오.",
      "correctAnswer": "다형성을 사용하면 인터페이스를 통해 여러 클래스의 동작을 통일시킬 수 있어, 기능 확장이나 수정 시 기존 코드를 최소한으로 변경할 수 있다."
    },
    {
      "id": "u4s12",
      "type": "subjective",
      "question": "접근제한자 default의 의미와 사용 시 주의사항에 대해 서술하시오.",
      "correctAnswer": "default 접근제한자는 명시적으로 접근제한자를 지정하지 않은 경우로, 같은 패키지 내에서만 접근 가능하므로 패키지 구성에 주의해야 한다."
    },
    {
      "id": "u4s13",
      "type": "subjective",
      "question": "객체의 형변환이 잘못되었을 때 발생하는 문제와 그 해결 방법에 대해 설명하시오.",
      "correctAnswer": "잘못된 형변환은 ClassCastException을 발생시키며, 이를 방지하기 위해 instanceof 연산자를 사용하여 객체 타입을 확인한 후 명시적 형변환을 수행해야 한다."
    },
    {
      "id": "u4s14",
      "type": "subjective",
      "question": "정적 멤버 변수와 인스턴스 멤버 변수의 차이점 및 각각의 장단점에 대해 설명하시오.",
      "correctAnswer": "정적 멤버 변수는 클래스 전체에서 공유되며 메모리 사용을 줄이지만, 객체별 개별 상태 표현이 어렵고, 인스턴스 멤버 변수는 각 객체마다 개별적으로 존재하여 고유 상태를 표현할 수 있다."
    },
    {
      "id": "u4s15",
      "type": "subjective",
      "question": "객체의 형변환과 관련된 문법적 특징 및 주의사항에 대해 서술하시오.",
      "correctAnswer": "객체 형변환은 (타입) 객체 형태로 수행되며, 실제 객체 타입과 일치하지 않으면 ClassCastException이 발생할 수 있으므로, 반드시 instanceof 연산자로 확인해야 한다."
    },
    {
      "id": "u4s16",
      "type": "subjective",
      "question": "다형성을 구현하기 위해 부모 클래스의 메서드를 오버라이딩하는 것이 왜 중요한지 설명하시오.",
      "correctAnswer": "오버라이딩을 통해 자식 클래스는 부모 클래스의 메서드를 자신의 방식으로 재정의하여, 런타임에 올바른 메서드가 호출되도록 함으로써 다형성을 구현한다."
    },
    {
      "id": "u4s17",
      "type": "subjective",
      "question": "접근제한자와 캡슐화가 객체지향 프로그래밍에 미치는 긍정적 효과에 대해 설명하시오.",
      "correctAnswer": "접근제한자는 클래스 내부의 데이터를 외부로부터 보호하여 캡슐화를 구현하고, 이를 통해 코드의 안정성과 보안이 강화된다."
    },
    {
      "id": "u4s18",
      "type": "subjective",
      "question": "업캐스팅과 다운캐스팅의 개념 및 각각의 사용 사례에 대해 서술하시오.",
      "correctAnswer": "업캐스팅은 자식 객체를 부모 타입으로 변환하여 공통 기능을 호출하는 데 유리하며, 다운캐스팅은 자식 클래스의 고유 기능을 사용하기 위해 명시적으로 수행된다."
    },
    {
      "id": "u4s19",
      "type": "subjective",
      "question": "자바에서 static 메서드가 가지는 특징과 그 한계에 대해 설명하시오.",
      "correctAnswer": "static 메서드는 객체 생성 없이 클래스 이름으로 호출되지만, 객체 상태에 접근할 수 없어 인스턴스별 동작 구현에 한계가 있다."
    },
    {
      "id": "u4s20",
      "type": "subjective",
      "question": "객체의 형변환을 통해 다형성을 구현하는 과정과 그 중요성에 대해 서술하시오.",
      "correctAnswer": "형변환을 통해 부모 클래스 참조변수에 자식 객체를 할당하면, 런타임 다형성이 구현되어 다양한 객체의 특성에 따라 적절한 메서드가 호출된다."
    },
    {
      "id": "u4s21",
      "type": "subjective",
      "question": "접근제한자, 다형성, 객체 형변환 개념이 소프트웨어 설계에 미치는 전반적인 영향을 정리하시오.",
      "correctAnswer": "이들 개념은 데이터 보호, 코드 재사용, 확장성 및 유지보수성을 향상시켜, 견고하고 유연한 소프트웨어 설계를 가능하게 한다."
    },
    {
      "id": "u4s22",
      "type": "subjective",
      "question": "객체 형변환에서 발생할 수 있는 오류와 이를 방지하기 위한 방법을 설명하시오.",
      "correctAnswer": "잘못된 형변환은 ClassCastException을 발생시킬 수 있으므로, 반드시 instanceof 연산자로 타입을 확인한 후 명시적 형변환을 수행해야 한다."
    },
    {
      "id": "u4s23",
      "type": "subjective",
      "question": "접근제한자의 적절한 사용이 클래스 간 결합도를 어떻게 낮추는지 설명하시오.",
      "correctAnswer": "접근제한자를 사용하면 클래스 내부의 구현을 감추고, 외부에는 필요한 인터페이스만 노출되어 결합도가 낮아진다."
    },
    {
      "id": "u4s24",
      "type": "subjective",
      "question": "다형성과 객체 형변환을 통해 얻을 수 있는 코드 확장성의 이점을 구체적인 예와 함께 설명하시오.",
      "correctAnswer": "부모 클래스 참조변수로 여러 자식 객체를 처리하면, 새로운 클래스 추가 시 기존 코드를 수정하지 않고 확장이 가능해진다."
    },
    {
      "id": "u4s25",
      "type": "subjective",
      "question": "접근제한자, 다형성, 객체 형변환 개념이 객체지향 프로그래밍 전반에 미치는 긍정적 효과를 요약하시오.",
      "correctAnswer": "이들 개념은 데이터 보호, 코드 재사용 및 확장을 가능하게 하여, 유지보수가 쉽고 유연한 소프트웨어 설계를 지원한다."
    }
  ],
  "unit5": [
    {
      "id": "u5m1",
      "type": "mcq",
      "question": "추상 클래스란 무엇인가?",
      "options": {
        "A": "인스턴스화할 수 없는 클래스",
        "B": "모든 메서드가 구현된 클래스",
        "C": "객체 생성이 가능한 클래스",
        "D": "오직 정적 메서드만 가진 클래스"
      },
      "correctAnswer": "A"
    },
    {
      "id": "u5m2",
      "type": "mcq",
      "question": "인터페이스란 무엇인가?",
      "options": {
        "A": "모든 메서드가 디폴트 메서드인 클래스",
        "B": "모든 메서드가 추상 메서드이며, 상수 필드만 포함하는 타입",
        "C": "객체 생성이 가능한 클래스",
        "D": "메서드 구현과 인스턴스 필드를 모두 포함하는 클래스"
      },
      "correctAnswer": "B"
    },
    {
      "id": "u5m3",
      "type": "mcq",
      "question": "추상 클래스와 인터페이스의 주요 차이점은 무엇인가?",
      "options": {
        "A": "추상 클래스는 다중 상속이 가능하다.",
        "B": "인터페이스는 모든 메서드가 구현되어 있다.",
        "C": "추상 클래스는 상태(멤버 변수)를 가질 수 있으나, 인터페이스는 상수만 가질 수 있다.",
        "D": "인터페이스는 객체 생성이 가능하다."
      },
      "correctAnswer": "C"
    },
    {
      "id": "u5m4",
      "type": "mcq",
      "question": "자바 8 이후 인터페이스에 추가된 기능은 무엇인가?",
      "options": {
        "A": "추상 메서드만 선언 가능하다.",
        "B": "정적 메서드만 추가되었다.",
        "C": "디폴트 메서드가 추가되었다.",
        "D": "디폴트 메서드와 정적 메서드가 모두 추가되었다."
      },
      "correctAnswer": "D"
    },
    {
      "id": "u5m5",
      "type": "mcq",
      "question": "추상 메서드를 포함한 클래스는 반드시 어떤 키워드로 선언되어야 하는가?",
      "options": {
        "A": "abstract",
        "B": "final",
        "C": "static",
        "D": "private"
      },
      "correctAnswer": "A"
    },
    {
      "id": "u5m6",
      "type": "mcq",
      "question": "인터페이스의 필드는 기본적으로 어떤 성질을 가지는가?",
      "options": {
        "A": "인스턴스 변수",
        "B": "public static final 상수",
        "C": "private 변수",
        "D": "변경 가능한 변수"
      },
      "correctAnswer": "B"
    },
    {
      "id": "u5m7",
      "type": "mcq",
      "question": "추상 클래스는 왜 인스턴스화할 수 없는가?",
      "options": {
        "A": "모든 메서드가 구현되어 있기 때문이다.",
        "B": "객체 생성이 메모리 부족으로 불가능하다.",
        "C": "미완성인 추상 메서드를 포함하고 있기 때문이다.",
        "D": "모든 멤버가 정적이기 때문이다."
      },
      "correctAnswer": "C"
    },
    {
      "id": "u5m8",
      "type": "mcq",
      "question": "인터페이스에 디폴트 메서드를 추가한 주된 목적은 무엇인가?",
      "options": {
        "A": "기존 인터페이스를 모두 제거하기 위해",
        "B": "모든 클래스를 강제 구현하게 하기 위해",
        "C": "메서드 오버라이딩을 제한하기 위해",
        "D": "기존 인터페이스를 변경하지 않고도 새로운 메서드를 추가할 수 있도록 하기 위해"
      },
      "correctAnswer": "D"
    },
    {
      "id": "u5m9",
      "type": "mcq",
      "question": "왜 추상 클래스는 인스턴스화할 수 없는가?",
      "options": {
        "A": "추상 메서드를 포함하여 완전한 구현이 없기 때문이다.",
        "B": "메모리 할당이 불가능하기 때문이다.",
        "C": "모든 메서드가 정적이기 때문이다.",
        "D": "인터페이스와 동일하다."
      },
      "correctAnswer": "A"
    },
    {
      "id": "u5m10",
      "type": "mcq",
      "question": "인터페이스는 다중 구현이 가능한 이유는 무엇인가?",
      "options": {
        "A": "자바는 다중 상속을 지원하기 때문이다.",
        "B": "자바는 다중 상속을 지원하지 않지만, 다중 인터페이스 구현은 가능하기 때문이다.",
        "C": "인터페이스는 클래스와 동일하게 동작하기 때문이다.",
        "D": "모든 인터페이스는 자동으로 추상 클래스가 된다."
      },
      "correctAnswer": "B"
    },
    {
      "id": "u5m11",
      "type": "mcq",
      "question": "추상 클래스에서 추상 메서드는 어떻게 선언되는가?",
      "options": {
        "A": "구현부를 포함한 메서드로 선언된다.",
        "B": "정적 메서드로 선언된다.",
        "C": "구현부 없이 선언만 된다.",
        "D": "일반 메서드와 동일하게 선언된다."
      },
      "correctAnswer": "C"
    },
    {
      "id": "u5m12",
      "type": "mcq",
      "question": "인터페이스에 선언된 메서드의 기본 접근제한자는 무엇인가?",
      "options": {
        "A": "private",
        "B": "default",
        "C": "protected",
        "D": "public abstract"
      },
      "correctAnswer": "D"
    },
    {
      "id": "u5m13",
      "type": "mcq",
      "question": "추상 클래스와 인터페이스 중 상태(멤버 변수)를 가질 수 있는 것은?",
      "options": {
        "A": "추상 클래스",
        "B": "인터페이스",
        "C": "둘 다",
        "D": "둘 다 불가능하다"
      },
      "correctAnswer": "A"
    },
    {
      "id": "u5m14",
      "type": "mcq",
      "question": "인터페이스는 다중 상속이 가능한가?",
      "options": {
        "A": "아니요, 불가능하다.",
        "B": "예, 여러 인터페이스를 구현할 수 있다.",
        "C": "조건부로 가능하다.",
        "D": "인터페이스는 상속이 불가능하다."
      },
      "correctAnswer": "B"
    },
    {
      "id": "u5m15",
      "type": "mcq",
      "question": "추상 클래스의 생성자는 주로 어떤 역할을 하는가?",
      "options": {
        "A": "객체 생성을 금지한다.",
        "B": "정적 메서드를 초기화한다.",
        "C": "객체의 상태를 초기화한다.",
        "D": "메모리를 해제한다."
      },
      "correctAnswer": "C"
    },
    {
      "id": "u5m16",
      "type": "mcq",
      "question": "자바 인터페이스는 왜 다중 구현이 가능한가?",
      "options": {
        "A": "인터페이스는 추상 클래스와 동일하기 때문이다.",
        "B": "클래스의 다중 상속이 가능하기 때문이다.",
        "C": "인터페이스는 상속이 불가능하다.",
        "D": "자바는 다중 상속을 지원하지 않지만, 인터페이스는 다중 구현이 가능하기 때문이다."
      },
      "correctAnswer": "D"
    },
    {
      "id": "u5m17",
      "type": "mcq",
      "question": "추상 클래스의 추상 메서드는 반드시 어떤 키워드로 선언되어야 하는가?",
      "options": {
        "A": "final",
        "B": "static",
        "C": "abstract",
        "D": "private"
      },
      "correctAnswer": "C"
    },
    {
      "id": "u5m18",
      "type": "mcq",
      "question": "인터페이스에서 정적 메서드의 도입 목적은 무엇인가?",
      "options": {
        "A": "모든 메서드를 추상화하기 위해",
        "B": "인터페이스 내에서 유틸리티 메서드를 제공하기 위해",
        "C": "객체 생성 없이 메서드를 호출하기 위해",
        "D": "메서드 오버라이딩을 가능하게 하기 위해"
      },
      "correctAnswer": "B"
    },
    {
      "id": "u5m19",
      "type": "mcq",
      "question": "추상 클래스와 인터페이스의 공통점은 무엇인가?",
      "options": {
        "A": "둘 다 인스턴스화할 수 있다.",
        "B": "둘 다 모든 메서드를 구현해야 한다.",
        "C": "둘 다 직접 인스턴스화할 수 없다.",
        "D": "둘 다 상속이 불가능하다."
      },
      "correctAnswer": "C"
    },
    {
      "id": "u5m20",
      "type": "mcq",
      "question": "인터페이스의 메서드는 기본적으로 어떤 성격을 갖는가?",
      "options": {
        "A": "구현부를 포함한다.",
        "B": "디폴트 메서드만 포함한다.",
        "C": "정적 메서드만 포함한다.",
        "D": "추상 메서드이다."
      },
      "correctAnswer": "D"
    },
    {
      "id": "u5m21",
      "type": "mcq",
      "question": "추상 클래스가 인스턴스화할 수 없는 이유는 무엇인가?",
      "options": {
        "A": "추상 메서드를 포함하고 있기 때문이다.",
        "B": "모든 메서드가 정적이기 때문이다.",
        "C": "인터페이스와 동일하기 때문이다.",
        "D": "클래스 상속이 불가능하기 때문이다."
      },
      "correctAnswer": "A"
    },
    {
      "id": "u5m22",
      "type": "mcq",
      "question": "인터페이스는 왜 객체 생성이 불가능한가?",
      "options": {
        "A": "모든 메서드가 구현되어 있기 때문이다.",
        "B": "추상 메서드와 상수만 포함하기 때문이다.",
        "C": "상속받은 클래스가 없기 때문이다.",
        "D": "컴파일러가 자동으로 인터페이스로 변환하기 때문이다."
      },
      "correctAnswer": "B"
    },
    {
      "id": "u5m23",
      "type": "mcq",
      "question": "자바 9 이후 인터페이스에서 추가된 기능 중 하나는 무엇인가?",
      "options": {
        "A": "정적 필드의 추가",
        "B": "디폴트 메서드의 제거",
        "C": "private 메서드의 추가",
        "D": "추상 메서드의 자동 구현"
      },
      "correctAnswer": "C"
    },
    {
      "id": "u5m24",
      "type": "mcq",
      "question": "추상 클래스의 주요 목적은 무엇인가?",
      "options": {
        "A": "객체 생성을 위해",
        "B": "모든 메서드를 구현하기 위해",
        "C": "상태를 감추기 위해",
        "D": "공통 기능을 정의하고, 일부 메서드를 추상화하여 하위 클래스에서 구현하도록 하기 위해"
      },
      "correctAnswer": "D"
    },
    {
      "id": "u5m25",
      "type": "mcq",
      "question": "인터페이스를 구현하는 클래스는 반드시 어떤 메서드를 구현해야 하는가?",
      "options": {
        "A": "모든 디폴트 메서드",
        "B": "모든 정적 메서드",
        "C": "모든 추상 메서드",
        "D": "모든 private 메서드"
      },
      "correctAnswer": "C"
    },
    {
      "id": "u5m26",
      "type": "mcq",
      "question": "추상 클래스와 인터페이스의 상속 관계에서 인터페이스는 어떤 상속을 지원하는가?",
      "options": {
        "A": "단일 상속만 지원한다.",
        "B": "다중 상속을 지원한다.",
        "C": "상속을 지원하지 않는다.",
        "D": "자동 상속된다."
      },
      "correctAnswer": "B"
    },
    {
      "id": "u5m27",
      "type": "mcq",
      "question": "인터페이스 내에서 선언된 필드는 반드시 어떤 성질을 가져야 하는가?",
      "options": {
        "A": "변경 가능하다.",
        "B": "인스턴스 변수이다.",
        "C": "public static final이다.",
        "D": "private이다."
      },
      "correctAnswer": "C"
    },
    {
      "id": "u5m28",
      "type": "mcq",
      "question": "추상 클래스가 일반 클래스보다 갖는 주요 장점은 무엇인가?",
      "options": {
        "A": "더 빠른 실행 속도",
        "B": "더 적은 메모리 사용",
        "C": "객체 생성이 자유롭다",
        "D": "공통 기능을 미리 구현하여 코드 재사용을 촉진한다"
      },
      "correctAnswer": "D"
    },
    {
      "id": "u5m29",
      "type": "mcq",
      "question": "인터페이스에 디폴트 메서드를 사용하면 얻을 수 있는 이점은 무엇인가?",
      "options": {
        "A": "기존 인터페이스를 변경하지 않고 새로운 기능을 추가할 수 있다.",
        "B": "객체 생성 속도가 빨라진다.",
        "C": "메모리 사용량이 줄어든다.",
        "D": "모든 메서드가 자동으로 구현된다."
      },
      "correctAnswer": "A"
    },
    {
      "id": "u5m30",
      "type": "mcq",
      "question": "추상 클래스의 생성자는 주로 어떤 역할을 수행하는가?",
      "options": {
        "A": "객체를 반환한다.",
        "B": "객체의 초기화를 담당한다.",
        "C": "메서드를 오버라이딩한다.",
        "D": "정적 멤버를 초기화한다."
      },
      "correctAnswer": "B"
    },
    {
      "id": "u5m31",
      "type": "mcq",
      "question": "인터페이스에서 선언된 메서드는 기본적으로 어떤 형태로 선언되는가?",
      "options": {
        "A": "구현부가 포함된 메서드",
        "B": "디폴트 메서드만",
        "C": "추상 메서드로 선언된다",
        "D": "정적 메서드만"
      },
      "correctAnswer": "C"
    },
    {
      "id": "u5m32",
      "type": "mcq",
      "question": "자바에서 인터페이스의 다중 구현이 가능한 이유는 무엇인가?",
      "options": {
        "A": "인터페이스는 클래스와 동일하다.",
        "B": "메모리 절약 효과가 있다.",
        "C": "인터페이스는 단일 상속만 지원한다.",
        "D": "자바는 다중 상속을 허용하지 않지만, 인터페이스는 다중 구현이 가능하다."
      },
      "correctAnswer": "D"
    },
    {
      "id": "u5m33",
      "type": "mcq",
      "question": "추상 클래스의 추상 메서드는 반드시 어떤 키워드로 선언되어야 하는가?",
      "options": {
        "A": "final",
        "B": "static",
        "C": "abstract",
        "D": "private"
      },
      "correctAnswer": "C"
    },
    {
      "id": "u5m34",
      "type": "mcq",
      "question": "인터페이스에서 정적 메서드의 도입 목적은 무엇인가?",
      "options": {
        "A": "모든 메서드를 추상화하기 위해",
        "B": "인터페이스 내에서 유틸리티 메서드를 제공하기 위해",
        "C": "객체 생성 없이 메서드를 호출하기 위해",
        "D": "메서드 오버라이딩을 가능하게 하기 위해"
      },
      "correctAnswer": "B"
    },
    {
      "id": "u5m35",
      "type": "mcq",
      "question": "추상 클래스와 인터페이스의 공통점은 무엇인가?",
      "options": {
        "A": "둘 다 인스턴스화할 수 있다.",
        "B": "둘 다 모든 메서드가 구현되어 있다.",
        "C": "둘 다 직접 인스턴스화할 수 없다.",
        "D": "둘 다 상속이 불가능하다."
      },
      "correctAnswer": "C"
    },
    {
      "id": "u5m36",
      "type": "mcq",
      "question": "인터페이스에서 모든 필드는 암시적으로 어떤 성질을 갖는가?",
      "options": {
        "A": "non-static",
        "B": "변경 가능하다",
        "C": "인스턴스 변수이다",
        "D": "public static final"
      },
      "correctAnswer": "D"
    },
    {
      "id": "u5m37",
      "type": "mcq",
      "question": "추상 클래스의 주요 목적은 무엇인가?",
      "options": {
        "A": "공통 기능의 정의와 일부 메서드의 추상화를 통해 하위 클래스에서 구현을 강제하기 위해",
        "B": "객체 생성 시간을 단축하기 위해",
        "C": "메모리 사용량을 줄이기 위해",
        "D": "모든 메서드를 자동으로 구현하기 위해"
      },
      "correctAnswer": "A"
    },
    {
      "id": "u5m38",
      "type": "mcq",
      "question": "추상 클래스와 인터페이스의 차이점 중 올바른 설명은 무엇인가?",
      "options": {
        "A": "인터페이스는 객체 생성이 가능하다.",
        "B": "추상 클래스는 상태(멤버 변수)를 가질 수 있으나, 인터페이스는 상수만 가질 수 있다.",
        "C": "둘 다 모든 메서드를 추상적으로 선언한다.",
        "D": "추상 클래스는 다중 상속을 지원한다."
      },
      "correctAnswer": "B"
    },
    {
      "id": "u5m39",
      "type": "mcq",
      "question": "인터페이스를 구현하는 클래스는 반드시 무엇을 구현해야 하는가?",
      "options": {
        "A": "디폴트 메서드",
        "B": "정적 메서드",
        "C": "추상 메서드",
        "D": "모든 멤버 변수"
      },
      "correctAnswer": "C"
    },
    {
      "id": "u5m40",
      "type": "mcq",
      "question": "추상 클래스와 인터페이스를 사용하는 공통 목표는 무엇인가?",
      "options": {
        "A": "객체 생성을 위한 메모리 확보",
        "B": "데이터 보호",
        "C": "메모리 최적화",
        "D": "코드 재사용과 다형성 구현"
      },
      "correctAnswer": "D"
    },
    {
      "id": "u5m41",
      "type": "mcq",
      "question": "자바 인터페이스의 메서드는 기본적으로 어떤 성격을 갖는가?",
      "options": {
        "A": "추상 메서드",
        "B": "디폴트 메서드",
        "C": "정적 메서드",
        "D": "구현이 포함된 메서드"
      },
      "correctAnswer": "A"
    },
    {
      "id": "u5m42",
      "type": "mcq",
      "question": "추상 클래스는 일반 클래스와 달리 어떤 특징을 갖는가?",
      "options": {
        "A": "모든 메서드가 정적이다.",
        "B": "인스턴스화할 수 없다.",
        "C": "모든 필드가 final이다.",
        "D": "모든 메서드가 추상 메서드이다."
      },
      "correctAnswer": "B"
    },
    {
      "id": "u5m43",
      "type": "mcq",
      "question": "인터페이스에서 구현된 디폴트 메서드는 무엇을 가능하게 하는가?",
      "options": {
        "A": "기존 인터페이스를 모두 제거한다.",
        "B": "모든 메서드를 강제로 구현하게 한다.",
        "C": "기존 인터페이스를 변경하지 않고도 새로운 기능을 추가할 수 있게 한다.",
        "D": "추상 메서드로 자동 변환된다."
      },
      "correctAnswer": "C"
    },
    {
      "id": "u5m44",
      "type": "mcq",
      "question": "추상 클래스에서 일반 메서드와 추상 메서드를 동시에 정의할 수 있는가?",
      "options": {
        "A": "불가능하다.",
        "B": "가능하지만 모든 메서드를 추상으로 선언해야 한다.",
        "C": "가능하다, 단 추상 메서드는 반드시 abstract 키워드를 사용해야 한다.",
        "D": "가능하며, 일반 메서드는 구현을 포함할 수 있다."
      },
      "correctAnswer": "D"
    },
    {
      "id": "u5m45",
      "type": "mcq",
      "question": "자바 9 이후 인터페이스에 새로 추가된 기능 중 하나는 무엇인가?",
      "options": {
        "A": "private 메서드",
        "B": "추상 생성자",
        "C": "인스턴스 필드",
        "D": "정적 블록"
      },
      "correctAnswer": "A"
    },
    {
      "id": "u5m46",
      "type": "mcq",
      "question": "추상 클래스와 인터페이스를 선택할 때 고려해야 할 주요 요소는 무엇인가?",
      "options": {
        "A": "메모리 사용량",
        "B": "코드 재사용 및 확장성",
        "C": "컴파일 속도",
        "D": "오버라이딩의 유무"
      },
      "correctAnswer": "B"
    },
    {
      "id": "u5m47",
      "type": "mcq",
      "question": "인터페이스를 구현하는 클래스는 반드시 어떤 메서드를 구현해야 하는가?",
      "options": {
        "A": "디폴트 메서드",
        "B": "정적 메서드",
        "C": "추상 메서드",
        "D": "private 메서드"
      },
      "correctAnswer": "C"
    },
    {
      "id": "u5m48",
      "type": "mcq",
      "question": "왜 추상 클래스는 인스턴스화할 수 없는가?",
      "options": {
        "A": "모든 메서드가 구현되어 있기 때문이다.",
        "B": "메모리 부족 문제 때문이다.",
        "C": "컴파일러가 이를 금지하기 때문이다.",
        "D": "추상 메서드를 포함하여 완전한 구현이 없기 때문이다."
      },
      "correctAnswer": "D"
    },
    {
      "id": "u5m49",
      "type": "mcq",
      "question": "자바에서 인터페이스의 다중 구현이 가능한 이유는 무엇인가?",
      "options": {
        "A": "자바가 클래스의 다중 상속을 허용하기 때문이다.",
        "B": "인터페이스는 추상 클래스와 동일하다.",
        "C": "인터페이스는 모든 메서드가 디폴트이다.",
        "D": "자바는 다중 상속을 허용하지 않지만, 인터페이스는 다중 구현이 가능하다."
      },
      "correctAnswer": "D"
    },
    {
      "id": "u5m50",
      "type": "mcq",
      "question": "추상 클래스와 인터페이스를 활용한 객체지향 설계의 주요 목표는 무엇인가?",
      "options": {
        "A": "데이터 보호",
        "B": "메모리 최적화",
        "C": "객체 생성 시간 단축",
        "D": "코드 재사용과 다형성 구현"
      },
      "correctAnswer": "D"
    },
      {
        "id": "u5c1",
        "type": "code",
        "question": "Abstract 클래스로 선언하기 위해 클래스 선언부에 추가해야 하는 키워드를 채워 넣으시오.",
        "codeSnippet": "public __ class Vehicle {\n    // 공통 멤버와 메서드\n}",
        "answers": ["abstract"]
      },
      {
        "id": "u5c2",
        "type": "code",
        "question": "추상 메서드는 구현부가 없으므로, 메서드 선언 후 빈 구현 대신 사용할 키워드를 채워 넣으시오.",
        "codeSnippet": "public abstract class Vehicle {\n    public __ void addFuel();\n}",
        "answers": ["abstract"]
      },
      {
        "id": "u5c3",
        "type": "code",
        "question": "추상 클래스를 상속받은 자식 클래스에서, 추상 메서드를 재정의할 때 사용해야 하는 접근제한자를 채워 넣으시오.",
        "codeSnippet": "public abstract class Vehicle {\n    public abstract void addFuel();\n}\n\npublic class ElectricCar extends Vehicle {\n    @Override\n    __ void addFuel() {\n        System.out.println(\"Charging...\");\n    }\n}",
        "answers": ["public"]
      },
      {
        "id": "u5c4",
        "type": "code",
        "question": "인터페이스에서 메서드를 선언할 때, 생략 가능한 키워드 대신 명시적으로 작성할 수 있는 키워드를 채워 넣으시오.",
        "codeSnippet": "public interface Drivable {\n    ____ void drive();\n}",
        "answers": ["public","abstract"]
      },
      {
        "id": "u5c5",
        "type": "code",
        "question": "인터페이스 내의 변수는 암묵적으로 상수로 취급되는데, 이를 명시하기 위해 추가할 수 있는 키워드를 채워 넣으시오.",
        "codeSnippet": "public interface Config {\n    ______ int TIMEOUT = 30;\n}",
        "answers": ["public","static","final"]
      },
      {
        "id": "u5c6",
        "type": "code",
        "question": "클래스가 인터페이스를 구현할 때 사용하는 키워드를 채워 넣으시오.",
        "codeSnippet": "public interface Flyable {\n    void fly();\n}\n\npublic class Airplane __ Flyable {\n    @Override\n    public void fly() {\n        System.out.println(\"Flying\");\n    }\n}",
        "answers": ["implements"]
      },
      {
        "id": "u5c7",
        "type": "code",
        "question": "추상 클래스 Vehicle을 상속받아, 구체적인 객체를 생성할 수 있는 DieselSUV 클래스를 사용하여 Vehicle 타입의 참조변수를 초기화하시오.",
        "codeSnippet": "public abstract class Vehicle {\n    public abstract void addFuel();\n}\n\npublic class DieselSUV extends Vehicle {\n    @Override\n    public void addFuel() {\n        System.out.println(\"Adding diesel\");\n    }\n}\n\npublic class VehicleTest {\n    public static void main(String[] args) {\n        Vehicle v = new __();\n        v.addFuel();\n    }\n}",
        "answers": ["DieselSUV"]
      },
      {
        "id": "u5c8",
        "type": "code",
        "question": "인터페이스에서 기본 메서드(default method)를 정의하기 위해 메서드 선언부에 추가할 키워드를 채워 넣으시오.",
        "codeSnippet": "public interface Operable {\n    __ void start() {\n        System.out.println(\"Starting operation\");\n    }\n}",
        "answers": ["default"]
      },
      {
        "id": "u5c9",
        "type": "code",
        "question": "인터페이스에 정의된 정적 메서드를 호출할 때 사용하는 메서드 이름을 채워 넣으시오.",
        "codeSnippet": "public interface Calculator {\n    static int add(int a, int b) {\n        return a + b;\n    }\n}\n\npublic class Test {\n    public static void main(String[] args) {\n        int sum = Calculator.__(3, 4);\n        System.out.println(sum);\n    }\n}",
        "answers": ["add"]
      },
      {
        "id": "u5c10",
        "type": "code",
        "question": "두 개 이상의 인터페이스를 구현할 때 사용하는 키워드를 채워 넣으시오.",
        "codeSnippet": "public interface Printable {\n    void print();\n}\n\npublic interface Scannable {\n    void scan();\n}\n\npublic class MultiFunctionPrinter __ Printable, Scannable {\n    @Override\n    public void print() {\n        System.out.println(\"Printing\");\n    }\n    @Override\n    public void scan() {\n        System.out.println(\"Scanning\");\n    }\n}",
        "answers": ["implements"]
      },

      {
         "id": "u5c11",
         "type": "code",
          "question": "여러 인터페이스에서 동일한 기본 메서드가 정의된 경우, 특정 인터페이스의 기본 메서드를 호출하기 위해 필요한 구문을 채워 넣으시오.",
          "codeSnippet": "public interface A {\n    default void show() {\n        System.out.println(\"A\");\n    }\n}\n\npublic interface B {\n    default void show() {\n        System.out.println(\"B\");\n    }\n}\n\npublic class Test implements A, B {\n    @Override\n    public void show() {\n        __.__.show(); // 호출: 인터페이스 A의 기본 메서드\n    }\n}\n",
          "answers": ["A", "super"]
       },
        {
          "id": "u5c12",
          "type": "code",
          "question": "추상 클래스의 메서드 호출 시, 상속받은 구체적 구현을 명시적으로 호출하기 위해 사용해야 하는 키워드를 채워 넣으시오.",
          "codeSnippet": "public abstract class Machine {\n    public void start() {\n        System.out.println(\"Machine starting\");\n    }\n    public abstract void stop();\n}\n\npublic class Computer extends Machine {\n    @Override\n    public void stop() {\n        System.out.println(\"Computer stopping\");\n    }\n    \n    public void restart() {\n        __.__; // 부모 클래스의 start() 메서드 호출\n        stop();\n    }\n}\n",
          "answers": ["super", "start()"]
        },
      
      {
        "id": "u5c13",
        "type": "code",
        "question": "추상 메서드 선언 시, 구현부 대신 사용해야 하는 기호를 채워 넣으시오.",
        "codeSnippet": "public abstract class Animal {\n    public abstract void makeSound() __\n}",
        "answers": [";"]
      },
      {
        "id": "u5c14",
        "type": "code",
        "question": "클래스가 인터페이스를 구현할 때, 인터페이스 이름 뒤에 추가해야 하는 키워드를 채워 넣으시오.",
        "codeSnippet": "public interface Operable {\n    void operate();\n}\n\npublic class Machine __ Operable {\n    @Override\n    public void operate() {\n        System.out.println(\"Operating machine\");\n    }\n}",
        "answers": ["implements"]
      },
      {
        "id": "u5c15",
        "type": "code",
        "question": "다형성을 활용하여, 추상 클래스의 구체적 메서드를 호출하는 예제에서 빈칸에 들어갈 메서드 이름을 채워 넣으시오.",
        "codeSnippet": "public abstract class Shape {\n    public abstract double area();\n    public void display() {\n        System.out.println(\"Displaying shape\");\n    }\n}\n\npublic class Circle extends Shape {\n    private double radius;\n    public Circle(double radius) {\n        this.radius = radius;\n    }\n    @Override\n    public double area() {\n        return Math.PI * radius * radius;\n    }\n}\n\npublic class Test {\n    public static void main(String[] args) {\n        Shape s = new Circle(5);\n        System.out.println(\"Area: \" + s.area());\n        s.__();\n    }\n}\n",
        "answers": ["display"]
      },
      {
        "id": "u5c16",
        "type": "code",
        "question": "인터페이스 상속 시, 상위 인터페이스의 메서드만 호출할 수 있는 상황에서, 변수 a로 호출 가능한 메서드를 채워 넣으시오.",
        "codeSnippet": "public interface A {\n    void methodA();\n}\npublic interface B extends A {\n    void methodB();\n}\npublic class C implements B {\n    @Override\n    public void methodA() {\n        System.out.println(\"A\");\n    }\n    @Override\n    public void methodB() {\n        System.out.println(\"B\");\n    }\n}\npublic class Test {\n    public static void main(String[] args) {\n        A a = new C();\n        a.__();\n    }\n}\n",
        "answers": ["methodA"]
      },
      {
        "id": "u5c17",
        "type": "code",
        "question": "추상 클래스를 상속받은 구체 클래스의 메서드를 호출하는 예제에서, 빈칸에 들어갈 메서드 이름을 채워 넣으시오.",
        "codeSnippet": "public abstract class Appliance {\n    public abstract void turnOn();\n}\n\npublic class Fan extends Appliance {\n    @Override\n    public void turnOn() {\n        System.out.println(\"Fan is on\");\n    }\n}\n\npublic class Test {\n    public static void main(String[] args) {\n        Appliance app = new Fan();\n        app.__();\n    }\n}\n",
        "answers": ["turnOn"]
      },
      {
        "id": "u5c18",
        "type": "code",
        "question": "여러 인터페이스에서 동일한 기본 메서드가 정의된 경우, 특정 인터페이스의 메서드를 호출하기 위한 구문을 채워 넣으시오.",
        "codeSnippet": "public interface X {\n    default void action() {\n        System.out.println(\"Action from X\");\n    }\n}\npublic interface Y {\n    default void action() {\n        System.out.println(\"Action from Y\");\n    }\n}\npublic class Z implements X, Y {\n    @Override\n    public void action() {\n        // 충돌 해결: X의 기본 메서드 호출\n        __.action();\n    }\n}\n",
        "answers": ["X.super"]
      },
      {
        "id": "u5c19",
        "type": "code",
        "question": "추상 클래스의 생성자에서, 자식 클래스의 생성자 호출을 위해 사용해야 하는 키워드를 채워 넣으시오.",
        "codeSnippet": "public abstract class Tool {\n    protected String name;\n    public Tool(String name) {\n        this.name = name;\n    }\n}\n\npublic class Hammer extends Tool {\n    public Hammer(String name) {\n        __;\n    }\n}\n",
        "answers": ["super(name)"]
      },
      {
        "id": "u5c20",
        "type": "code",
        "question": "인터페이스를 타입으로 사용하여, 구현 클래스의 메서드를 호출하는 예제에서 빈칸에 들어갈 메서드 이름을 채워 넣으시오.",
        "codeSnippet": "public interface Drivable {\n    void drive();\n}\n\npublic class Car implements Drivable {\n    @Override\n    public void drive() {\n        System.out.println(\"Car driving\");\n    }\n}\n\npublic class Test {\n    public static void main(String[] args) {\n        Drivable d = new Car();\n        d.__();\n    }\n}\n",
        "answers": ["drive"]
      },
      {
        "id": "u5c21",
        "type": "code",
        "question": "추상 클래스 Animal을 상속받은 자식 클래스에서, 추상 메서드를 재정의할 때 올바른 접근 제한자를 채워 넣으시오.",
        "codeSnippet": "public abstract class Animal {\n    public abstract void makeSound();\n}\n\npublic class Cat extends Animal {\n    @Override\n    public __ void makeSound() {\n        System.out.println(\"Meow\");\n    }\n}\n",
        "answers": ["public"]
      },
      {
        "id": "u5c22",
        "type": "code",
        "question": "인터페이스를 선언할 때, 인터페이스임을 나타내는 키워드를 채워 넣으시오.",
        "codeSnippet": "public __ Drawable {\n    void draw();\n}\n",
        "answers": ["interface"]
      },
      {
        "id": "u5c23",
        "type": "code",
        "question": "인터페이스 상속 시, 하위 인터페이스가 상위 인터페이스의 기능을 포함하도록 선언할 때 사용하는 키워드를 채워 넣으시오.",
        "codeSnippet": "public interface First {\n    void firstMethod();\n}\n\npublic interface Second {\n    void secondMethod();\n}\n\npublic interface Combined __ First, Second {\n    // Combined 인터페이스는 First와 Second의 기능을 모두 포함함\n}\n",
        "answers": ["extends"]
      },
      {
        "id": "u5c24",
        "type": "code",
        "question": "추상 클래스의 자식 클래스에서, 부모 클래스의 생성자를 호출하기 위해 사용해야 하는 키워드를 채워 넣으시오.",
        "codeSnippet": "public abstract class AbstractEntity {\n    protected int id;\n    public AbstractEntity(int id) {\n        this.id = id;\n    }\n}\n\npublic class UserEntity extends AbstractEntity {\n    public UserEntity(int id) {\n        __;\n    }\n}\n",
        "answers": ["super(id)"]
      },
      {
        "id": "u5c25",
        "type": "code",
        "question": "인터페이스 내에 메서드를 정의할 때, 모든 메서드가 암묵적으로 갖는 접근제한자를 명시적으로 작성하려면 어떤 키워드를 사용해야 하는지 채워 넣으시오.",
        "codeSnippet": "public interface Sample {\n    ____ void execute();\n}\n",
        "answers": ["public","abstract"]
      }
    ,
    {
      "id": "u5s1",
      "type": "subjective",
      "question": "추상 클래스의 개념과 사용 목적에 대해 설명하시오.",
      "correctAnswer": "추상 클래스는 인스턴스화할 수 없는 클래스이며, 공통 기능의 일부를 구현하고 하위 클래스에서 구체적인 구현을 강제하기 위해 사용된다."
    },
    {
      "id": "u5s2",
      "type": "subjective",
      "question": "인터페이스의 주요 특징과 활용 방안에 대해 서술하시오.",
      "correctAnswer": "인터페이스는 오직 추상 메서드와 상수만을 포함하여, 다중 구현을 통해 클래스 간의 계약을 정의하고, 다형성을 구현하는 데 사용된다."
    },
    {
      "id": "u5s3",
      "type": "subjective",
      "question": "추상 메서드와 일반 메서드의 차이점을 설명하시오.",
      "correctAnswer": "추상 메서드는 선언만 있고 구현이 없으며, 일반 메서드는 구현부를 포함하여 동작을 정의한다."
    },
    {
      "id": "u5s4",
      "type": "subjective",
      "question": "자바에서 추상 클래스와 인터페이스 중 언제 각각을 사용하는지 설명하시오.",
      "correctAnswer": "추상 클래스는 공통 상태와 메서드 구현이 필요한 경우, 인터페이스는 다양한 클래스에서 공통된 계약을 강제하고 다중 구현이 필요한 경우 사용한다."
    },
    {
      "id": "u5s5",
      "type": "subjective",
      "question": "인터페이스에 디폴트 메서드가 도입된 배경과 그 장점에 대해 설명하시오.",
      "correctAnswer": "디폴트 메서드는 기존 인터페이스를 변경하지 않고도 새로운 메서드를 추가할 수 있게 하여, 기존 구현체와의 호환성을 유지하면서 기능 확장이 가능하게 한다."
    },
    {
      "id": "u5s6",
      "type": "subjective",
      "question": "추상 클래스와 인터페이스의 상속 관계에 대해 설명하시오.",
      "correctAnswer": "추상 클래스는 단일 상속을 통해 하위 클래스에 공통 기능을 물려주고, 인터페이스는 다중 구현이 가능하여 여러 계약을 동시에 만족시킬 수 있다."
    },
    {
      "id": "u5s7",
      "type": "subjective",
      "question": "자바 인터페이스의 다중 구현이 가능한 이유와 그 장점을 서술하시오.",
      "correctAnswer": "자바는 클래스의 다중 상속은 지원하지 않지만, 인터페이스의 다중 구현을 통해 다양한 기능을 조합할 수 있어 유연하고 확장성 있는 설계가 가능하다."
    },
    {
      "id": "u5s8",
      "type": "subjective",
      "question": "추상 클래스에서 생성자의 역할과 필요성에 대해 설명하시오.",
      "correctAnswer": "추상 클래스의 생성자는 하위 클래스에서 공통적으로 사용되는 멤버 변수 초기화 및 기본 상태 설정을 담당하여, 객체의 일관된 초기화를 보장한다."
    },
    {
      "id": "u5s9",
      "type": "subjective",
      "question": "인터페이스에 선언된 메서드를 구현하는 클래스의 책임에 대해 논하시오.",
      "correctAnswer": "인터페이스를 구현하는 클래스는 인터페이스에 선언된 모든 추상 메서드를 구현하여, 해당 계약을 충족시키고 다형성을 실현해야 한다."
    },
    {
      "id": "u5s10",
      "type": "subjective",
      "question": "추상 메서드를 포함한 클래스 디자인의 장점과 단점에 대해 설명하시오.",
      "correctAnswer": "추상 메서드를 포함한 클래스는 공통 기능을 정의하고 하위 클래스에 구현을 강제하여 코드 재사용성을 높이지만, 잘못 사용하면 유연성이 떨어질 수 있다."
    },
    {
      "id": "u5s11",
      "type": "subjective",
      "question": "인터페이스와 추상 클래스의 유사점과 차이점을 비교하시오.",
      "correctAnswer": "둘 다 객체를 직접 생성할 수 없고, 공통 기능을 정의하는 역할을 하지만, 추상 클래스는 상태와 구현을 가질 수 있고, 인터페이스는 오직 상수와 추상 메서드(디폴트/정적 메서드 포함)만 가진다."
    },
    {
      "id": "u5s12",
      "type": "subjective",
      "question": "디폴트 메서드와 정적 메서드의 차이점에 대해 설명하시오.",
      "correctAnswer": "디폴트 메서드는 인스턴스 메서드처럼 동작하며 오버라이딩이 가능하지만, 정적 메서드는 클래스 이름으로 호출되고 오버라이딩할 수 없다."
    },
    {
      "id": "u5s13",
      "type": "subjective",
      "question": "자바 9 이후 인터페이스의 개선 사항에 대해 서술하시오.",
      "correctAnswer": "자바 9에서는 인터페이스에 private 메서드가 도입되어, 디폴트 메서드의 중복 코드를 줄이고 내부 구현을 캡슐화할 수 있게 되었다."
    },
    {
      "id": "u5s14",
      "type": "subjective",
      "question": "추상 클래스의 상속을 통한 코드 재사용의 이점과 한계에 대해 논하시오.",
      "correctAnswer": "추상 클래스는 공통 기능을 재사용하여 코드 중복을 줄이지만, 단일 상속만 지원하므로 클래스 계층 구조가 복잡해지면 결합도가 높아지는 한계가 있다."
    },
    {
      "id": "u5s15",
      "type": "subjective",
      "question": "인터페이스 구현 시 다형성 구현의 중요성에 대해 설명하시오.",
      "correctAnswer": "인터페이스를 통해 여러 클래스의 동작을 통일된 방식으로 처리할 수 있어, 코드의 유연성과 확장성을 크게 향상시킨다."
    },
    {
      "id": "u5s16",
      "type": "subjective",
      "question": "추상 클래스와 인터페이스 중 어느 것을 선택할지 결정할 때 고려해야 할 사항은 무엇이며, 그 이유는 무엇인가?",
      "correctAnswer": "클래스에 공통 상태와 구현이 필요한 경우 추상 클래스를, 여러 클래스로부터 동일한 계약을 강제하고자 할 때 인터페이스를 선택한다."
    },
    {
      "id": "u5s17",
      "type": "subjective",
      "question": "인터페이스에 상수를 선언하는 이유와 그 효과에 대해 설명하시오.",
      "correctAnswer": "인터페이스의 상수는 모든 구현체에서 공통적으로 사용할 수 있는 불변 값을 제공하여, 코드의 일관성과 안전성을 높인다."
    },
    {
      "id": "u5s18",
      "type": "subjective",
      "question": "추상 메서드의 선언이 클래스 디자인에 미치는 영향에 대해 서술하시오.",
      "correctAnswer": "추상 메서드 선언은 하위 클래스에서 반드시 구현하도록 강제하여, 클래스 설계의 일관성과 확장성을 높이는 역할을 한다."
    },
    {
      "id": "u5s19",
      "type": "subjective",
      "question": "인터페이스를 통한 다중 상속이 객체지향 설계에 미치는 이점에 대해 설명하시오.",
      "correctAnswer": "다중 인터페이스 구현을 통해 하나의 클래스가 여러 계약을 동시에 만족시킬 수 있어, 유연하고 확장 가능한 설계가 가능하다."
    },
    {
      "id": "u5s20",
      "type": "subjective",
      "question": "추상 클래스와 인터페이스가 제공하는 캡슐화 효과에 대해 논하시오.",
      "correctAnswer": "두 개념 모두 내부 구현을 감추고 외부에는 필요한 인터페이스만 노출하여, 데이터 보호와 유지보수성을 향상시킨다."
    },
    {
      "id": "u5s21",
      "type": "subjective",
      "question": "디폴트 메서드를 사용하여 인터페이스 확장의 유연성을 어떻게 확보할 수 있는지 설명하시오.",
      "correctAnswer": "디폴트 메서드는 기존 인터페이스에 변경 없이 새로운 기능을 추가할 수 있어, 구현체의 호환성을 유지하면서 기능 확장이 가능하다."
    },
    {
      "id": "u5s22",
      "type": "subjective",
      "question": "추상 클래스의 추상 메서드가 하위 클래스에 미치는 강제성에 대해 논하시오.",
      "correctAnswer": "추상 메서드는 하위 클래스에서 반드시 구현해야 하므로, 클래스 설계 시 일관성과 필수 기능 구현을 보장한다."
    },
    {
      "id": "u5s23",
      "type": "subjective",
      "question": "인터페이스 구현 시 나타나는 일반적인 문제점과 그 해결 방법에 대해 설명하시오.",
      "correctAnswer": "인터페이스 구현 시 중복 코드나 불필요한 강제 구현 문제가 발생할 수 있으며, 디폴트 메서드와 추상 클래스를 적절히 혼용하여 해결할 수 있다."
    },
    {
      "id": "u5s24",
      "type": "subjective",
      "question": "추상 클래스와 인터페이스의 활용 예를 들어, 실제 애플리케이션 설계에 미치는 영향을 설명하시오.",
      "correctAnswer": "예를 들어, GUI 프레임워크에서는 추상 클래스를 통해 기본 위젯 기능을 제공하고, 인터페이스를 통해 이벤트 처리 계약을 정의하여 유연한 확장을 가능하게 한다."
    },
    {
      "id": "u5s25",
      "type": "subjective",
      "question": "자바에서 추상 클래스와 인터페이스를 함께 사용할 때의 장점과 단점에 대해 논하시오.",
      "correctAnswer": "추상 클래스와 인터페이스를 함께 사용하면, 공통 기능과 계약을 분리하여 코드 재사용성과 유연성을 높일 수 있지만, 설계가 복잡해지고 클래스 간 결합도가 증가할 위험이 있다."
    }
  ]
}
