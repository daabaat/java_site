{
  "unit1": [
    {
      "id": "m1",
      "type": "mcq",
      "question": "다음 중 유효한 자바 변수 선언은 무엇인가?",
      "options": {
        "A": "int 1number = 10;",
        "B": "int number = 10;",
        "C": "int number 10;",
        "D": "int number: 10;"
      },
      "correctAnswer": "B"
    },
    {
      "id": "m2",
      "type": "mcq",
      "question": "다음 코드에서 int a = 5; double b = 2.0; 일 때, a/b의 결과 타입은?",
      "options": {
        "A": "int",
        "B": "double",
        "C": "float",
        "D": "long"
      },
      "correctAnswer": "B"
    },
    {
      "id": "m3",
      "type": "mcq",
      "question": "명시적 형변환이 필요한 경우는 어느 상황인가?",
      "options": {
        "A": "int에서 double로 변환할 때",
        "B": "double에서 int로 변환할 때",
        "C": "int에서 long으로 변환할 때",
        "D": "char에서 int로 변환할 때"
      },
      "correctAnswer": "B"
    },
    {
      "id": "m4",
      "type": "mcq",
      "question": "다음 중 올바른 배열 선언은?",
      "options": {
        "A": "int[] arr = new int[10];",
        "B": "int arr = new int[10];",
        "C": "int arr[] = new int(10);",
        "D": "int[] arr = int[10];"
      },
      "correctAnswer": "A"
    },
    {
      "id": "m5",
      "type": "mcq",
      "question": "자바에서 객체 생성을 위해 사용하는 키워드는?",
      "options": {
        "A": "build",
        "B": "create",
        "C": "new",
        "D": "init"
      },
      "correctAnswer": "C"
    },
    {
      "id": "m6",
      "type": "mcq",
      "question": "double d = 9.99; int i = (int)d; 의 결과는?",
      "options": {
        "A": "9.99",
        "B": "10",
        "C": "9.",
        "D": "에러"
      },
      "correctAnswer": "C"
    },
    {
      "id": "m7",
      "type": "mcq",
      "question": "자바에서 배열의 길이를 반환하는 프로퍼티는?",
      "options": {
        "A": "count",
        "B": "size()",
        "C": "length",
        "D": "length()"
      },
      "correctAnswer": "C"
    },
    {
      "id": "m8",
      "type": "mcq",
      "question": "2차원 배열 선언 시 올바른 표현은?",
      "options": {
        "A": "int[][] arr = new int[3][4];",
        "B": "int[][] arr = new int[3];",
        "C": "int arr[][] = new int[3,4];",
        "D": "int[][] arr = new int[3][];"
      },
      "correctAnswer": "A"
    },
    {
      "id": "m9",
      "type": "mcq",
      "question": "자바에서 int형 변수의 기본값(인스턴스 변수 기준)은?",
      "options": {
        "A": "1",
        "B": "null",
        "C": "정의되지 않음",
        "D": "0"
      },
      "correctAnswer": "D"
    },
    {
      "id": "m10",
      "type": "mcq",
      "question": "자바에서 상수를 선언하는 올바른 방법은?",
      "options": {
        "A": "int CONSTANT = 10;",
        "B": "const int CONSTANT = 10;",
        "C": "final int CONSTANT = 10;",
        "D": "static int CONSTANT = 10;"
      },
      "correctAnswer": "C"
    },
    {
      "id": "m11",
      "type": "mcq",
      "question": "System.out.println((char)65)의 출력 결과는?",
      "options": {
        "A": "A",
        "B": "65",
        "C": "에러",
        "D": "a"
      },
      "correctAnswer": "A"
    },
    {
      "id": "m12",
      "type": "mcq",
      "question": "다음 중 유효하지 않은 변수명은?",
      "options": {
        "A": "_number",
        "B": "$number",
        "C": "number1",
        "D": "1number"
      },
      "correctAnswer": "D"
    },
    {
      "id": "m13",
      "type": "mcq",
      "question": "자바에서 int 변수의 크기는?",
      "options": {
        "A": "4바이트",
        "B": "2바이트",
        "C": "8바이트",
        "D": "플랫폼에 따라 다름"
      },
      "correctAnswer": "A"
    },
    {
      "id": "m14",
      "type": "mcq",
      "question": "double 변수의 크기는?",
      "options": {
        "A": "8바이트",
        "B": "4바이트",
        "C": "16바이트",
        "D": "플랫폼에 따라 다름"
      },
      "correctAnswer": "A"
    },
    {
      "id": "m15",
      "type": "mcq",
      "question": "자바에서 상수를 선언하는 올바른 방법은?",
      "options": {
        "A": "final int CONSTANT = 10;",
        "B": "const int CONSTANT = 10;",
        "C": "int CONSTANT = 10;",
        "D": "static int CONSTANT = 10;"
      },
      "correctAnswer": "A"
    },
    {
      "id": "m16",
      "type": "mcq",
      "question": "System.out.println(5 + 2 * 3)의 출력 결과는?",
      "options": {
        "A": "21",
        "B": "11",
        "C": "15",
        "D": "7"
      },
      "correctAnswer": "B"
    },
    {
      "id": "m17",
      "type": "mcq",
      "question": "다음 중 암시적 형변환의 예는?",
      "options": {
        "A": "int에서 double로",
        "B": "double에서 int로",
        "C": "float에서 int로",
        "D": "char에서 String으로"
      },
      "correctAnswer": "A"
    },
    {
      "id": "m18",
      "type": "mcq",
      "question": "(int)'A'의 결과는?",
      "options": {
        "A": "65",
        "B": "'A'",
        "C": "에러",
        "D": "0"
      },
      "correctAnswer": "A"
    },
    {
      "id": "m19",
      "type": "mcq",
      "question": "자바 배열에 관한 설명으로 옳은 것은?",
      "options": {
        "A": "배열은 고정 크기를 가진다.",
        "B": "배열은 동적 크기 조절이 가능하다.",
        "C": "배열은 Collections 프레임워크의 일부이다.",
        "D": "배열은 불변이다."
      },
      "correctAnswer": "A"
    },
    {
      "id": "m20",
      "type": "mcq",
      "question": "자바에서 배열을 초기화하는 올바른 방법은?",
      "options": {
        "A": "int[] arr = {1,2,3};",
        "B": "int arr[] = new int[]{1,2,3};",
        "C": "A와 B 모두",
        "D": "없음"
      },
      "correctAnswer": "C"
    },
    {
      "id": "m21",
      "type": "mcq",
      "question": "System.out.println(10/3)의 출력 결과는?",
      "options": {
        "A": "3",
        "B": "3.33",
        "C": "3.0",
        "D": "3.3333"
      },
      "correctAnswer": "A"
    },
    {
      "id": "m22",
      "type": "mcq",
      "question": "자바 형변환에 관한 설명 중 옳은 것은?",
      "options": {
        "A": "암시적 변환 시 데이터 손실이 발생할 수 있다.",
        "B": "명시적 변환은 항상 안전하다.",
        "C": "작은 타입에서 큰 타입으로의 변환은 암시적으로 이루어진다.",
        "D": "명시적 변환은 자동으로 이루어진다."
      },
      "correctAnswer": "C"
    },
    {
      "id": "m23",
      "type": "mcq",
      "question": "boolean 배열의 미초기화 요소의 기본값은?",
      "options": {
        "A": "false",
        "B": "true",
        "C": "0",
        "D": "null"
      },
      "correctAnswer": "A"
    },
    {
      "id": "m24",
      "type": "mcq",
      "question": "문자열을 정수로 변환하는 메서드는?",
      "options": {
        "A": "Integer.parseInt()",
        "B": "(int) string",
        "C": "String.toInt()",
        "D": "parseInt()"
      },
      "correctAnswer": "A"
    },
    {
      "id": "m25",
      "type": "mcq",
      "question": "'final' 키워드의 효과는 무엇인가?",
      "options": {
        "A": "초기화 후 값 변경 불가",
        "B": "상수가 된다",
        "C": "A와 B 모두",
        "D": "없음"
      },
      "correctAnswer": "C"
    },
    {
      "id": "m26",
      "type": "mcq",
      "question": "지역 변수에 대한 설명으로 틀린 것은?",
      "options": {
        "A": "자동 초기화된다.",
        "B": "메서드 내에서 선언된다.",
        "C": "스코프가 블록 단위이다.",
        "D": "스택 영역에 저장된다."
      },
      "correctAnswer": "A"
    },
    {
      "id": "m27",
      "type": "mcq",
      "question": "다음 코드의 결과는:\nint[] arr = new int[3];\nSystem.out.println(arr[1]);",
      "options": {
        "A": "0",
        "B": "null",
        "C": "undefined",
        "D": "에러"
      },
      "correctAnswer": "A"
    },
    {
      "id": "m28",
      "type": "mcq",
      "question": "System.out.println((int)3.9)의 출력 결과는?",
      "options": {
        "A": "3",
        "B": "4",
        "C": "3.9",
        "D": "에러"
      },
      "correctAnswer": "A"
    },
    {
      "id": "m29",
      "type": "mcq",
      "question": "3차원 배열 선언 시 올바른 구문은?",
      "options": {
        "A": "int[][][] arr = new int[2][3][4];",
        "B": "int arr[][][] = new int[2][3][4];",
        "C": "A와 B 모두",
        "D": "없음"
      },
      "correctAnswer": "C"
    },
    {
      "id": "m30",
      "type": "mcq",
      "question": "세 개의 문자열을 초기화하는 올바른 배열 선언은?",
      "options": {
        "A": "String[] arr = [\"a\", \"b\", \"c\"];",
        "B": "String[] arr = {\"a\", \"b\", \"c\"};",
        "C": "String arr[] = new String[\"a\",\"b\",\"c\"];",
        "D": "String arr = new String[]{\"a\", \"b\", \"c\"};"
      },
      "correctAnswer": "B"
    },
    {
      "id": "m31",
      "type": "mcq",
      "question": "정수를 0으로 나누면 발생하는 현상은?",
      "options": {
        "A": "ArithmeticException",
        "B": "Infinity",
        "C": "0",
        "D": "정의되지 않음"
      },
      "correctAnswer": "A"
    },
    {
      "id": "m32",
      "type": "mcq",
      "question": "Object에서 String으로의 형변환 올바른 구문은?",
      "options": {
        "A": "(String) obj",
        "B": "String(obj)",
        "C": "obj as String",
        "D": "cast(String, obj)"
      },
      "correctAnswer": "A"
    },
    {
      "id": "m33",
      "type": "mcq",
      "question": "자바에서 배열은 어느 영역에 할당되는가?",
      "options": {
        "A": "힙(heap)",
        "B": "스택(stack)",
        "C": "String Pool",
        "D": "Permanent Generation"
      },
      "correctAnswer": "A"
    },
    {
      "id": "m34",
      "type": "mcq",
      "question": "System.out.println(3 + \"5\")의 결과는?",
      "options": {
        "A": "8",
        "B": "35",
        "C": "에러",
        "D": "3 5"
      },
      "correctAnswer": "B"
    },
    {
      "id": "m35",
      "type": "mcq",
      "question": "자바 배열의 인덱스는 몇부터 시작하는가?",
      "options": {
        "A": "0",
        "B": "1",
        "C": "-1",
        "D": "임의의 수"
      },
      "correctAnswer": "A"
    },
    {
      "id": "m36",
      "type": "mcq",
      "question": "객체의 참조 비교에 사용되는 연산자는?",
      "options": {
        "A": "==",
        "B": "equals()",
        "C": "compareTo()",
        "D": "==="
      },
      "correctAnswer": "A"
    },
    {
      "id": "m37",
      "type": "mcq",
      "question": "'instanceof' 키워드의 역할은?",
      "options": {
        "A": "객체의 타입 검사",
        "B": "형변환 수행",
        "C": "객체 비교",
        "D": "클래스 반환"
      },
      "correctAnswer": "A"
    },
    {
      "id": "m38",
      "type": "mcq",
      "question": "자바의 타입 시스템에 대한 설명 중 옳은 것은?",
      "options": {
        "A": "정적 타입",
        "B": "동적 타입",
        "C": "정적과 동적 혼합",
        "D": "약한 타입"
      },
      "correctAnswer": "A"
    },
    {
      "id": "m39",
      "type": "mcq",
      "question": "System.out.println((double)5/2)의 출력 결과는?",
      "options": {
        "A": "2.5",
        "B": "2",
        "C": "2.0",
        "D": "3"
      },
      "correctAnswer": "A"
    },
    {
      "id": "m40",
      "type": "mcq",
      "question": "다차원 배열을 선언하는 올바른 방법은?",
      "options": {
        "A": "int[][] matrix = new int[3][4];",
        "B": "int matrix[][] = new int[3,4];",
        "C": "int matrix = new int[3][4];",
        "D": "int[] matrix = new int[3][4];"
      },
      "correctAnswer": "A"
    },
    {
      "id": "m41",
      "type": "mcq",
      "question": "다음 코드의 결과는:\nint[] a = {1,2,3};\nint[] b = a;\nb[0] = 10;\nSystem.out.println(a[0]);",
      "options": {
        "A": "10",
        "B": "1",
        "C": "0",
        "D": "에러"
      },
      "correctAnswer": "A"
    },
    {
      "id": "m42",
      "type": "mcq",
      "question": "다음 중 오토박싱의 예는?",
      "options": {
        "A": "Integer i = 5;",
        "B": "int i = new Integer(5);",
        "C": "Integer i = new Integer(5);",
        "D": "없음"
      },
      "correctAnswer": "A"
    },
    {
      "id": "m43",
      "type": "mcq",
      "question": "System.out.println(1 + 2 + \"3\")의 출력 결과는?",
      "options": {
        "A": "33",
        "B": "123",
        "C": "6 3",
        "D": "3 3"
      },
      "correctAnswer": "A"
    },
    {
      "id": "m44",
      "type": "mcq",
      "question": "자바에서 변수 섀도잉(shadowing)에 대한 올바른 설명은?",
      "options": {
        "A": "지역변수가 인스턴스 변수를 가릴 수 있다.",
        "B": "인스턴스 변수가 지역변수를 가린다.",
        "C": "섀도잉은 허용되지 않는다.",
        "D": "컴파일 에러를 발생시킨다."
      },
      "correctAnswer": "A"
    },
    {
      "id": "m45",
      "type": "mcq",
      "question": "System.out.println('A' + 1)의 결과는?",
      "options": {
        "A": "66",
        "B": "'B'",
        "C": "에러",
        "D": "65"
      },
      "correctAnswer": "A"
    },
    {
      "id": "m46",
      "type": "mcq",
      "question": "다음 중 자바의 기본 자료형이 아닌 것은?",
      "options": {
        "A": "String",
        "B": "int",
        "C": "double",
        "D": "boolean"
      },
      "correctAnswer": "A"
    },
    {
      "id": "m47",
      "type": "mcq",
      "question": "다음 코드의 출력 결과는:\nint a = 10;\na += 5;\nSystem.out.println(a);",
      "options": {
        "A": "15",
        "B": "10",
        "C": "5",
        "D": "105"
      },
      "correctAnswer": "A"
    },
    {
      "id": "m48",
      "type": "mcq",
      "question": "큰 타입을 작은 타입으로 캐스팅할 때 주의할 점은?",
      "options": {
        "A": "정밀도 손실이 발생할 수 있다.",
        "B": "항상 안전하다.",
        "C": "값이 그대로 유지된다.",
        "D": "불가능하다."
      },
      "correctAnswer": "A"
    },
    {
      "id": "m49",
      "type": "mcq",
      "question": "메소드 오버라이딩을 방지하는 키워드는?",
      "options": {
        "A": "final",
        "B": "static",
        "C": "private",
        "D": "abstract"
      },
      "correctAnswer": "A"
    },
    {
      "id": "m50",
      "type": "mcq",
      "question": "System.out.println(3 * (2 + 4))의 출력 결과는?",
      "options": {
        "A": "18",
        "B": "20",
        "C": "24",
        "D": "12"
      },
      "correctAnswer": "A"
    },
    {
      "id": "c1",
      "type": "code",
      "question": "길이가 10인 int형 배열을 선언하는 코드를 완성하세요.",
      "codeSnippet": "int[] arr = new int[__];",
      "answers": ["10"]
    },
    {
      "id": "c2",
      "type": "code",
      "question": "double형 변수 d를 int형으로 명시적 형변환하여 변수 i에 저장하는 코드를 완성하세요.",
      "codeSnippet": "int i = (__d);",
      "answers": ["(int)"]
    },
    {
      "id": "c3",
      "type": "code",
      "question": "배열 arr의 길이를 출력하는 코드를 완성하세요.",
      "codeSnippet": "System.out.println(arr.__);",
      "answers": ["length"]
    },
    {
      "id": "c4",
      "type": "code",
      "question": "문자열 \"hello\"를 저장하는 변수를 선언하는 코드를 완성하세요.",
      "codeSnippet": "String s = __(\"hello\");",
      "answers": ["new String"]
    },
    {
      "id": "c5",
      "type": "code",
      "question": "int형 배열 nums의 첫 번째 요소에 100을 대입하는 코드를 완성하세요.",
      "codeSnippet": "nums[__] = 100;",
      "answers": ["0"]
    },
    {
      "id": "c6",
      "type": "code",
      "question": "3행 4열의 int형 2차원 배열을 선언하는 코드를 완성하세요.",
      "codeSnippet": "int[][] matrix = new int[__][__];",
      "answers": ["3", "4"]
    },
    {
      "id": "c7",
      "type": "code",
      "question": "정수형 배열 arr의 두 번째 요소에 접근하는 코드를 완성하세요.",
      "codeSnippet": "int x = arr[__];",
      "answers": ["1"]
    },
    {
      "id": "c8",
      "type": "code",
      "question": "문자열 s를 정수로 변환하는 코드를 완성하세요.",
      "codeSnippet": "int num = __(s);",
      "answers": ["Integer.parseInt"]
    },
    {
      "id": "c9",
      "type": "code",
      "question": "값 3.14를 가진 상수 PI를 선언하는 코드를 완성하세요.",
      "codeSnippet": "final double PI = __;",
      "answers": ["3.14"]
    },
    {
      "id": "c10",
      "type": "code",
      "question": "정수 변수 count를 0으로 초기화하는 코드를 완성하세요.",
      "codeSnippet": "int count = __;",
      "answers": ["0"]
    },
    {
      "id": "c11",
      "type": "code",
      "question": "정수 변수 i를 1 증가시키는 코드를 완성하세요.",
      "codeSnippet": "i__;",
      "answers": ["++"]
    },
    {
      "id": "c12",
      "type": "code",
      "question": "문자 'A'를 값으로 갖는 char 변수를 선언하는 코드를 완성하세요.",
      "codeSnippet": "char ch = __;",
      "answers": ["'A'"]
    },
    {
      "id": "c13",
      "type": "code",
      "question": "boolean 변수 flag를 true로 선언하는 코드를 완성하세요.",
      "codeSnippet": "boolean flag = __;",
      "answers": ["true"]
    },
    {
      "id": "c14",
      "type": "code",
      "question": "float형 변수 f를 int형으로 명시적 형변환하는 코드를 완성하세요.",
      "codeSnippet": "int num = (__f);",
      "answers": ["(int)"]
    },
    {
      "id": "c15",
      "type": "code",
      "question": "new 연산자를 사용하여 \"hello\"를 값으로 갖는 String 객체를 생성하는 코드를 완성하세요.",
      "codeSnippet": "String s = ____;",
      "answers": ["new", "String(\"hello\")"]
    },
    {
      "id": "c16",
      "type": "code",
      "question": "문자열 변수 a와 b를 연결하는 코드를 완성하세요.",
      "codeSnippet": "String result = a __ b;",
      "answers": ["+"]
    },
    {
      "id": "c17",
      "type": "code",
      "question": "두 문자열 s1과 s2의 동등 비교를 수행하는 코드를 완성하세요.",
      "codeSnippet": "boolean eq = s1.__(s2);",
      "answers": ["equals"]
    },
    {
      "id": "c18",
      "type": "code",
      "question": "값 5.5를 가진 double형 변수 d를 선언하는 코드를 완성하세요.",
      "codeSnippet": "double d = __;",
      "answers": ["5.5"]
    },
    {
      "id": "c19",
      "type": "code",
      "question": "int형 배열 arr의 두 번째 요소를 변수 x에 저장하는 코드를 완성하세요.",
      "codeSnippet": "int x = arr[__];",
      "answers": ["1"]
    },
    {
      "id": "c20",
      "type": "code",
      "question": "크기 5인 int형 배열 nums를 생성하는 코드를 완성하세요.",
      "codeSnippet": "int[] nums = new int[__];",
      "answers": ["5"]
    },
    {
      "id": "c21",
      "type": "code",
      "question": "2행 3열의 int형 다차원 배열을 선언하는 코드를 완성하세요.",
      "codeSnippet": "int[][] matrix = new int[__][__];",
      "answers": ["2", "3"]
    },
    {
      "id": "c22",
      "type": "code",
      "question": "문자열 str의 첫 번째 문자를 반환하는 코드를 완성하세요.",
      "codeSnippet": "char firstChar = str.__(0);",
      "answers": ["charAt"]
    },
    {
      "id": "c23",
      "type": "code",
      "question": "정수 n을 문자열로 변환하는 코드를 완성하세요.",
      "codeSnippet": "String s = Integer.__(n);",
      "answers": ["toString"]
    },
    {
      "id": "c24",
      "type": "code",
      "question": "StringBuilder를 사용하여 문자열 a와 b를 연결하는 코드를 완성하세요.",
      "codeSnippet": "StringBuilder sb = new StringBuilder(); sb.__(a).append(b);",
      "answers": ["append"]
    },
    {
      "id": "c25",
      "type": "code",
      "question": "크기 3인 boolean형 배열을 선언하는 코드를 완성하세요.",
      "codeSnippet": "boolean[] flags = new boolean[__];",
      "answers": ["3"]
    },
    {
      "id": "s1",
      "type": "subjective",
      "question": "자바에서 변수 타입 선언이 메모리 할당에 미치는 영향을 설명하시오.",
      "correctAnswer": "변수의 타입은 저장되는 데이터의 크기와 형태를 결정하며, 이에 따라 필요한 메모리 공간이 할당된다."
    },
    {
      "id": "s2",
      "type": "subjective",
      "question": "명시적 형변환이 필요한 이유와 예제를 설명하시오.",
      "correctAnswer": "명시적 형변환은 데이터 손실의 가능성이 있는 변환 시 개발자가 의도적으로 변환하도록 하여 예기치 않은 결과를 방지하기 위함이다. 예를 들어, double을 int로 변환할 때 사용된다."
    },
    {
      "id": "s3",
      "type": "subjective",
      "question": "객체와 기본 자료형의 메모리 저장 방식 차이를 설명하시오.",
      "correctAnswer": "기본 자료형은 스택에 직접 저장되고, 객체는 힙에 저장되며 참조를 통해 접근된다."
    },
    {
      "id": "s4",
      "type": "subjective",
      "question": "오토박싱(autoboxing)의 개념과 장점을 설명하시오.",
      "correctAnswer": "오토박싱은 기본형 데이터를 자동으로 해당하는 래퍼 객체로 변환하여, 코드의 간결성과 컬렉션 사용의 편리함을 제공한다."
    },
    {
      "id": "s5",
      "type": "subjective",
      "question": "배열의 고정 크기가 가지는 한계와 이를 극복하기 위한 자료구조를 설명하시오.",
      "correctAnswer": "배열은 한 번 선언하면 크기를 변경할 수 없기 때문에 동적 데이터 처리에 한계가 있으며, 이를 극복하기 위해 ArrayList와 같은 동적 자료구조를 사용한다."
    },
    {
      "id": "s6",
      "type": "subjective",
      "question": "자바에서 배열이 힙 영역에 저장되는 이유와 그 장점을 설명하시오.",
      "correctAnswer": "배열이 힙에 저장되면 동적 메모리 할당과 가비지 컬렉션의 혜택을 받아, 프로그램의 메모리 관리가 효율적이다."
    },
    {
      "id": "s7",
      "type": "subjective",
      "question": "'final' 키워드가 변수에 미치는 영향에 대해 설명하시오.",
      "correctAnswer": "final 키워드를 사용하면 변수의 값을 한 번 초기화한 후 변경할 수 없게 되어, 상수로 사용된다."
    },
    {
      "id": "s8",
      "type": "subjective",
      "question": "자바에서 암시적 형변환이 이루어지는 상황과 그 이유를 설명하시오.",
      "correctAnswer": "암시적 형변환은 작은 데이터 타입을 큰 데이터 타입으로 자동 변환할 때 발생하며, 데이터 손실 없이 안전하게 변환할 수 있기 때문이다."
    },
    {
      "id": "s9",
      "type": "subjective",
      "question": "정수와 실수의 나눗셈 결과가 다른 이유에 대해 설명하시오.",
      "correctAnswer": "정수끼리의 나눗셈은 정수 결과만 반환하고 소수점 이하를 버리지만, 실수 연산은 소수점 이하까지 계산한다."
    },
    {
      "id": "s10",
      "type": "subjective",
      "question": "얕은 복사(shallow copy)와 깊은 복사(deep copy)의 차이를 설명하시오.",
      "correctAnswer": "얕은 복사는 객체의 참조만 복사하여 같은 객체를 공유하고, 깊은 복사는 객체 내부의 데이터를 모두 복사하여 독립적인 객체를 생성한다."
    },
    {
      "id": "s11",
      "type": "subjective",
      "question": "변수의 스코프(scope)가 프로그램에 미치는 영향을 논하시오.",
      "correctAnswer": "변수의 스코프는 해당 변수가 유효한 범위를 결정하며, 메모리 사용과 네임스페이스 충돌을 관리하는 데 중요한 역할을 한다."
    },
    {
      "id": "s12",
      "type": "subjective",
      "question": "명시적 형변환 시 발생할 수 있는 문제점과 이를 방지하는 방법을 설명하시오.",
      "correctAnswer": "명시적 형변환은 데이터 손실이나 ClassCastException을 발생시킬 수 있으므로, 타입 확인과 범위 검사를 통해 주의해야 한다."
    },
    {
      "id": "s13",
      "type": "subjective",
      "question": "'=='와 'equals()'의 차이점을 논하시오.",
      "correctAnswer": "'=='는 객체의 참조(주소) 비교를 수행하고, equals()는 객체의 내용을 비교한다."
    },
    {
      "id": "s14",
      "type": "subjective",
      "question": "자바에서 String의 불변성이 왜 중요한지 설명하시오.",
      "correctAnswer": "String이 불변하면 여러 곳에서 안전하게 공유할 수 있고, 해시코드 캐싱 등 성능 최적화 및 보안 측면에서 이점을 제공한다."
    },
    {
      "id": "s15",
      "type": "subjective",
      "question": "자바의 가비지 컬렉션이 메모리 관리에 미치는 긍정적 효과에 대해 논하시오.",
      "correctAnswer": "가비지 컬렉션은 사용되지 않는 객체를 자동으로 회수하여 메모리 누수를 방지하고, 개발자가 메모리 해제에 신경쓰지 않아도 되게 한다."
    },
    {
      "id": "s16",
      "type": "subjective",
      "question": "배열의 인덱스가 0부터 시작하는 이유와 그 장점을 설명하시오.",
      "correctAnswer": "인덱스가 0부터 시작하면 주소 산술이 단순해지고, 메모리 오프셋 계산이 효율적으로 이루어진다."
    },
    {
      "id": "s17",
      "type": "subjective",
      "question": "자바에서 컴파일 시 타입 검사가 중요한 이유를 설명하시오.",
      "correctAnswer": "컴파일 시 타입 검사를 통해 잘못된 타입 사용을 사전에 방지하여 런타임 오류를 줄이고, 코드 안정성을 높인다."
    },
    {
      "id": "s18",
      "type": "subjective",
      "question": "문자열을 기본형으로 변환하는 과정에서 주의할 점에 대해 논하시오.",
      "correctAnswer": "문자열이 올바른 숫자 형식인지 확인하지 않으면 NumberFormatException이 발생할 수 있으므로, 사전 검증이 필요하다."
    },
    {
      "id": "s19",
      "type": "subjective",
      "question": "JVM이 변수와 배열의 메모리를 관리하는 방식을 설명하시오.",
      "correctAnswer": "JVM은 기본형은 스택에, 객체와 배열은 힙에 할당하며, 가비지 컬렉션을 통해 메모리를 자동 관리한다."
    },
    {
      "id": "s20",
      "type": "subjective",
      "question": "유효하지 않은 형변환 시 발생하는 예외와 그 처리 방법을 설명하시오.",
      "correctAnswer": "잘못된 형변환은 ClassCastException을 발생시키며, instanceof 연산자나 try-catch 구문으로 사전에 검사 및 처리가 필요하다."
    },
    {
      "id": "s21",
      "type": "subjective",
      "question": "자바에서 배열의 인덱스 범위 검사가 중요한 이유에 대해 설명하시오.",
      "correctAnswer": "인덱스 범위 검사를 통해 배열의 경계를 넘어선 접근을 막아 ArrayIndexOutOfBoundsException 등의 런타임 오류를 예방할 수 있다."
    },
    {
      "id": "s22",
      "type": "subjective",
      "question": "'static' 키워드가 변수에 미치는 영향에 대해 논하시오.",
      "correctAnswer": "static 변수는 클래스에 속해 모든 인스턴스가 공유되며, 객체 생성 없이 접근 가능해 메모리 사용 효율성을 높인다."
    },
    {
      "id": "s23",
      "type": "subjective",
      "question": "배열의 한계를 극복하기 위해 자바에서 제공하는 컬렉션 프레임워크의 장점을 설명하시오.",
      "correctAnswer": "컬렉션은 동적 크기 조절, 다양한 메서드, 제네릭 지원 등으로 배열의 고정 크기 한계를 극복할 수 있다."
    },
    {
      "id": "s24",
      "type": "subjective",
      "question": "얕은 비교와 깊은 비교의 차이를 배열 비교에 적용하여 설명하시오.",
      "correctAnswer": "얕은 비교는 배열 객체의 참조만 비교하고, 깊은 비교는 배열 내부 요소까지 비교하여 동일성을 판단한다."
    },
    {
      "id": "s25",
      "type": "subjective",
      "question": "혼합된 자료형의 산술 연산 시 자바가 수행하는 타입 변환 과정을 설명하시오.",
      "correctAnswer": "연산 시 피연산자들이 가장 큰 타입으로 자동 승격되어 연산되므로 정밀도가 보장된다."
    }
  ],
  "unit2": [
    {
      "id": "u2m1",
      "type": "mcq",
      "question": "자바의 객체지향 프로그래밍(OOP)의 4대 원칙 중 하나가 아닌 것은 무엇인가?",
      "options": {
        "A": "캡슐화",
        "B": "상속",
        "C": "다형성",
        "D": "함수형 프로그래밍"
      },
      "correctAnswer": "D"
    },
    {
      "id": "u2m2",
      "type": "mcq",
      "question": "클래스의 생성자는 반드시 클래스 이름과 동일해야 한다.",
      "options": {
        "A": "맞다",
        "B": "틀리다",
        "C": "경우에 따라 다르다",
        "D": "상속 시 변경된다"
      },
      "correctAnswer": "A"
    },
    {
      "id": "u2m3",
      "type": "mcq",
      "question": "생성자의 주요 역할은 무엇인가?",
      "options": {
        "A": "메모리 해제",
        "B": "객체 초기화",
        "C": "메서드 호출",
        "D": "변수 선언"
      },
      "correctAnswer": "B"
    },
    {
      "id": "u2m4",
      "type": "mcq",
      "question": "this 키워드의 용도는 무엇인가?",
      "options": {
        "A": "정적 메서드를 호출한다",
        "B": "부모 객체를 참조한다",
        "C": "현재 객체의 인스턴스를 참조한다",
        "D": "생성자를 호출한다"
      },
      "correctAnswer": "C"
    },
    {
      "id": "u2m5",
      "type": "mcq",
      "question": "생성자 오버로딩에 대해 올바른 설명은 무엇인가?",
      "options": {
        "A": "오버로딩된 생성자는 상속된다",
        "B": "생성자 오버로딩은 불가능하다",
        "C": "오버로딩된 생성자는 자동 호출된다",
        "D": "동일한 이름의 생성자를 매개변수로 구분하여 여러 개 정의할 수 있다"
      },
      "correctAnswer": "D"
    },
    {
      "id": "u2m6",
      "type": "mcq",
      "question": "메서드 오버로딩과 오버라이딩의 차이점은 무엇인가?",
      "options": {
        "A": "오버로딩은 같은 이름의 메서드를 매개변수로 구분하여 정의하는 것이고, 오버라이딩은 상속받은 메서드를 재정의하는 것이다",
        "B": "두 개념은 동일하다",
        "C": "오버로딩은 컴파일 타임 다형성, 오버라이딩은 런타임 다형성을 구현한다",
        "D": "A와 C 모두"
      },
      "correctAnswer": "D"
    },
    {
      "id": "u2m7",
      "type": "mcq",
      "question": "정적(static) 메서드는 객체 생성 없이 호출이 가능한가?",
      "options": {
        "A": "맞다",
        "B": "틀리다",
        "C": "객체 생성 후 호출해야 한다",
        "D": "추상 클래스에서만 가능하다"
      },
      "correctAnswer": "A"
    },
    {
      "id": "u2m8",
      "type": "mcq",
      "question": "메서드 오버라이딩 시, 부모 메서드의 접근제한자보다 좁은 접근제한자를 사용할 수 있는가?",
      "options": {
        "A": "가능하다",
        "B": "아니다",
        "C": "일부 경우 가능하다",
        "D": "컴파일러가 자동 조정한다"
      },
      "correctAnswer": "B"
    },
    {
      "id": "u2m9",
      "type": "mcq",
      "question": "생성자 내부에서 다른 생성자를 호출할 때 사용하는 키워드는 무엇인가?",
      "options": {
        "A": "new()",
        "B": "super()",
        "C": "this()",
        "D": "call()"
      },
      "correctAnswer": "C"
    },
    {
      "id": "u2m10",
      "type": "mcq",
      "question": "반환형이 void인 메서드는 값을 반환하는가?",
      "options": {
        "A": "빈 문자열을 반환한다",
        "B": "null을 반환한다",
        "C": "0을 반환한다",
        "D": "아무것도 반환하지 않는다"
      },
      "correctAnswer": "D"
    },
    {
      "id": "u2m11",
      "type": "mcq",
      "question": "객체지향 프로그래밍에서 캡슐화(encapsulation)의 의미는 무엇인가?",
      "options": {
        "A": "데이터를 보호하고 은닉하는 것이다",
        "B": "상속을 가능하게 하는 것이다",
        "C": "메서드 오버로딩이다",
        "D": "클래스의 확장이다"
      },
      "correctAnswer": "A"
    },
    {
      "id": "u2m12",
      "type": "mcq",
      "question": "메서드 오버라이딩 시, 부모 클래스의 메서드를 호출하기 위해 사용하는 키워드는 무엇인가?",
      "options": {
        "A": "this",
        "B": "super",
        "C": "parent",
        "D": "base"
      },
      "correctAnswer": "B"
    },
    {
      "id": "u2m13",
      "type": "mcq",
      "question": "자바의 생성자는 반환값을 가지는가?",
      "options": {
        "A": "null을 반환한다",
        "B": "0을 반환한다",
        "C": "아니다",
        "D": "컴파일러가 자동 생성한다"
      },
      "correctAnswer": "C"
    },
    {
      "id": "u2m14",
      "type": "mcq",
      "question": "생성자 내에서 다른 생성자를 호출할 때, 그 호출은 반드시 생성자의 첫 번째 문장에 작성되어야 한다.",
      "options": {
        "A": "무관하다",
        "B": "틀리다",
        "C": "상황에 따라 다르다",
        "D": "맞다"
      },
      "correctAnswer": "D"
    },
    {
      "id": "u2m15",
      "type": "mcq",
      "question": "메서드 오버로딩이 가능한 이유는 무엇인가?",
      "options": {
        "A": "매개변수의 타입이나 개수로 구분되기 때문",
        "B": "반환형으로 구분되기 때문",
        "C": "접근제한자로 구분되기 때문",
        "D": "예외 선언으로 구분된다"
      },
      "correctAnswer": "A"
    },
    {
      "id": "u2m16",
      "type": "mcq",
      "question": "객체 생성 시, 부모 클래스의 생성자가 먼저 호출되는 이유는 무엇인가?",
      "options": {
        "A": "객체 초기화를 위해서",
        "B": "메모리 할당을 위해서",
        "C": "자식 클래스의 생성자 호출 전에 반드시 실행되어야 하기 때문",
        "D": "접근제한자 때문"
      },
      "correctAnswer": "C"
    },
    {
      "id": "u2m17",
      "type": "mcq",
      "question": "자바에서 메서드 오버라이딩을 결정하는 메서드 시그니처는 무엇인가?",
      "options": {
        "A": "메서드 이름과 매개변수 목록",
        "B": "메서드 이름과 반환형",
        "C": "매개변수 목록과 반환형",
        "D": "메서드 이름과 예외 선언"
      },
      "correctAnswer": "A"
    },
    {
      "id": "u2m18",
      "type": "mcq",
      "question": "메서드 내에서 선언된 지역 변수의 유효 범위는 어디인가?",
      "options": {
        "A": "해당 메서드 내",
        "B": "클래스 전체",
        "C": "패키지 전체",
        "D": "전역 변수와 동일하다"
      },
      "correctAnswer": "A"
    },
    {
      "id": "u2m19",
      "type": "mcq",
      "question": "객체지향 프로그래밍에서 다형성이란 무엇을 의미하는가?",
      "options": {
        "A": "객체의 내부 구조 및 데이터를 캡슐처럼 감싸 외부에서 직접 볼 수 없게 은닉하여 보호하는 것",
        "B": "동일한 인터페이스로 다양한 구현을 제공하는 것",
        "C": "기존의 클래스를 재활용하여 새로운 클래스를 작성하는 자바의 문법 요소",
        "D": "객체의 공통적인 특성을 추출하여 인터페이스나 추상 클래스로 정의하는 것"
      },
      "correctAnswer": "B"
    },
    {
      "id": "u2m20",
      "type": "mcq",
      "question": "메서드 호출 시, 인자의 값은 어떤 방식으로 전달되는가?",
      "options": {
        "A": "전역 변수 사용",
        "B": "참조에 의한 전달",
        "C": "포인터 전달",
        "D": "값에 의한 전달"
      },
      "correctAnswer": "D"
    },
    {
      "id": "u2m21",
      "type": "mcq",
      "question": "생성자 오버로딩 시, 기본 생성자가 자동으로 생성되는 조건은 무엇인가?",
      "options": {
        "A": "상속 관계에 있을 때",
        "B": "항상 자동 생성된다",
        "C": "클래스에 다른 생성자가 없을 때",
        "D": "정적 생성자가 있을 때"
      },
      "correctAnswer": "C"
    },
    {
      "id": "u2m22",
      "type": "mcq",
      "question": "반환형이 void인 메서드는 어떤 값을 반환하는가?",
      "options": {
        "A": "false",
        "B": "null",
        "C": "0",
        "D": "아무것도 반환하지 않는다"
      },
      "correctAnswer": "D"
    },
    {
      "id": "u2m23",
      "type": "mcq",
      "question": "객체지향 프로그래밍에서 추상화(abstraction)의 의미는 무엇인가?",
      "options": {
        "A": "복잡한 시스템을 단순한 모델로 표현하는 것",
        "B": "데이터를 암호화하는 것",
        "C": "메서드 오버라이딩",
        "D": "상속을 의미한다"
      },
      "correctAnswer": "A"
    },
    {
      "id": "u2m24",
      "type": "mcq",
      "question": "메서드 호출 시, 여러 개의 매개변수를 구분하는 기준은 무엇인가?",
      "options": {
        "A": "반환형",
        "B": "매개변수의 개수와 타입",
        "C": "메서드 이름",
        "D": "접근제한자"
      },
      "correctAnswer": "B"
    },
    {
      "id": "u2m25",
      "type": "mcq",
      "question": "생성자 내에서 멤버 변수를 초기화할 때 this 키워드를 사용하는 이유는 무엇인가?",
      "options": {
        "A": "정적 변수를 호출하기 위함",
        "B": "부모 변수를 호출하기 위함",
        "C": "이름 충돌을 피하기 위함",
        "D": "메서드를 호출하기 위함"
      },
      "correctAnswer": "C"
    },
    {
      "id": "u2m26",
      "type": "mcq",
      "question": "상속이란 무엇을 의미하는가?",
      "options": {
        "A": "변수 복사",
        "B": "두 객체를 연결하는 것",
        "C": "메서드 오버로딩",
        "D": "기존 클래스로부터 새로운 클래스를 만드는 것"
      },
      "correctAnswer": "D"
    },
    {
      "id": "u2m27",
      "type": "mcq",
      "question": "자바에서 기본 생성자가 자동으로 생성되는 경우는 언제인가?",
      "options": {
        "A": "클래스에 생성자가 정의되어 있지 않을 때",
        "B": "클래스에 하나 이상의 생성자가 있을 때",
        "C": "항상",
        "D": "상속 관계에서만"
      },
      "correctAnswer": "A"
    },
    {
      "id": "u2m28",
      "type": "mcq",
      "question": "반환형이 void인 메서드의 특징은 무엇인가?",
      "options": {
        "A": "null을 반환하다",
        "B": "값을 반환하지 않는다",
        "C": "0을 반환한다",
        "D": "빈 문자열을 반환한다"
      },
      "correctAnswer": "B"
    },
    {
      "id": "u2m29",
      "type": "mcq",
      "question": "객체지향 프로그래밍에서 다형성을 구현하는 한 가지 방법은 무엇인가?",
      "options": {
        "A": "변수 재선언",
        "B": "생성자 오버로딩",
        "C": "메서드 오버로딩과 오버라이딩",
        "D": "인터페이스 사용"
      },
      "correctAnswer": "C"
    },
    {
      "id": "u2m30",
      "type": "mcq",
      "question": "객체 생성 시 부모 클래스의 생성자가 먼저 호출되는 이유는 무엇에 기반하는가?",
      "options": {
        "A": "접근제한자",
        "B": "객체 초기화",
        "C": "메모리 할당",
        "D": "클래스 상속 구조"
      },
      "correctAnswer": "D"
    },
    {
      "id": "u2m31",
      "type": "mcq",
      "question": "자바에서 메서드 시그니처에 포함되는 요소는 무엇인가?",
      "options": {
        "A": "메서드 이름과 매개변수 목록",
        "B": "반환형",
        "C": "접근제한자",
        "D": "예외 목록"
      },
      "correctAnswer": "A"
    },
    {
      "id": "u2m32",
      "type": "mcq",
      "question": "정적 메서드는 인스턴스 변수에 접근할 수 있는가?",
      "options": {
        "A": "가능하다",
        "B": "아니다",
        "C": "조건부로 가능하다",
        "D": "컴파일러가 결정한다"
      },
      "correctAnswer": "B"
    },
    {
      "id": "u2m33",
      "type": "mcq",
      "question": "객체지향 프로그래밍에서 캡슐화의 주요 목적은 무엇인가?",
      "options": {
        "A": "다형성 구현",
        "B": "코드 재사용",
        "C": "데이터 보호와 은닉",
        "D": "상속 촉진"
      },
      "correctAnswer": "C"
    },
    {
      "id": "u2m34",
      "type": "mcq",
      "question": "메서드 오버라이딩 시 부모 클래스의 메서드와 자식 클래스의 메서드 시그니처는 어떻게 되어야 하는가?",
      "options": {
        "A": "접근제한자만 동일하면 된다",
        "B": "반환형만 동일하면 된다",
        "C": "매개변수만 동일하면 된다",
        "D": "동일해야 한다"
      },
      "correctAnswer": "D"
    },
    {
      "id": "u2m35",
      "type": "mcq",
      "question": "자바에서 모든 클래스의 최상위 클래스는 무엇인가?",
      "options": {
        "A": "Object",
        "B": "Class",
        "C": "String",
        "D": "System"
      },
      "correctAnswer": "A"
    },
    {
      "id": "u2m36",
      "type": "mcq",
      "question": "객체 생성 시, 생성자가 호출되는 순서는 어떻게 결정되는가?",
      "options": {
        "A": "자식부터 호출된다",
        "B": "상속 구조에 따라 부모부터 호출된다",
        "C": "임의로 호출된다",
        "D": "동시에 호출된다"
      },
      "correctAnswer": "B"
    },
    {
      "id": "u2m37",
      "type": "mcq",
      "question": "this 키워드와 super 키워드의 차이는 무엇인가?",
      "options": {
        "A": "super는 정적 메서드를 호출한다",
        "B": "둘은 동일하다",
        "C": "this는 현재 객체, super는 부모 객체를 참조한다",
        "D": "this는 생성자에서만 사용된다"
      },
      "correctAnswer": "C"
    },
    {
      "id": "u2m38",
      "type": "mcq",
      "question": "메서드 오버로딩은 컴파일 타임 다형성의 한 예이다. 이 설명은 옳은가?",
      "options": {
        "A": "적용되지 않는다",
        "B": "틀리다",
        "C": "일부 경우 옳다",
        "D": "옳다"
      },
      "correctAnswer": "D"
    },
    {
      "id": "u2m39",
      "type": "mcq",
      "question": "생성자에서 멤버 변수를 초기화하는 또 다른 방법으로 올바른 것은 무엇인가?",
      "options": {
        "A": "초기화 블록을 사용하는 것",
        "B": "메서드 오버로딩을 사용하는 것",
        "C": "정적 메서드를 호출하는 것",
        "D": "super()를 호출하는 것"
      },
      "correctAnswer": "A"
    },
    {
      "id": "u2m40",
      "type": "mcq",
      "question": "여러 생성자 중 호출될 생성자는 어떻게 결정되는가?",
      "options": {
        "A": "항상 기본 생성자가 호출된다",
        "B": "인자의 개수와 타입에 따라 결정된다",
        "C": "임의로 결정된다",
        "D": "마지막에 정의된 생성자가 호출된다"
      },
      "correctAnswer": "B"
    },
    {
      "id": "u2m41",
      "type": "mcq",
      "question": "자바에서 메서드의 파라미터 전달 방식은 무엇인가?",
      "options": {
        "A": "포인터 전달",
        "B": "참조에 의한 전달",
        "C": "값에 의한 전달",
        "D": "복사 전달"
      },
      "correctAnswer": "C"
    },
    {
      "id": "u2m42",
      "type": "mcq",
      "question": "객체지향 프로그래밍에서 캡슐화의 개념은 무엇을 의미하는가?",
      "options": {
        "A": "다형성 구현",
        "B": "상속을 통한 코드 재사용",
        "C": "메서드 오버로딩",
        "D": "데이터와 메서드를 하나의 객체로 묶는 것"
      },
      "correctAnswer": "D"
    },
    {
      "id": "u2m43",
      "type": "mcq",
      "question": "메서드 오버라이딩 시, 부모 클래스의 메서드를 재정의할 때 반드시 포함되어야 하는 것은 무엇인가?",
      "options": {
        "A": "메서드 이름과 매개변수 목록",
        "B": "반환형",
        "C": "접근제한자",
        "D": "예외 선언"
      },
      "correctAnswer": "A"
    },
    {
      "id": "u2m44",
      "type": "mcq",
      "question": "정적 메서드에서 인스턴스 변수에 접근할 수 없는 이유는 무엇인가?",
      "options": {
        "A": "인스턴스 변수가 private이기 때문",
        "B": "정적 메서드는 객체와 무관하기 때문",
        "C": "메모리 부족",
        "D": "컴파일러 오류 때문이다"
      },
      "correctAnswer": "B"
    },
    {
      "id": "u2m45",
      "type": "mcq",
      "question": "생성자와 메서드의 차이점은 무엇인가?",
      "options": {
        "A": "생성자는 반환값이 있다",
        "B": "둘은 동일하다",
        "C": "생성자는 객체 초기화, 메서드는 기능 수행",
        "D": "메서드는 클래스 이름과 동일하다"
      },
      "correctAnswer": "C"
    },
    {
      "id": "u2m46",
      "type": "mcq",
      "question": "메서드 오버로딩 시, 매개변수의 순서도 중요한 구분 요소에 포함되는가?",
      "options": {
        "A": "접근제한자에 따라 다르다",
        "B": "아니다",
        "C": "반환형에 따라 다르다",
        "D": "예, 순서도 구분된다"
      },
      "correctAnswer": "D"
    },
    {
      "id": "u2m47",
      "type": "mcq",
      "question": "자바에서 생성자와 일반 메서드는 어떻게 구분되는가?",
      "options": {
        "A": "생성자는 클래스 이름과 동일하며 반환형이 없다",
        "B": "둘은 구분되지 않는다",
        "C": "생성자는 static이다",
        "D": "메서드는 항상 void이다"
      },
      "correctAnswer": "A"
    },
    {
      "id": "u2m48",
      "type": "mcq",
      "question": "객체지향 프로그래밍에서 상속의 주요 이점은 무엇인가?",
      "options": {
        "A": "메모리 절약",
        "B": "코드 재사용과 확장",
        "C": "성능 향상",
        "D": "보안 강화"
      },
      "correctAnswer": "B"
    },
    {
      "id": "u2m49",
      "type": "mcq",
      "question": "자바에서 모든 클래스의 최상위 클래스는 무엇인가?",
      "options": {
        "A": "String",
        "B": "Class",
        "C": "Object",
        "D": "System"
      },
      "correctAnswer": "C"
    },
    {
      "id": "u2m50",
      "type": "mcq",
      "question": "메서드 오버라이딩 시, 자식 클래스의 메서드 반환형은 부모 클래스의 메서드 반환형과 어떻게 되어야 하는가?",
      "options": {
        "A": "공변 반환형을 사용할 수 있다",
        "B": "반드시 동일해야 한다",
        "C": "전혀 상관없다",
        "D": "자식 메서드가 더 넓어야 한다"
      },
      "correctAnswer": "A"
    },
    {
      "id": "q1",
      "type": "code",
      "question": "매개변수가 없는 생성자를 사용하여 MyClass 객체를 생성하는 코드를 완성하시오.",
      "codeSnippet": "MyClass obj = new __();",
      "answers": ["MyClass"]
    },
    {
      "id": "q2",
      "type": "code",
      "question": "두 개의 정수 매개변수를 받아 인스턴스 변수 a와 b를 초기화하는 생성자를 정의하는 코드를 완성하시오.",
      "codeSnippet": "public MyClass(__ a, __ b) { this.a = a; this.b = b; }",
      "answers": ["int", "int"]
    },
    {
      "id": "q3",
      "type": "code",
      "question": "매개변수 value를 인스턴스 변수 value에 대입할 때, this 키워드를 사용하여 코드를 완성하시오.",
      "codeSnippet": "public void setValue(int value) { __ = value; }",
      "answers": ["this.value"]
    },
    {
      "id": "q4",
      "type": "code",
      "question": "기본 생성자에서 매개변수가 하나인 생성자를 호출하는 생성자 체이닝 코드를 완성하시오. (기본 값은 0)",
      "codeSnippet": "public MyClass() { __(0); }",
      "answers": ["this"]
    },
    {
      "id": "q5",
      "type": "code",
      "question": "클래스 내부에서 올바른 생성자 이름을 사용하여 MyClass의 생성자를 선언하는 코드를 완성하시오.",
      "codeSnippet": "class MyClass { public __() { } }",
      "answers": ["MyClass"]
    },
    {
      "id": "q6",
      "type": "code",
      "question": "콘솔에 \"Hello\"를 출력하고 반환값이 없는 메서드 display를 선언하는 코드를 완성하시오.",
      "codeSnippet": "public __ display() { System.out.println(\"Hello\"); }",
      "answers": ["void"]
    },
    {
      "id": "q7",
      "type": "code",
      "question": "정수 매개변수 하나를 받는 compute 메서드를 선언할 때, 매개변수의 자료형을 완성하시오.",
      "codeSnippet": "public void compute(__ a) { }",
      "answers": ["int"]
    },
    {
      "id": "q8",
      "type": "code",
      "question": "매개변수 a를 인스턴스 변수 a에 대입할 때 this 키워드를 사용하여 코드를 완성하시오.",
      "codeSnippet": "public void setA(int a) { __ = a; }",
      "answers": ["this.a"]
    },
    {
      "id": "q9",
      "type": "code",
      "question": "정수 매개변수를 받는 생성자 내부에서 다른 생성자(두 개의 매개변수를 받는)를 호출하여 a와 0으로 초기화하는 코드를 완성하시오.",
      "codeSnippet": "public MyClass(int a) { __(a, 0); }",
      "answers": ["this"]
    },
    {
      "id": "q10",
      "type": "code",
      "question": "인스턴스 변수 a의 값을 반환하는 getter 메서드 getA를 완성하시오.",
      "codeSnippet": "public int getA() { return __; }",
      "answers": ["a"]
    },
    {
      "id": "q11",
      "type": "code",
      "question": "정적 메서드 main 내부에서 클래스 이름을 사용하여 정적 메서드 method를 호출하는 코드를 완성하시오.",
      "codeSnippet": "public static void main(String[] args) { __.method(); }",
      "answers": ["MyClass"]
    },
    {
      "id": "q12",
      "type": "code",
      "question": "클래스 변수 count에 접근하기 위해 클래스 이름을 사용하여 값을 출력하는 코드를 완성하시오.",
      "codeSnippet": "System.out.println(__.count);",
      "answers": ["MyClass"]
    },
    {
      "id": "q13",
      "type": "code",
      "question": "정수를 출력하는 print 메서드를 선언할 때, 매개변수의 자료형을 완성하시오.",
      "codeSnippet": "public void print(__ x) { System.out.println(x); }",
      "answers": ["int"]
    },
    {
      "id": "q14",
      "type": "code",
      "question": "기본 생성자에서 다른 생성자를 호출하는 생성자 체이닝 예제를 완성하시오.",
      "codeSnippet": "public MyClass() { __(); }",
      "answers": ["this"]
    },
    {
      "id": "q15",
      "type": "code",
      "question": "MyClass 객체를 10개 담을 수 있는 배열을 선언하는 코드를 완성하시오.",
      "codeSnippet": "MyClass[] arr = new MyClass[__];",
      "answers": ["10"]
    },
    {
      "id": "q16",
      "type": "code",
      "question": "인스턴스 변수 value를 반환하는 getter 메서드 getValue를 완성하시오.",
      "codeSnippet": "public __ getValue() { return value; }",
      "answers": ["int"]
    },
    {
      "id": "q17",
      "type": "code",
      "question": "정적 팩토리 메서드 getInstance를 선언할 때, 반환형을 올바르게 지정하여 코드를 완성하시오.",
      "codeSnippet": "public static __ getInstance() { return instance; }",
      "answers": ["MyClass"]
    },
    {
      "id": "q18",
      "type": "code",
      "question": "this 키워드를 사용하여 인스턴스 변수 value에 100을 대입하는 코드를 완성하시오.",
      "codeSnippet": "this.__ = 100;",
      "answers": ["value"]
    },
    {
      "id": "q19",
      "type": "code",
      "question": "객체 obj의 display 메서드를 호출하는 코드를 완성하시오.",
      "codeSnippet": "obj.__();",
      "answers": ["display"]
    },
    {
      "id": "q20",
      "type": "code",
      "question": "문자열 인스턴스 변수 name을 반환하는 getName 메서드를 완성하시오.",
      "codeSnippet": "public String getName() { return __; }",
      "answers": ["name"]
    },
    {
      "id": "q21",
      "type": "code",
      "question": "생성자 내부에서 매개변수 a를 인스턴스 변수 a에 대입할 때, 모호성을 해결하기 위해 올바른 키워드를 사용하여 코드를 완성하시오.",
      "codeSnippet": "public MyClass(int a) { __ = a; }",
      "answers": ["this.a"]
    },
    {
      "id": "q22",
      "type": "code",
      "question": "메서드 오버로딩의 예제로, 하나는 정수 하나를 받고 다른 하나는 정수 두 개를 받는 compute 메서드를 선언할 때, 두 번째 메서드의 매개변수 자료형을 완성하시오.",
      "codeSnippet": "public void compute(int a) { } public void compute(__ a, __ b) { }",
      "answers": ["int", "int"]
    },
    {
      "id": "q23",
      "type": "code",
      "question": "매개변수 value를 인스턴스 변수 value에 대입할 때, this 키워드를 사용하여 코드를 완성하시오.",
      "codeSnippet": "public void setValue(int value) { __ = value; }",
      "answers": ["this.value"]
    },
    {
      "id": "q24",
      "type": "code",
      "question": "정수 매개변수 5를 전달하여 MyClass 객체를 생성하는 코드를 완성하시오.",
      "codeSnippet": "MyClass obj = new __(5);",
      "answers": ["MyClass"]
    },
    {
      "id": "q25",
      "type": "code",
      "question": "인스턴스 변수 result를 반환하는 getResult 메서드를 완성하시오.",
      "codeSnippet": "public __ getResult() { return result; }",
      "answers": ["int"]
    },
    {
      "id": "u2s1",
      "type": "subjective",
      "question": "객체지향 프로그래밍의 4대 원칙(캡슐화, 상속, 다형성, 추상화)에 대해 설명하시오.",
      "correctAnswer": "객체지향 프로그래밍은 캡슐화, 상속, 다형성, 추상화의 네 가지 원칙을 기반으로 하며, 이를 통해 복잡한 시스템을 단순화하고 재사용성을 높인다."
    },
    {
      "id": "u2s2",
      "type": "subjective",
      "question": "생성자의 역할과 필요성에 대해 서술하시오.",
      "correctAnswer": "생성자는 객체가 생성될 때 멤버 변수를 초기화하고, 필요한 초기 설정을 수행하는 특별한 메서드로, 객체의 상태를 올바르게 구성하는 데 필요하다."
    },
    {
      "id": "u2s3",
      "type": "subjective",
      "question": "this 키워드의 역할과 사용법에 대해 설명하시오.",
      "correctAnswer": "this 키워드는 현재 객체의 인스턴스를 참조하는 데 사용되며, 주로 매개변수와 멤버 변수의 이름이 충돌할 때 구분하여 사용한다."
    },
    {
      "id": "u2s4",
      "type": "subjective",
      "question": "메서드 오버로딩과 오버라이딩의 차이에 대해 서술하시오.",
      "correctAnswer": "오버로딩은 같은 이름의 메서드를 매개변수로 구분하여 여러 개 정의하는 것이며, 오버라이딩은 상속받은 메서드를 자식 클래스에서 재정의하는 것이다."
    },
    {
      "id": "u2s5",
      "type": "subjective",
      "question": "생성자 체이닝(this() 호출)의 장단점에 대해 설명하시오.",
      "correctAnswer": "생성자 체이닝은 중복 코드를 줄여 초기화를 일관되게 관리할 수 있지만, 코드 가독성이 떨어질 수 있다는 단점이 있다."
    },
    {
      "id": "u2s6",
      "type": "subjective",
      "question": "정적 메서드와 인스턴스 메서드의 차이점에 대해 설명하시오.",
      "correctAnswer": "정적 메서드는 객체 생성 없이 클래스 이름으로 호출되며, 인스턴스 메서드는 객체의 상태에 의존하여 동작한다."
    },
    {
      "id": "u2s7",
      "type": "subjective",
      "question": "객체 생성 시 메모리 할당 과정에 대해 설명하시오.",
      "correctAnswer": "객체는 new 연산자를 통해 힙 영역에 생성되며, 생성자에 의해 초기화된다. 이후 가비지 컬렉션에 의해 관리된다."
    },
    {
      "id": "u2s8",
      "type": "subjective",
      "question": "메서드 오버라이딩 시 접근제한자 규칙에 대해 설명하시오.",
      "correctAnswer": "오버라이딩된 메서드는 부모 메서드의 접근제한자보다 좁은 접근제한자를 사용할 수 없으며, 보통 부모와 동일하거나 더 넓은 범위로 선언되어야 한다."
    },
    {
      "id": "u2s9",
      "type": "subjective",
      "question": "캡슐화의 개념과 그 장점에 대해 서술하시오.",
      "correctAnswer": "캡슐화는 데이터와 메서드를 하나의 객체로 묶어 외부로부터 데이터를 보호하고, 인터페이스를 통해 접근하도록 하여 유지보수와 보안 측면에서 유리하다."
    },
    {
      "id": "u2s10",
      "type": "subjective",
      "question": "상속이 객체지향 프로그래밍에서 중요한 이유는 무엇인지 설명하시오.",
      "correctAnswer": "상속은 기존 클래스의 기능을 재사용하고 확장할 수 있게 하여 코드의 중복을 줄이고, 유지보수를 쉽게 한다."
    },
    {
      "id": "u2s11",
      "type": "subjective",
      "question": "다형성의 개념과 이를 활용한 예제에 대해 설명하시오.",
      "correctAnswer": "다형성은 동일한 인터페이스를 사용해 여러 형태의 객체가 서로 다른 동작을 할 수 있도록 하는 개념으로, 예를 들어 부모 타입의 참조변수로 자식 객체들을 다루는 경우를 들 수 있다."
    },
    {
      "id": "u2s12",
      "type": "subjective",
      "question": "생성자와 일반 메서드의 차이점에 대해 설명하시오.",
      "correctAnswer": "생성자는 객체 생성 시 초기화를 담당하며 반환형이 없고, 일반 메서드는 객체의 기능을 수행하며 반환형을 가진다."
    },
    {
      "id": "u2s13",
      "type": "subjective",
      "question": "자바에서 생성자 오버로딩이 가능한 이유에 대해 서술하시오.",
      "correctAnswer": "생성자 오버로딩은 매개변수의 개수와 타입에 따라 서로 다른 생성자를 정의할 수 있어, 다양한 방식으로 객체를 초기화할 수 있게 해준다."
    },
    {
      "id": "u2s14",
      "type": "subjective",
      "question": "객체지향 설계 원칙 중 SOLID 원칙 중 하나를 선택하여 간략히 설명하시오.",
      "correctAnswer": "예를 들어, 단일 책임 원칙(Single Responsibility Principle)은 클래스가 하나의 책임만 가져야 한다는 원칙으로, 이를 통해 코드의 유지보수성과 재사용성을 높일 수 있다."
    },
    {
      "id": "u2s15",
      "type": "subjective",
      "question": "메서드 내에서 지역 변수와 인스턴스 변수의 차이에 대해 설명하시오.",
      "correctAnswer": "지역 변수는 메서드 내부에서 선언되어 그 메서드 내에서만 유효하고, 인스턴스 변수는 클래스의 각 객체에 속하며 객체 전체에서 사용된다."
    },
    {
      "id": "u2s16",
      "type": "subjective",
      "question": "this 키워드를 사용함으로써 얻는 이점에 대해 논하시오.",
      "correctAnswer": "this 키워드는 현재 객체를 명확하게 참조함으로써, 매개변수와 멤버 변수의 이름 충돌을 방지하고 객체의 상태를 올바르게 다룰 수 있게 해준다."
    },
    {
      "id": "u2s17",
      "type": "subjective",
      "question": "생성자 내부에서 다른 생성자를 호출하는 이유와 그 장점을 설명하시오.",
      "correctAnswer": "생성자 체이닝을 통해 중복되는 초기화 코드를 줄이고, 여러 생성자 간의 일관성을 유지할 수 있다."
    },
    {
      "id": "u2s18",
      "type": "subjective",
      "question": "재귀 호출(recursion)의 개념과 활용에 대해 설명하시오.",
      "correctAnswer": "재귀 호출은 메서드가 자기 자신을 호출하는 것으로, 문제를 작은 단위로 분할하여 해결하는 데 유용하지만, 종료 조건이 반드시 필요하다."
    },
    {
      "id": "u2s19",
      "type": "subjective",
      "question": "메서드 오버로딩이 컴파일 타임 다형성에 미치는 영향을 설명하시오.",
      "correctAnswer": "메서드 오버로딩은 컴파일러가 호출할 메서드를 결정하므로, 컴파일 타임 다형성을 구현하는 한 방법이다."
    },
    {
      "id": "u2s20",
      "type": "subjective",
      "question": "객체지향 프로그래밍에서 추상화의 중요성에 대해 서술하시오.",
      "correctAnswer": "추상화는 복잡한 시스템을 단순화하여 핵심 개념에 집중할 수 있게 하며, 코드의 이해와 유지보수를 용이하게 한다."
    },
    {
      "id": "u2s21",
      "type": "subjective",
      "question": "메서드 오버라이딩을 사용할 때 주의해야 할 사항은 무엇인지 설명하시오.",
      "correctAnswer": "부모 클래스의 메서드와 동일한 시그니처를 유지해야 하며, 접근제한자 및 예외 선언에도 주의를 기울여야 한다."
    },
    {
      "id": "u2s22",
      "type": "subjective",
      "question": "정적 메서드와 인스턴스 메서드의 용도 차이에 대해 논하시오.",
      "correctAnswer": "정적 메서드는 객체 생성 없이 클래스 수준에서 사용되며, 인스턴스 메서드는 각 객체의 상태에 따라 동작한다."
    },
    {
      "id": "u2s23",
      "type": "subjective",
      "question": "객체 생성 시 생성자 호출 순서가 중요한 이유에 대해 설명하시오.",
      "correctAnswer": "부모 클래스의 생성자가 먼저 호출되어 기본적인 초기화가 이루어진 후 자식 클래스의 생성자가 호출되므로, 상속 관계에 따른 초기화 순서를 보장한다."
    },
    {
      "id": "u2s24",
      "type": "subjective",
      "question": "자바에서 생성자 없이 객체를 생성할 수 있는 경우에 대해 설명하시오.",
      "correctAnswer": "생성자를 명시적으로 정의하지 않으면 컴파일러가 기본 생성자를 자동으로 생성하므로, 개발자가 별도로 생성자를 작성하지 않아도 객체를 생성할 수 있다."
    },
    {
      "id": "u2s25",
      "type": "subjective",
      "question": "객체지향 프로그래밍에서 상속의 단점과 이를 극복하는 방법에 대해 논하시오.",
      "correctAnswer": "상속은 강한 결합을 초래할 수 있어 코드 변경 시 영향이 클 수 있으며, 이를 극복하기 위해 인터페이스나 구성(composition) 방식을 사용할 수 있다."
    }
  ],
  "unit3": [
    {
      "id": "u3m1",
      "type": "mcq",
      "question": "상속의 개념에 대해 올바른 설명은 무엇인가?",
      "options": {
        "A": "자식 클래스가 부모 클래스의 멤버와 메서드를 상속받는다.",
        "B": "부모 클래스가 자식 클래스의 멤버를 상속받는다.",
        "C": "모든 클래스는 서로 독립적이다.",
        "D": "상속은 단순히 메모리 절약을 위한 것이다."
      },
      "correctAnswer": "A"
    },
    {
      "id": "u3m2",
      "type": "mcq",
      "question": "메서드 재정의(오버라이딩) 시, 부모 메서드와 자식 메서드의 조건으로 올바른 것은 무엇인가?",
      "options": {
        "A": "메서드 이름이 다르면 오버라이딩이다.",
        "B": "메서드 이름, 매개변수, 반환형이 모두 동일해야 한다.",
        "C": "반환형은 달라도 오버라이딩이 가능하다.",
        "D": "접근제한자는 무시된다."
      },
      "correctAnswer": "B"
    },
    {
      "id": "u3m3",
      "type": "mcq",
      "question": "부모 클래스의 private 멤버는 자식 클래스에 어떻게 상속되는가?",
      "options": {
        "A": "자식 클래스에서 직접 접근할 수 있다.",
        "B": "상속되지만 자식 클래스에서 직접 접근할 수 없다.",
        "C": "상속되지 않는다.",
        "D": "자동으로 protected로 변경되어 상속된다."
      },
      "correctAnswer": "B"
    },
    {
      "id": "u3m4",
      "type": "mcq",
      "question": "메서드 오버라이딩 시, 부모 메서드와 자식 메서드의 접근제한자 규칙에 대해 올바른 설명은 무엇인가?",
      "options": {
        "A": "자식 메서드는 부모 메서드보다 좁은 접근제한자를 사용할 수 있다.",
        "B": "부모 메서드와 자식 메서드는 동일한 접근제한자만 사용할 수 있다.",
        "C": "자식 메서드는 부모 메서드보다 넓은 접근제한자를 사용해야 한다.",
        "D": "접근제한자는 오버라이딩에 영향을 주지 않는다."
      },
      "correctAnswer": "C"
    },
    {
      "id": "u3m5",
      "type": "mcq",
      "question": "상속에서 'super' 키워드의 역할은 무엇인가?",
      "options": {
        "A": "자식 클래스의 멤버를 호출한다.",
        "B": "현재 객체를 참조한다.",
        "C": "부모 클래스의 생성자나 메서드를 호출한다.",
        "D": "클래스의 정적 메서드를 호출한다."
      },
      "correctAnswer": "C"
    },
    {
      "id": "u3m6",
      "type": "mcq",
      "question": "공변 반환형(covariant return type)이란 무엇을 의미하는가?",
      "options": {
        "A": "자식 클래스 타입의 객체를 반환할 수 있다.",
        "B": "부모 클래스 타입의 객체만 반환할 수 있다.",
        "C": "반환형은 오버라이딩 시 변경할 수 없다.",
        "D": "자식 클래스의 메서드는 부모의 반환형의 하위 타입을 반환할 수 있다."
      },
      "correctAnswer": "D"
    },
    {
      "id": "u3m7",
      "type": "mcq",
      "question": "메서드 오버라이딩 시, 부모 클래스의 메서드와 자식 클래스의 메서드가 동일한 시그니처를 가져야 하는 이유는 무엇인가?",
      "options": {
        "A": "메서드 이름만 같으면 충분하다.",
        "B": "메서드 이름, 매개변수, 그리고 반환형이 동일해야 정확한 바인딩이 가능하다.",
        "C": "반환형은 달라도 상관없다.",
        "D": "접근제한자만 동일하면 된다."
      },
      "correctAnswer": "B"
    },
    {
      "id": "u3m8",
      "type": "mcq",
      "question": "상속을 사용하면 코드 재사용성이 높아지는 이유는 무엇인가?",
      "options": {
        "A": "모든 멤버 변수가 공유되기 때문이다.",
        "B": "자식 클래스가 부모 클래스의 모든 메서드를 오버라이딩하기 때문이다.",
        "C": "부모 클래스의 기능을 물려받아 중복 코드를 줄일 수 있기 때문이다.",
        "D": "객체 생성 속도가 빨라지기 때문이다."
      },
      "correctAnswer": "C"
    },
    {
      "id": "u3m9",
      "type": "mcq",
      "question": "메서드 오버로딩과 오버라이딩의 차이점중 옳지 않은 것은?",
      "options": {
        "A": "오버로딩은 같은 이름의 메서드를 매개변수로 구분하여 여러 개 정의하는 것이다.",
        "B": "오버라이딩은 부모 클래스의 메서드를 재정의하는 것이다.",
        "C": "오버라이딩은 부모 클래스의 메서드를 재정의하여 다형성을 구현하는 것이다.",
        "D": "두 개념은 동일하다."
      },
      "correctAnswer": "D"
    },
    {
      "id": "u3m10",
      "type": "mcq",
      "question": "부모 클래스의 final 메서드는 자식 클래스에서 어떻게 되는가?",
      "options": {
        "A": "자식 클래스에서 재정의할 수 없다.",
        "B": "자식 클래스에서 접근은 가능하지만 재정의할 수 없다.",
        "C": "자식 클래스에서 오버라이딩이 가능하다.",
        "D": "부모 클래스의 메서드가 숨겨진다."
      },
      "correctAnswer": "A"
    },
    {
      "id": "u3m11",
      "type": "mcq",
      "question": "자바에서 @Override 어노테이션의 주된 역할은 무엇인가?",
      "options": {
        "A": "부모 클래스의 메서드를 오버라이딩하는 의도를 명시한다.",
        "B": "컴파일러에게 오버라이딩 여부를 확인하도록 지시한다.",
        "C": "메서드의 이름을 변경한다.",
        "D": "메서드를 정적으로 만든다."
      },
      "correctAnswer": "B"
    },
    {
      "id": "u3m12",
      "type": "mcq",
      "question": "자식 클래스에서 부모 클래스의 protected 멤버는 어디서 접근 가능한가?",
      "options": {
        "A": "오직 자식 클래스에서만 접근 가능하다.",
        "B": "같은 패키지 내에서만 접근 가능하다.",
        "C": "같은 패키지와 자식 클래스에서 접근 가능하다.",
        "D": "모든 클래스에서 접근 가능하다."
      },
      "correctAnswer": "C"
    },
    {
      "id": "u3m13",
      "type": "mcq",
      "question": "메서드 오버라이딩 시 반환형에 공변 반환형을 허용하는 이유는 무엇인가?",
      "options": {
        "A": "자식 클래스는 부모 클래스와 완전히 다른 반환형을 사용할 수 있다.",
        "B": "반환형은 오버라이딩 시 고려되지 않는다.",
        "C": "자식 클래스의 메서드는 부모의 반환형과 반드시 동일해야 한다.",
        "D": "자식 클래스의 메서드는 부모의 반환형의 하위 타입을 반환할 수 있다."
      },
      "correctAnswer": "D"
    },
    {
      "id": "u3m14",
      "type": "mcq",
      "question": "부모 클래스의 메서드를 오버라이딩할 때, 부모의 메서드를 호출하려면 어떻게 해야 하는가?",
      "options": {
        "A": "super.method()",
        "B": "this.method()",
        "C": "parent.method()",
        "D": "직접 호출할 수 없다."
      },
      "correctAnswer": "A"
    },
    {
      "id": "u3m15",
      "type": "mcq",
      "question": "메서드 오버로딩은 어느 다형성의 형태에 속하는가?",
      "options": {
        "A": "런타임 다형성",
        "B": "컴파일 타임 다형성",
        "C": "동적 다형성",
        "D": "정적 다형성"
      },
      "correctAnswer": "B"
    },
    {
      "id": "u3m16",
      "type": "mcq",
      "question": "자식 클래스에서 부모 클래스의 메서드를 재정의할 때, 반드시 지켜져야 하는 규칙은 무엇인가?",
      "options": {
        "A": "모든 요소가 동일해야 한다.",
        "B": "메서드 이름과 매개변수만 동일하면 된다.",
        "C": "메서드 이름, 매개변수, 접근제한자 및 예외 선언이 동일해야 한다.",
        "D": "메서드 이름만 동일하면 된다."
      },
      "correctAnswer": "C"
    },
    {
      "id": "u3m17",
      "type": "mcq",
      "question": "상속을 통한 코드 재사용의 단점은 무엇인가?",
      "options": {
        "A": "상속은 항상 장점만 있다.",
        "B": "코드 재사용성이 낮아진다.",
        "C": "객체 생성 속도가 느려진다.",
        "D": "상속 관계가 과도하게 복잡해지면 유지보수가 어려워진다."
      },
      "correctAnswer": "D"
    },
    {
      "id": "u3m18",
      "type": "mcq",
      "question": "자바에서 super() 호출은 주로 언제 사용되는가?",
      "options": {
        "A": "부모 클래스의 생성자를 명시적으로 호출할 때",
        "B": "현재 객체의 생성자를 호출할 때",
        "C": "정적 메서드를 호출할 때",
        "D": "메서드 오버로딩 시 사용된다"
      },
      "correctAnswer": "A"
    },
    {
      "id": "u3m19",
      "type": "mcq",
      "question": "부모 클래스의 메서드를 오버라이딩할 때, 자식 클래스에서 허용되는 반환형 변경은 무엇인가?",
      "options": {
        "A": "전혀 변경할 수 없다.",
        "B": "부모의 반환형과 동일하거나 그 하위 타입이어야 한다.",
        "C": "반환형은 임의로 변경할 수 있다.",
        "D": "오버라이딩 시 반환형은 고려되지 않는다."
      },
      "correctAnswer": "B"
    },
    {
      "id": "u3m20",
      "type": "mcq",
      "question": "메서드 오버로딩 시 구분 기준은 무엇인가?",
      "options": {
        "A": "메서드 이름과 매개변수의 개수, 타입, 순서가 모두 고려된다.",
        "B": "반환형만 고려된다.",
        "C": "접근제한자만 고려된다.",
        "D": "예외 선언만 고려된다."
      },
      "correctAnswer": "A"
    },
    {
      "id": "u3m21",
      "type": "mcq",
      "question": "자식 클래스에서 부모 클래스의 멤버에 접근할 수 없는 경우는 언제인가?",
      "options": {
        "A": "부모 클래스의 public 멤버인 경우",
        "B": "부모 클래스의 protected 멤버인 경우",
        "C": "부모 클래스의 private 멤버인 경우",
        "D": "부모 클래스의 default 멤버인 경우"
      },
      "correctAnswer": "C"
    },
    {
      "id": "u3m22",
      "type": "mcq",
      "question": "메서드 오버라이딩 시, 자식 메서드가 선언할 수 있는 예외 범위에 관한 올바른 설명은 무엇인가?",
      "options": {
        "A": "자식 메서드는 부모 메서드가 선언한 예외보다 좁은 범위의 예외만 선언할 수 있다.",
        "B": "자식 메서드는 부모 메서드와 동일한 예외를 반드시 선언해야 한다.",
        "C": "자식 메서드는 부모 메서드보다 더 많은 예외를 선언할 수 있다.",
        "D": "예외 선언은 오버라이딩에 영향을 주지 않는다."
      },
      "correctAnswer": "A"
    },
    {
      "id": "u3m23",
      "type": "mcq",
      "question": "상속을 통한 코드 재사용의 장점은 무엇인가?",
      "options": {
        "A": "상속은 코드 재사용이 어렵다.",
        "B": "상속을 통해 기존 코드를 재사용하여 개발 시간을 단축할 수 있다.",
        "C": "상속은 코드 재사용과는 무관하다.",
        "D": "상속은 메모리 효율성을 높인다."
      },
      "correctAnswer": "B"
    },
    {
      "id": "u3m24",
      "type": "mcq",
      "question": "메서드 오버라이딩과 오버로딩의 차이점은 무엇인가?",
      "options": {
        "A": "오버로딩은 같은 이름의 메서드를 매개변수로 구분하여 여러 개 정의하는 것이고, 오버라이딩은 부모 클래스의 메서드를 재정의하는 것이다.",
        "B": "오버로딩은 부모 클래스의 메서드를 재정의하는 것이다.",
        "C": "오버라이딩은 메서드 이름이 다르면 발생한다.",
        "D": "오버라이딩은 부모 클래스의 메서드를 재정의하여 다형성을 구현하는 것이다."
      },
      "correctAnswer": "A"
    },
    {
      "id": "u3m25",
      "type": "mcq",
      "question": "자식 클래스에서 부모 클래스의 멤버를 재정의할 때 지켜져야 하는 규칙은 무엇인가?",
      "options": {
        "A": "시그니처는 중요하지 않다.",
        "B": "메서드 이름, 매개변수, 그리고 접근제한자가 동일해야 한다.",
        "C": "반환형은 자유롭게 변경할 수 있다.",
        "D": "오버라이딩은 자동으로 이루어진다."
      },
      "correctAnswer": "B"
    },
    {
      "id": "u3m26",
      "type": "mcq",
      "question": "상속 관계에서 부모 클래스의 생성자가 먼저 호출되는 이유는 무엇인가?",
      "options": {
        "A": "부모 클래스의 초기화가 먼저 이루어져야 하기 때문이다.",
        "B": "자식 클래스의 생성자가 없기 때문이다.",
        "C": "객체 생성 순서에 따라 임의로 결정된다.",
        "D": "컴파일러가 부모 클래스를 먼저 처리하기 때문이다."
      },
      "correctAnswer": "A"
    },
    {
      "id": "u3m27",
      "type": "mcq",
      "question": "자바에서 메서드 시그니처에 포함되는 요소는 무엇인가?",
      "options": {
        "A": "메서드 이름, 매개변수, 반환형, 접근제한자 모두 포함된다.",
        "B": "메서드 이름과 매개변수의 타입 및 순서가 시그니처를 결정한다.",
        "C": "반환형만 포함된다.",
        "D": "예외 선언만 포함된다."
      },
      "correctAnswer": "B"
    },
    {
      "id": "u3m28",
      "type": "mcq",
      "question": "자바에서 정적 메서드의 특징은 무엇인가?",
      "options": {
        "A": "정적 메서드는 항상 객체를 통해 호출된다.",
        "B": "정적 메서드는 인스턴스 변수에 반드시 의존한다.",
        "C": "정적 메서드는 클래스 이름으로 직접 호출할 수 있으며, 모든 인스턴스가 공유한다.",
        "D": "정적 메서드는 컴파일 시에만 호출된다."
      },
      "correctAnswer": "C"
    },
    {
      "id": "u3m29",
      "type": "mcq",
      "question": "상속에서 부모 클래스의 멤버가 자식 클래스에 전달되는 현상을 무엇이라 하는가?",
      "options": {
        "A": "캡슐화",
        "B": "다형성",
        "C": "추상화",
        "D": "상속"
      },
      "correctAnswer": "D"
    },
    {
      "id": "u3m30",
      "type": "mcq",
      "question": "메서드 오버로딩은 어느 다형성의 형태에 해당하는가?",
      "options": {
        "A": "컴파일 타임 다형성",
        "B": "런타임 다형성",
        "C": "동적 다형성",
        "D": "정적 다형성"
      },
      "correctAnswer": "A"
    },
    {
      "id": "u3m31",
      "type": "mcq",
      "question": "자바에서 private 멤버에 접근하기 위한 일반적인 방법은 무엇인가?",
      "options": {
        "A": "직접 접근할 수 있다.",
        "B": "getter와 setter 메서드를 사용한다.",
        "C": "상속받아 오버라이딩해야 한다.",
        "D": "무조건 public으로 변경해야 한다."
      },
      "correctAnswer": "B"
    },
    {
      "id": "u3m32",
      "type": "mcq",
      "question": "상속 관계에서 생성자의 호출 순서에 관한 올바른 설명은 무엇인가?",
      "options": {
        "A": "자식 클래스의 생성자가 먼저 호출된다.",
        "B": "부모 클래스의 생성자가 먼저 호출되어야 한다.",
        "C": "부모 생성자 호출 후 자식 생성자가 호출된다.",
        "D": "생성자 호출 순서는 임의이다."
      },
      "correctAnswer": "C"
    },
    {
      "id": "u3m33",
      "type": "mcq",
      "question": "메서드 오버라이딩에서 공변 반환형(covariant return type)이란 무엇을 의미하는가?",
      "options": {
        "A": "자식 클래스의 메서드가 부모의 반환형과 완전히 달라질 수 있다.",
        "B": "반환형은 오버라이딩 시 변경할 수 없다.",
        "C": "자식 클래스의 메서드가 반드시 void여야 한다.",
        "D": "자식 클래스의 메서드는 부모의 반환형의 하위 타입을 반환할 수 있다."
      },
      "correctAnswer": "D"
    },
    {
      "id": "u3m34",
      "type": "mcq",
      "question": "메서드 오버로딩은 어떤 요소에 의해 구분되는가?",
      "options": {
        "A": "메서드 이름과 매개변수의 개수, 타입, 순서",
        "B": "반환형",
        "C": "접근제한자",
        "D": "예외 선언"
      },
      "correctAnswer": "A"
    },
    {
      "id": "u3m35",
      "type": "mcq",
      "question": "자식 클래스에서 부모 클래스의 멤버를 재정의할 때 필수적으로 지켜져야 하는 것은 무엇인가?",
      "options": {
        "A": "시그니처는 중요하지 않다.",
        "B": "메서드 이름, 매개변수, 접근제한자가 동일해야 한다.",
        "C": "반환형은 자유롭게 변경할 수 있다.",
        "D": "오버라이딩은 컴파일러에 의해 자동 처리된다."
      },
      "correctAnswer": "B"
    },
    {
      "id": "u3m36",
      "type": "mcq",
      "question": "상속 관계에서 부모 클래스의 생성자가 먼저 호출되는 이유는 무엇인가?",
      "options": {
        "A": "부모 클래스의 초기화가 선행되어야 하기 때문이다.",
        "B": "자식 클래스의 생성자가 없기 때문이다.",
        "C": "객체 생성 순서에 따라 임의로 결정된다.",
        "D": "컴파일러가 부모를 먼저 처리한다."
      },
      "correctAnswer": "A"
    },
    {
      "id": "u3m37",
      "type": "mcq",
      "question": "this와 super 키워드의 차이는 무엇인가?",
      "options": {
        "A": "this는 현재 객체, super는 부모 객체의 생성자와 메서드를 호출한다.",
        "B": "둘은 동일하다.",
        "C": "super는 자식 객체를 참조한다.",
        "D": "this는 생성자에서만 사용된다."
      },
      "correctAnswer": "A"
    },
    {
      "id": "u3m38",
      "type": "mcq",
      "question": "메서드 오버로딩은 어떤 다형성을 구현하는가?",
      "options": {
        "A": "런타임 다형성",
        "B": "동적 다형성",
        "C": "정적 다형성",
        "D": "컴파일 타임 다형성"
      },
      "correctAnswer": "D"
    },
    {
      "id": "u3m39",
      "type": "mcq",
      "question": "부모 클래스의 private 멤버는 자식 클래스에서 어떻게 처리되는가?",
      "options": {
        "A": "자식 클래스에서 직접 접근할 수 있다.",
        "B": "getter/setter를 통해 간접적으로 접근해야 한다.",
        "C": "오버라이딩하여 사용할 수 있다.",
        "D": "자동으로 protected로 변경된다."
      },
      "correctAnswer": "B"
    },
    {
      "id": "u3m40",
      "type": "mcq",
      "question": "자식 클래스에서 부모 클래스의 메서드를 오버라이딩할 때, 부모의 메서드를 호출하려면 어떻게 해야 하는가?",
      "options": {
        "A": "this.method()",
        "B": "parent.method()",
        "C": "super.method()",
        "D": "직접 호출할 수 없다."
      },
      "correctAnswer": "C"
    },
    {
      "id": "u3m41",
      "type": "mcq",
      "question": "상속을 통한 코드 재사용의 주요 장점은 무엇인가?",
      "options": {
        "A": "상속은 코드 중복을 줄여준다.",
        "B": "메모리 사용량이 줄어든다.",
        "C": "컴파일 속도가 빨라진다.",
        "D": "객체 생성 시간이 단축된다."
      },
      "correctAnswer": "A"
    },
    {
      "id": "u3m42",
      "type": "mcq",
      "question": "자식 클래스에서 부모 클래스의 private 멤버에 접근하려면 어떤 방법을 사용해야 하는가?",
      "options": {
        "A": "직접 접근할 수 있다.",
        "B": "super 키워드를 사용한다.",
        "C": "getter/setter 메서드를 사용한다.",
        "D": "오버라이딩하여 접근한다."
      },
      "correctAnswer": "C"
    },
    {
      "id": "u3m43",
      "type": "mcq",
      "question": "@Override 어노테이션의 주요 목적은 무엇인가?",
      "options": {
        "A": "부모 메서드를 오버라이딩하는 의도를 명시하는 것이다.",
        "B": "메서드 오버로딩을 수행한다.",
        "C": "클래스의 상속 관계를 표시한다.",
        "D": "메서드 이름을 변경한다."
      },
      "correctAnswer": "A"
    },
    {
      "id": "u3m44",
      "type": "mcq",
      "question": "부모 클래스의 멤버에 접근할 때, 접근제한자에 따른 올바른 규칙은 무엇인가?",
      "options": {
        "A": "모든 부모 멤버는 자식에서 접근할 수 있다.",
        "B": "부모의 private 멤버는 자식에서 접근할 수 없다.",
        "C": "부모의 protected 멤버는 오직 자식에서만 접근 가능하다.",
        "D": "부모의 default 멤버는 항상 public이다."
      },
      "correctAnswer": "B"
    },
    {
      "id": "u3m45",
      "type": "mcq",
      "question": "메서드 오버라이딩과 오버로딩의 차이는 무엇인가?",
      "options": {
        "A": "오버로딩은 같은 이름의 메서드를 여러 개 정의하는 것이고, 오버라이딩은 부모 클래스의 메서드를 재정의하는 것이다.",
        "B": "두 개념은 동일하다.",
        "C": "오버로딩은 런타임 다형성, 오버라이딩은 컴파일 타임 다형성이다.",
        "D": "오버라이딩은 단지 접근제한자 변경만을 의미한다."
      },
      "correctAnswer": "A"
    },
    {
      "id": "u3m46",
      "type": "mcq",
      "question": "정적 메서드는 인스턴스 변수에 접근할 수 있는가?",
      "options": {
        "A": "예, 항상 접근할 수 있다.",
        "B": "아니요, 인스턴스 생성 없이 호출되므로 접근할 수 없다.",
        "C": "조건부로 접근할 수 있다.",
        "D": "컴파일러가 자동으로 조정한다."
      },
      "correctAnswer": "B"
    },
    {
      "id": "u3m47",
      "type": "mcq",
      "question": "메서드 오버라이딩 시, 부모 메서드와 시그니처가 다르면 어떻게 되는가?",
      "options": {
        "A": "오버로딩으로 간주된다.",
        "B": "컴파일 오류가 발생한다.",
        "C": "런타임 오류가 발생한다.",
        "D": "부모 메서드가 호출된다."
      },
      "correctAnswer": "B"
    },
    {
      "id": "u3m48",
      "type": "mcq",
      "question": "부모 클래스의 final 메서드는 자식 클래스에서 재정의할 수 있는가?",
      "options": {
        "A": "재정의할 수 있다.",
        "B": "조건부로 재정의할 수 있다.",
        "C": "오버로딩은 가능하나 재정의는 불가능하다.",
        "D": "재정의할 수 없다."
      },
      "correctAnswer": "D"
    },
    {
      "id": "u3m49",
      "type": "mcq",
      "question": "메서드 오버라이딩 시, 올바른 문법 규칙은 무엇인가?",
      "options": {
        "A": "메서드 이름은 변경해도 된다.",
        "B": "반환형은 반드시 동일해야 한다.",
        "C": "매개변수는 자유롭게 변경할 수 있다.",
        "D": "자식 클래스의 메서드는 부모 클래스의 반환형 하위 타입을 반환할 수 있다."
      },
      "correctAnswer": "D"
    },
    {
      "id": "u3m50",
      "type": "mcq",
      "question": "상속, 메서드 재정의, 제한자와 관련하여 객체지향 프로그래밍의 핵심 개념은 무엇인가?",
      "options": {
        "A": "상속, 오버라이딩, 제한자는 객체지향 프로그래밍의 핵심 개념으로, 코드 재사용과 다형성을 구현한다.",
        "B": "이들은 단지 부가적인 기능에 불과하다.",
        "C": "이들은 메모리 관리를 위한 것이다.",
        "D": "이들은 컴파일러에 의해 자동 처리된다."
      },
      "correctAnswer": "A"
    },
    {
      "id": "u3c1",
      "type": "code",
      "question": "【가정】부모 클래스의 이름은 Parent, 자식 클래스의 이름은 Child입니다.\n다음 코드를 완성하여 Child 클래스가 Parent 클래스를 상속받도록 하시오.",
      "codeSnippet": "class Child __ Parent { }",
      "answers": ["extends"]
    },
    {
      "id": "u3c2",
      "type": "code",
      "question": "【가정】부모 클래스(Parent)에 display() 메서드가 정의되어 있습니다.\n자식 클래스(Child)에서 display() 메서드를 오버라이딩하면서, 부모 클래스의 display() 메서드를 호출하는 코드를 완성하시오.",
      "codeSnippet": "public void display() { return __.display(); }",
      "answers": ["super"]
    },
    {
      "id": "u3c3",
      "type": "code",
      "question": "【가정】Parent 클래스에 int형 멤버 변수 value와 getValue() 메서드가 정의되어 있습니다.\n자식 클래스(Child)에서, 부모 클래스의 private 멤버에 직접 접근할 수 없으므로 getter를 통해 값을 읽어오는 코드를 완성하시오.",
      "codeSnippet": "public int fetchValue() { return __; }",
      "answers": ["super.getValue()"]
    },
    {
      "id": "u3c4",
      "type": "code",
      "question": "【가정】자식 클래스(Child)의 생성자에서 부모 클래스(Parent)의 기본 생성자를 명시적으로 호출하여 초기화를 수행하고자 합니다.\n아래 코드의 빈칸을 채워 넣으시오.",
      "codeSnippet": "public Child() { __(); }",
      "answers": ["super"]
    },
    {
      "id": "u3c5",
      "type": "code",
      "question": "【가정】Parent 클래스에 final 메서드 display()가 정의되어 있습니다.\n다음 코드는 Child 클래스에서 display() 메서드를 오버라이딩하려 할 때 발생하는 컴파일 오류를 보여줍니다.\n빈칸에 올바른 메서드 이름을 채워 넣으시오.",
      "codeSnippet": "class Parent {\n    public final void display() { }\n}\n\nclass Child extends Parent {\n    public void __() { }\n}",
      "answers": ["display"]
    },
    {
      "id": "u3c6",
      "type": "code",
      "question": "【가정】Parent 클래스에 int형 멤버 변수 number가 정의되어 있습니다.\nChild 클래스에서, 동일한 이름의 멤버 변수를 선언하여 부모의 변수를 숨기는(shadowing) 예제를 완성하시오.",
      "codeSnippet": "class Child extends Parent {\n    private int __ = 10;\n}",
      "answers": ["number"]
    },
    {
      "id": "u3c7",
      "type": "code",
      "question": "【가정】Parent 클래스에 오버라이딩 가능한 compute() 메서드가 정의되어 있습니다.\nChild 클래스에서 compute() 메서드를 재정의하여, 부모 메서드의 결과에 5를 더한 값을 반환하는 코드를 완성하시오.",
      "codeSnippet": "public int compute() { return __+__; }",
      "answers": ["super.compute()", "5"]
    },
    {
      "id": "u3c8",
      "type": "code",
      "question": "Child 클래스에서 생성자 체이닝을 사용하여, 같은 클래스 내의 다른 생성자를 호출하는 예제를 완성하시오.",
      "codeSnippet": "public Child(int num) { __(num); }",
      "answers": ["this"]
    },
    {
      "id": "u3c9",
      "type": "code",
      "question": "【가정】Parent 클래스에 정적 메서드 staticMethod()가 정의되어 있습니다.\nParent 클래스의 정적 메서드를 클래스 이름을 사용하여 호출하는 코드를 완성하시오.",
      "codeSnippet": "Parent.__();",
      "answers": ["staticMethod"]
    },
    {
      "id": "u3c10",
      "type": "code",
      "question": "【가정】Parent 클래스에 process() 메서드가 정의되어 있습니다.\nChild 클래스에서 @Override 어노테이션을 사용하여 process() 메서드를 오버라이딩하는 예제를 완성하시오.",
      "codeSnippet": "@Override\npublic void __() { System.out.println(\"오버라이딩\"); }",
      "answers": ["process"]
    },
    {
      "id": "u3c11",
      "type": "code",
      "question": "【가정】부모 클래스는 Parent, 자식 클래스는 Child입니다.\n부모 타입의 참조변수에 자식 객체를 할당하는 업캐스팅 예제를 완성하시오.",
      "codeSnippet": "Parent p = new __();",
      "answers": ["Child"]
    },
    {
      "id": "u3c12",
      "type": "code",
      "question": "【가정】Parent 클래스에 protected로 선언된 display() 메서드가 존재합니다.\nChild 클래스에서 해당 메서드를 오버라이딩하는 예제를 완성하시오.",
      "codeSnippet": "protected void __() { System.out.println(\"재정의\"); }",
      "answers": ["display"]
    },
    {
      "id": "u3c13",
      "type": "code",
      "question": "Child 클래스의 생성자에서 자신의 멤버 변수를 초기화할 때, 명확한 식별을 위해 사용하는 키워드를 채워 넣으시오.",
      "codeSnippet": "public Child(int num) { __.num = num; }",
      "answers": ["this"]
    },
    {
      "id": "u3c14",
      "type": "code",
      "question": "【가정】Parent 클래스에 정의된 getValue() 메서드를 재사용하여, Child 클래스에서 값을 반환하는 코드를 완성하시오.",
      "codeSnippet": "public int fetchParentValue() { return __.__; }",
      "answers": ["super", "getValue()"]
    },
    {
      "id": "u3c15",
      "type": "code",
      "question": "【가정】Parent 클래스에 show() 메서드가 정의되어 있습니다.\nChild 클래스에서 부모의 show() 메서드를 오버라이딩하지 않고 그대로 호출하기 위해, 올바른 코드를 완성하시오.",
      "codeSnippet": "public void callShow() { __.show(); }",
      "answers": ["super"]
    },
    {
      "id": "u3c16",
      "type": "code",
      "question": "【가정】Parent 클래스의 생성자가 int형 매개변수를 받습니다.\nChild 클래스의 생성자에서, 부모 클래스의 해당 생성자에 매개변수를 전달하여 호출하는 코드를 완성하시오.",
      "codeSnippet": "public Child(int num) { __(num); }",
      "answers": ["super"]
    },
    {
      "id": "u3c17",
      "type": "code",
      "question": "【가정】Parent 클래스의 process() 메서드는 throws Exception을 선언합니다.\nChild 클래스에서 이 메서드를 오버라이딩할 때, 부모와 동일하거나 좁은 범위의 예외를 선언하는 예제를 완성하시오.",
      "codeSnippet": "public void process() throws __ { }",
      "answers": ["Exception"]
    },
    {
      "id": "u3c18",
      "type": "code",
      "question": "【가정】Parent 클래스에 정의된 getInstance() 메서드의 반환형은 Parent입니다.\nChild 클래스에서 공변 반환형을 활용하여, getInstance() 메서드를 재정의하고 Child 타입의 객체를 반환하는 코드를 완성하시오.",
      "codeSnippet": "public __ getInstance() { return new Child(); }",
      "answers": ["Child"]
    },
    {
      "id": "u3c19",
      "type": "code",
      "question": "Child 클래스에서 getNumber() 메서드를 재정의하여, 항상 42를 반환하도록 구현하는 예제를 완성하시오.",
      "codeSnippet": "public int getNumber() { return __; }",
      "answers": ["42"]
    },
    {
      "id": "u3c20",
      "type": "code",
      "question": "Child 클래스에서 오버라이딩하지 않고, Parent 클래스에 정의된 compute() 메서드를 그대로 호출하여 그 결과를 반환하는 코드를 완성하시오.",
      "codeSnippet": "public int compute() { return __.__; }",
      "answers": ["super", "compute()"]
    },
    {
      "id": "u3c21",
      "type": "code",
      "question": "메서드 오버로딩을 통해, 동일한 이름의 calculate() 메서드를 서로 다른 매개변수로 정의하는 예제를 완성하시오.\n(예: 첫 번째 calculate()는 int 하나를, 두 번째 calculate()는 int 두 개를 매개변수로 받음)",
      "codeSnippet": "public int calculate(int a) { return a * 2; }\npublic int calculate(__ b, int c) { return b + c; }",
      "answers": ["int"]
    },
    {
      "id": "u3c22",
      "type": "code",
      "question": "【가정】Parent 클래스에 정적 메서드 staticMethod()가 정의되어 있습니다.\nChild 클래스에서 오버라이딩 없이, Parent 클래스의 정적 메서드를 클래스 이름을 사용하여 호출하는 코드를 완성하시오.",
      "codeSnippet": "Parent.__();",
      "answers": ["staticMethod"]
    },
    {
      "id": "u3c23",
      "type": "code",
      "question": "【가정】Parent 클래스에 protected 또는 public으로 선언된 int형 필드 data가 있습니다.\nChild 클래스에서 동일한 이름의 필드를 선언하여 부모의 필드를 숨기는(shadowing) 상황에서, 부모 클래스의 data 값을 참조하는 코드를 완성하시오.",
      "codeSnippet": "public int getParentData() { return __.__; }",
      "answers": ["super", "data"]
    },
    {
      "id": "u3c24",
      "type": "code",
      "question": "Child 클래스에서 부모 클래스(Parent)의 멤버 메서드를 재정의하지 않고 그대로 호출하기 위해 사용하는 키워드를 코드에 채워 넣으시오.",
      "codeSnippet": "public void invokeParent() { __.method(); }",
      "answers": ["super"]
    },
    {
      "id": "u3c25",
      "type": "code",
      "question": "【가정】Child 클래스에는 기본 생성자와 int형 매개변수를 받는 생성자가 있습니다.\n아래 예제에서, 기본 생성자에서는 Parent 클래스의 기본 생성자를 호출하고, 매개변수 생성자에서는 Child 클래스의 기본 생성자를 호출하여 초기화를 수행하는 코드를 완성하시오.",
      "codeSnippet": "public Child() {\n    __(); // 부모 클래스의 기본 생성자 호출\n    // 추가 초기화 코드\n}\n\npublic Child(int num) {\n    __( ); // 자식 클래스의 기본 생성자 호출\n    this.num = num;\n}",
      "answers": ["super", "this"]
    },
    {
      "id": "u3s1",
      "type": "subjective",
      "question": "상속의 장단점에 대해 구체적인 예를 들어 설명하시오.",
      "correctAnswer": "상속은 기존 클래스의 기능을 재사용하여 코드 중복을 줄이고 유지보수를 용이하게 하지만, 과도한 상속은 결합도를 높여 유연성을 떨어뜨릴 수 있다."
    },
    {
      "id": "u3s2",
      "type": "subjective",
      "question": "메서드 오버라이딩의 개념과 필요성에 대해 서술하시오.",
      "correctAnswer": "오버라이딩은 부모 클래스의 메서드를 자식 클래스에서 재정의함으로써, 런타임 다형성을 구현하고 객체마다 다른 동작을 수행할 수 있게 한다."
    },
    {
      "id": "u3s3",
      "type": "subjective",
      "question": "부모 클래스의 private 멤버에 접근하는 방법에 대해 설명하시오.",
      "correctAnswer": "private 멤버는 직접 상속되지는 않으므로, getter와 setter 메서드를 통해 간접적으로 접근해야 한다."
    },
    {
      "id": "u3s4",
      "type": "subjective",
      "question": "super 키워드의 사용법과 그 중요성에 대해 설명하시오.",
      "correctAnswer": "super 키워드는 자식 클래스에서 부모 클래스의 생성자나 메서드를 호출할 때 사용되어, 부모의 초기화나 기본 동작을 유지할 수 있게 한다."
    },
    {
      "id": "u3s5",
      "type": "subjective",
      "question": "메서드 오버라이딩과 오버로딩의 차이를 예제를 들어 설명하시오.",
      "correctAnswer": "오버로딩은 같은 이름의 메서드를 매개변수로 구분하여 여러 개 정의하는 것이고, 오버라이딩은 부모 클래스의 메서드를 자식 클래스에서 재정의하여 다형성을 구현하는 것이다."
    },
    {
      "id": "u3s6",
      "type": "subjective",
      "question": "공변 반환형의 개념과 그 필요성에 대해 설명하시오.",
      "correctAnswer": "공변 반환형은 자식 클래스의 메서드가 부모 클래스의 반환형의 하위 타입을 반환할 수 있게 하여, 보다 구체적인 객체를 반환하고 다형성을 강화한다."
    },
    {
      "id": "u3s7",
      "type": "subjective",
      "question": "상속을 통한 코드 재사용의 이점과 단점에 대해 논하시오.",
      "correctAnswer": "상속은 기존 코드를 재사용하여 개발 시간을 단축하고 유지보수를 용이하게 하지만, 잘못 설계하면 클래스 간 결합도가 높아져 유연성이 떨어질 수 있다."
    },
    {
      "id": "u3s8",
      "type": "subjective",
      "question": "메서드 오버라이딩 시 접근제한자 규칙에 대해 설명하시오.",
      "correctAnswer": "자식 클래스에서 오버라이딩하는 메서드는 부모 클래스의 접근제한자보다 좁은 범위로 설정할 수 없으며, 보통 동일하거나 더 넓은 범위로 선언해야 한다."
    },
    {
      "id": "u3s9",
      "type": "subjective",
      "question": "자식 클래스에서 부모 클래스의 멤버를 숨기는(섀도잉) 현상의 원인과 그 결과에 대해 서술하시오.",
      "correctAnswer": "섀도잉은 자식 클래스에서 동일한 이름의 멤버를 재선언하여 부모 클래스의 멤버를 가리는 현상으로, 혼란을 야기할 수 있으므로 주의해야 한다."
    },
    {
      "id": "u3s10",
      "type": "subjective",
      "question": "상속 관계에서 생성자 호출 순서의 중요성에 대해 설명하시오.",
      "correctAnswer": "부모 클래스의 생성자가 먼저 호출되어 기본적인 초기화가 완료된 후 자식 클래스의 생성자가 호출되므로, 상속 관계의 올바른 초기화 순서를 보장한다."
    },
    {
      "id": "u3s11",
      "type": "subjective",
      "question": "메서드 오버라이딩이 다형성 구현에 미치는 영향을 구체적인 예와 함께 설명하시오.",
      "correctAnswer": "부모 클래스 참조변수로 자식 객체를 다루면, 런타임에 자식 클래스에서 재정의한 메서드가 호출되어 다양한 동작을 구현할 수 있다."
    },
    {
      "id": "u3s12",
      "type": "subjective",
      "question": "부모 클래스의 final 메서드가 가지는 의미와 사용 사례에 대해 설명하시오.",
      "correctAnswer": "final 메서드는 재정의가 불가능하여 부모 클래스의 기본 기능을 보호하는 용도로 사용되며, 보안이나 안정성이 중요한 경우에 유용하다."
    },
    {
      "id": "u3s13",
      "type": "subjective",
      "question": "상속과 컴포지션의 차이점과 각각의 장단점에 대해 비교하시오.",
      "correctAnswer": "상속은 코드 재사용과 확장을 가능하게 하지만 강한 결합을 초래할 수 있으며, 컴포지션은 객체를 구성하여 유연성을 제공하지만 인터페이스 설계가 복잡해질 수 있다."
    },
    {
      "id": "u3s14",
      "type": "subjective",
      "question": "자바에서 접근제한자(private, protected, public)의 역할과 상속에서의 적용에 대해 설명하시오.",
      "correctAnswer": "접근제한자는 클래스 멤버의 노출 범위를 결정하며, 이를 통해 캡슐화가 이루어지고 상속 시 불필요한 외부 접근을 제한할 수 있다."
    },
    {
      "id": "u3s15",
      "type": "subjective",
      "question": "메서드 시그니처의 정의와 오버라이딩, 오버로딩에서의 역할에 대해 설명하시오.",
      "correctAnswer": "메서드 시그니처는 메서드 이름과 매개변수의 타입 및 순서를 의미하며, 오버로딩과 오버라이딩을 구분하는 핵심 요소이다."
    },
    {
      "id": "u3s16",
      "type": "subjective",
      "question": "상속을 통한 코드 재사용이 유지보수에 미치는 긍정적, 부정적 영향을 설명하시오.",
      "correctAnswer": "상속은 중복 코드를 줄여 유지보수를 쉽게 하지만, 과도한 상속은 클래스 간 결합도를 높여 변경에 따른 영향을 크게 할 수 있다."
    },
    {
      "id": "u3s17",
      "type": "subjective",
      "question": "오버라이딩된 메서드 내에서 부모 클래스의 메서드를 호출하는 이유와 그 방법에 대해 설명하시오.",
      "correctAnswer": "부모의 기본 동작을 유지하거나 확장하기 위해 super 키워드를 사용하여 부모의 메서드를 호출한다."
    },
    {
      "id": "u3s18",
      "type": "subjective",
      "question": "자식 클래스에서 부모 클래스의 생성자를 호출하는 방식과 그 필요성에 대해 설명하시오.",
      "correctAnswer": "자식 클래스의 생성자에서 super()를 호출하여 부모 클래스의 초기화를 먼저 수행함으로써, 올바른 객체 구성이 가능하다."
    },
    {
      "id": "u3s19",
      "type": "subjective",
      "question": "메서드 오버로딩이 컴파일 타임 다형성을 구현하는 방법에 대해 설명하시오.",
      "correctAnswer": "오버로딩은 같은 이름의 메서드를 매개변수로 구분하여 여러 개 정의함으로써, 컴파일 시 호출할 메서드를 결정하는 방식으로 다형성을 구현한다."
    },
    {
      "id": "u3s20",
      "type": "subjective",
      "question": "상속을 이용한 클래스 확장이 시스템 설계에 미치는 장단점에 대해 논하시오.",
      "correctAnswer": "상속은 기존 기능을 재사용하여 개발을 단축시키지만, 잘못 사용하면 강한 결합과 복잡한 계층 구조로 인해 유지보수가 어려워질 수 있다."
    },
    {
      "id": "u3s21",
      "type": "subjective",
      "question": "상속 관계를 통해 구현할 수 있는 다형성의 예를 구체적으로 설명하시오.",
      "correctAnswer": "예를 들어, 부모 클래스 타입의 참조변수에 자식 객체를 할당하여, 런타임에 자식 클래스의 재정의된 메서드가 호출되는 경우가 있다."
    },
    {
      "id": "u3s22",
      "type": "subjective",
      "question": "메서드 오버라이딩 시 발생할 수 있는 문제점과 이를 해결하기 위한 방법에 대해 논하시오.",
      "correctAnswer": "부모와 자식의 메서드 시그니처 불일치나 예외 처리 차이 등이 문제를 일으킬 수 있으며, 이를 해결하기 위해 @Override 어노테이션과 엄격한 시그니처 준수가 필요하다."
    },
    {
      "id": "u3s23",
      "type": "subjective",
      "question": "부모 클래스의 멤버에 접근하기 위해 사용하는 getter와 setter 메서드의 역할에 대해 설명하시오.",
      "correctAnswer": "getter와 setter는 private 멤버에 대한 간접 접근을 제공하여, 데이터 은닉과 캡슐화를 유지하면서 외부 접근을 가능하게 한다."
    },
    {
      "id": "u3s24",
      "type": "subjective",
      "question": "상속, 오버라이딩, 제한자가 협력하여 객체지향 프로그래밍을 구현하는 방식을 설명하시오.",
      "correctAnswer": "이들 개념은 함께 작동하여 코드 재사용과 다형성을 구현하며, 클래스 간의 계층 구조를 통해 복잡한 시스템을 단순화한다."
    },
    {
      "id": "u3s25",
      "type": "subjective",
      "question": "자식 클래스에서 부모 클래스의 메서드를 재정의할 때 고려해야 할 핵심 사항에 대해 설명하시오.",
      "correctAnswer": "부모의 메서드와 동일한 시그니처, 접근제한자, 예외 선언 등을 준수해야 하며, 이를 통해 올바른 오버라이딩과 다형성이 구현된다."
    }
  ],
  "unit4": [
    {
      "id": "u4m1",
      "type": "mcq",
      "question": "자바에서 public 접근제한자는 어떤 의미인가?",
      "options": {
        "A": "모든 클래스에서 접근 가능하다.",
        "B": "같은 패키지 내에서만 접근 가능하다.",
        "C": "오직 해당 클래스 내부에서만 접근 가능하다.",
        "D": "자식 클래스에서만 접근 가능하다."
      },
      "correctAnswer": "A"
    },
    {
      "id": "u4m2",
      "type": "mcq",
      "question": "자바에서 default 접근제한자는 무엇을 의미하는가?",
      "options": {
        "A": "모든 곳에서 접근 가능하다.",
        "B": "명시적 제한자가 없을 경우, 같은 패키지 내에서만 접근 가능하다.",
        "C": "클래스 내부에서만 접근 가능하다.",
        "D": "자식 클래스에서만 접근 가능하다."
      },
      "correctAnswer": "B"
    },
    {
      "id": "u4m3",
      "type": "mcq",
      "question": "protected 접근제한자는 어느 범위까지 접근을 허용하는가?",
      "options": {
        "A": "오직 클래스 내부에서만",
        "B": "같은 패키지 내에서만",
        "C": "같은 패키지 및 자식 클래스에서",
        "D": "모든 곳에서"
      },
      "correctAnswer": "C"
    },
    {
      "id": "u4m4",
      "type": "mcq",
      "question": "private 접근제한자의 의미는 무엇인가?",
      "options": {
        "A": "자식 클래스에서 접근 가능하다.",
        "B": "같은 패키지 내에서 접근 가능하다.",
        "C": "모든 클래스에서 접근 가능하다.",
        "D": "해당 클래스 내부에서만 접근 가능하다."
      },
      "correctAnswer": "D"
    },
    {
      "id": "u4m5",
      "type": "mcq",
      "question": "자바에서 static 멤버의 주요 특징은 무엇인가?",
      "options": {
        "A": "클래스 이름으로 직접 접근 가능하다.",
        "B": "객체 생성 후에만 접근 가능하다.",
        "C": "인스턴스 메서드에서만 사용된다.",
        "D": "생성자 내에서만 접근할 수 있다."
      },
      "correctAnswer": "A"
    },
    {
      "id": "u4m6",
      "type": "mcq",
      "question": "다형성이란 무엇을 의미하는가?",
      "options": {
        "A": "하나의 클래스에서 여러 개의 변수를 선언하는 것이다.",
        "B": "하나의 인터페이스로 다양한 구현을 제공하는 것이다.",
        "C": "메서드 오버로딩만을 의미한다.",
        "D": "상속을 통한 클래스 확장을 의미한다."
      },
      "correctAnswer": "B"
    },
    {
      "id": "u4m7",
      "type": "mcq",
      "question": "객체의 형변환에서 업캐스팅(upcasting)이란 무엇을 의미하는가?",
      "options": {
        "A": "부모 클래스로의 변환",
        "B": "자식 클래스로의 변환",
        "C": "자식 객체를 부모 타입으로 변환하는 것",
        "D": "객체를 기본형으로 변환하는 것"
      },
      "correctAnswer": "C"
    },
    {
      "id": "u4m8",
      "type": "mcq",
      "question": "객체의 형변환에서 다운캐스팅(downcasting)이란 무엇을 의미하는가?",
      "options": {
        "A": "부모 타입에서 자식 타입으로의 자동 형변환",
        "B": "자식 타입에서 부모 타입으로의 변환",
        "C": "동일한 클래스 간의 형변환",
        "D": "부모 타입의 객체를 자식 타입으로 명시적으로 변환하는 것"
      },
      "correctAnswer": "D"
    },
    {
      "id": "u4m9",
      "type": "mcq",
      "question": "접근제한자를 사용하는 주된 목적은 무엇인가?",
      "options": {
        "A": "데이터 보호와 캡슐화",
        "B": "메모리 사용량 감소",
        "C": "코드 실행 속도 향상",
        "D": "객체 생성 시간 단축"
      },
      "correctAnswer": "A"
    },
    {
      "id": "u4m10",
      "type": "mcq",
      "question": "다형성을 구현하기 위한 한 가지 방법은 무엇인가?",
      "options": {
        "A": "모든 메서드를 static으로 선언한다.",
        "B": "부모 클래스 타입의 참조변수로 자식 객체를 다룬다.",
        "C": "모든 메서드를 final로 선언한다.",
        "D": "객체를 복제한다."
      },
      "correctAnswer": "B"
    },
    {
      "id": "u4m11",
      "type": "mcq",
      "question": "업캐스팅은 어떤 상황에서 유용하게 사용되는가?",
      "options": {
        "A": "자식 클래스의 고유 메서드를 사용하려 할 때",
        "B": "객체의 메모리 주소를 확인할 때",
        "C": "부모 클래스의 공통 기능을 활용할 때",
        "D": "객체를 문자열로 변환할 때"
      },
      "correctAnswer": "C"
    },
    {
      "id": "u4m12",
      "type": "mcq",
      "question": "다운캐스팅 시 주의해야 할 점은 무엇인가?",
      "options": {
        "A": "항상 자동으로 이루어진다.",
        "B": "업캐스팅 후에만 명시적 형변환을 사용할 수 있다.",
        "C": "형변환 후 객체는 자동으로 변경된다.",
        "D": "잘못된 형변환은 ClassCastException을 발생시킬 수 있다."
      },
      "correctAnswer": "D"
    },
    {
      "id": "u4m13",
      "type": "mcq",
      "question": "protected 접근제한자의 주요 특징은 무엇인가?",
      "options": {
        "A": "같은 패키지 및 자식 클래스에서 접근 가능하다.",
        "B": "오직 클래스 내부에서만 접근 가능하다.",
        "C": "모든 곳에서 접근 가능하다.",
        "D": "private와 동일하다."
      },
      "correctAnswer": "A"
    },
    {
      "id": "u4m14",
      "type": "mcq",
      "question": "다형성의 이점 중 올바른 설명은 무엇인가?",
      "options": {
        "A": "코드가 간결해진다.",
        "B": "동일한 인터페이스로 다양한 객체를 처리할 수 있다.",
        "C": "메모리 사용량이 크게 줄어든다.",
        "D": "컴파일 속도가 향상된다."
      },
      "correctAnswer": "B"
    },
    {
      "id": "u4m15",
      "type": "mcq",
      "question": "자바에서 형변환 시 명시적 형변환이 필요한 경우는 언제인가?",
      "options": {
        "A": "부모 타입에서 자식 타입으로 변환할 때",
        "B": "자식 타입에서 부모 타입으로 변환할 때",
        "C": "동일 타입 간의 변환 시",
        "D": "모든 형변환은 자동으로 이루어진다."
      },
      "correctAnswer": "A"
    },
    {
      "id": "u4m16",
      "type": "mcq",
      "question": "instanceof 연산자의 역할은 무엇인가?",
      "options": {
        "A": "객체를 특정 타입으로 자동 변환한다.",
        "B": "객체의 메모리 주소를 반환한다.",
        "C": "객체의 클래스 이름을 출력한다.",
        "D": "객체가 특정 타입의 인스턴스인지 확인한다."
      },
      "correctAnswer": "D"
    },
    {
      "id": "u4m17",
      "type": "mcq",
      "question": "접근제한자가 올바르게 사용되었을 때 얻을 수 있는 주요 이점은 무엇인가?",
      "options": {
        "A": "데이터 보호와 보안 강화",
        "B": "메모리 최적화",
        "C": "코드 실행 속도 향상",
        "D": "객체 생성 시간 단축"
      },
      "correctAnswer": "A"
    },
    {
      "id": "u4m18",
      "type": "mcq",
      "question": "다형성을 구현하기 위해 부모 클래스의 참조변수에 자식 객체를 할당하는 이유는 무엇인가?",
      "options": {
        "A": "메모리 절약을 위해",
        "B": "다형성을 통해 다양한 객체를 한 인터페이스로 다루기 위해",
        "C": "객체의 복제를 위해",
        "D": "컴파일 속도를 높이기 위해"
      },
      "correctAnswer": "B"
    },
    {
      "id": "u4m19",
      "type": "mcq",
      "question": "자바에서 기본형과 참조형 간의 형변환에 대해 올바른 설명은 무엇인가?",
      "options": {
        "A": "기본형과 참조형은 서로 자동으로 변환된다.",
        "B": "기본형은 참조형으로, 참조형은 기본형으로 변환할 수 없다.",
        "C": "기본형과 참조형은 직접 변환할 수 없으며, 별도의 메서드를 사용해야 한다.",
        "D": "기본형과 참조형은 서로 자동 형변환되지 않는다."
      },
      "correctAnswer": "D"
    },
    {
      "id": "u4m20",
      "type": "mcq",
      "question": "다운캐스팅 시 안전성을 보장하기 위한 일반적인 방법은 무엇인가?",
      "options": {
        "A": "자동 형변환을 사용한다.",
        "B": "형변환 후 객체가 변경된다.",
        "C": "항상 부모 클래스로 업캐스팅한다.",
        "D": "instanceof 연산자로 타입을 확인한 후 명시적 형변환을 수행한다."
      },
      "correctAnswer": "D"
    },
    {
      "id": "u4m21",
      "type": "mcq",
      "question": "private 멤버의 주요 특징은 무엇인가?",
      "options": {
        "A": "오직 해당 클래스 내부에서만 접근 가능하다.",
        "B": "같은 패키지 내에서도 접근 가능하다.",
        "C": "자식 클래스에서도 접근 가능하다.",
        "D": "모든 클래스에서 접근 가능하다."
      },
      "correctAnswer": "A"
    },
    {
      "id": "u4m22",
      "type": "mcq",
      "question": "protected 멤버는 어느 범위에서 접근할 수 있는가?",
      "options": {
        "A": "오직 클래스 내부에서만",
        "B": "같은 패키지 및 자식 클래스에서",
        "C": "모든 곳에서",
        "D": "자식 클래스에서만"
      },
      "correctAnswer": "B"
    },
    {
      "id": "u4m23",
      "type": "mcq",
      "question": "자바에서 객체의 업캐스팅이 자동으로 이루어지는 이유는 무엇인가?",
      "options": {
        "A": "자식 객체가 부모 클래스의 메서드를 항상 포함하기 때문이다.",
        "B": "명시적 형변환이 불필요하기 때문이다.",
        "C": "부모 타입으로의 변환은 컴파일러가 자동으로 처리하기 때문이다.",
        "D": "다운캐스팅은 항상 자동이다."
      },
      "correctAnswer": "C"
    },
    {
      "id": "u4m24",
      "type": "mcq",
      "question": "객체의 형변환 시, 명시적 형변환을 하는 주된 이유는 무엇인가?",
      "options": {
        "A": "컴파일러가 자동으로 변환해주기 때문이다.",
        "B": "타입 정보를 잃지 않고 강제로 변환하기 위함이다.",
        "C": "객체를 기본형으로 변환하기 위함이다.",
        "D": "메모리 사용량을 줄이기 위함이다."
      },
      "correctAnswer": "B"
    },
    {
      "id": "u4m25",
      "type": "mcq",
      "question": "정적 메서드의 주요 특징은 무엇인가?",
      "options": {
        "A": "객체 생성 없이 클래스 이름으로 직접 호출 가능하다.",
        "B": "인스턴스 변수에 직접 접근할 수 있다.",
        "C": "오버라이딩이 가능하다.",
        "D": "모든 메서드가 abstract이다."
      },
      "correctAnswer": "A"
    },
    {
      "id": "u4m26",
      "type": "mcq",
      "question": "다형성(polymorphism)이 객체지향 프로그래밍에서 중요한 이유는 무엇인가?",
      "options": {
        "A": "객체 생성 속도를 향상시킨다.",
        "B": "코드 재사용성과 확장성을 높인다.",
        "C": "메모리 사용량을 최적화한다.",
        "D": "컴파일러 오류를 줄인다."
      },
      "correctAnswer": "B"
    },
    {
      "id": "u4m27",
      "type": "mcq",
      "question": "객체 형변환 시, 다운캐스팅이 실패하면 발생하는 예외는 무엇인가?",
      "options": {
        "A": "NullPointerException",
        "B": "ArrayIndexOutOfBoundsException",
        "C": "ClassCastException",
        "D": "IllegalArgumentException"
      },
      "correctAnswer": "C"
    },
    {
      "id": "u4m28",
      "type": "mcq",
      "question": "접근제한자를 통해 캡슐화를 구현하면 얻을 수 있는 효과는 무엇인가?",
      "options": {
        "A": "코드 실행 속도가 빨라진다.",
        "B": "데이터 보호와 보안이 강화된다.",
        "C": "메모리 사용량이 줄어든다.",
        "D": "객체 생성 비용이 감소한다."
      },
      "correctAnswer": "B"
    },
    {
      "id": "u4m29",
      "type": "mcq",
      "question": "자바에서 형변환 시 사용하는 명시적 형변환의 문법은 무엇인가?",
      "options": {
        "A": "(타입) 객체",
        "B": "타입(객체)",
        "C": "객체 as 타입",
        "D": "타입 객체"
      },
      "correctAnswer": "A"
    },
    {
      "id": "u4m30",
      "type": "mcq",
      "question": "다형성을 구현하기 위한 중요한 키워드 중 하나인 instanceof의 주된 용도는 무엇인가?",
      "options": {
        "A": "객체를 특정 타입으로 자동 변환한다.",
        "B": "객체가 특정 타입의 인스턴스인지 확인한다.",
        "C": "객체의 메모리 주소를 반환한다.",
        "D": "객체를 복제한다."
      },
      "correctAnswer": "B"
    },
    {
      "id": "u4m31",
      "type": "mcq",
      "question": "업캐스팅은 일반적으로 어떤 경우에 사용되는가?",
      "options": {
        "A": "자식 객체의 고유 기능 호출 시",
        "B": "부모 클래스의 공통 기능 사용 시",
        "C": "객체를 문자열로 변환할 때",
        "D": "메모리 할당을 최적화할 때"
      },
      "correctAnswer": "B"
    },
    {
      "id": "u4m32",
      "type": "mcq",
      "question": "자바에서 다형성을 구현하기 위해 가장 많이 사용되는 개념은 무엇인가?",
      "options": {
        "A": "캡슐화",
        "B": "상속",
        "C": "메서드 오버로딩",
        "D": "메서드 오버라이딩"
      },
      "correctAnswer": "D"
    },
    {
      "id": "u4m33",
      "type": "mcq",
      "question": "객체의 형변환에서 명시적 형변환을 사용할 때 주의해야 할 점은 무엇인가?",
      "options": {
        "A": "반드시 자동 형변환이 이루어진다.",
        "B": "실제 객체 타입과 일치하는지 확인해야 한다.",
        "C": "형변환 후 객체의 값이 변경된다.",
        "D": "형변환은 컴파일러가 임의로 처리한다."
      },
      "correctAnswer": "B"
    },
    {
      "id": "u4m34",
      "type": "mcq",
      "question": "접근제한자, 다형성, 객체의 형변환과 관련하여, 올바른 형변환 예제는 무엇인가?",
      "options": {
        "A": "자식 객체를 부모 타입으로 변환하는 업캐스팅",
        "B": "부모 객체를 자식 타입으로 변환하는 다운캐스팅",
        "C": "같은 클래스 간의 형변환",
        "D": "기본형과 참조형 간의 형변환"
      },
      "correctAnswer": "A"
    },
    {
      "id": "u4m35",
      "type": "mcq",
      "question": "접근제한자가 없는(default) 멤버는 어느 범위에서 접근 가능한가?",
      "options": {
        "A": "같은 클래스 내부에서만",
        "B": "같은 패키지 내에서만",
        "C": "모든 곳에서",
        "D": "자식 클래스에서만"
      },
      "correctAnswer": "B"
    },
    {
      "id": "u4m36",
      "type": "mcq",
      "question": "자바에서 형변환이 실패할 때 발생하는 예외는 무엇인가?",
      "options": {
        "A": "NullPointerException",
        "B": "ArithmeticException",
        "C": "ClassCastException",
        "D": "IllegalArgumentException"
      },
      "correctAnswer": "C"
    },
    {
      "id": "u4m37",
      "type": "mcq",
      "question": "객체 형변환 시, 부모 타입의 참조변수에 자식 객체를 할당하는 것을 무엇이라 하는가?",
      "options": {
        "A": "다운캐스팅",
        "B": "업캐스팅",
        "C": "명시적 형변환",
        "D": "자동 형변환"
      },
      "correctAnswer": "B"
    },
    {
      "id": "u4m38",
      "type": "mcq",
      "question": "다형성 구현 시, 부모 클래스 참조변수를 통해 자식 클래스의 재정의된 메서드를 호출하는 이유는 무엇인가?",
      "options": {
        "A": "컴파일 타임 다형성을 구현하기 위해",
        "B": "런타임 다형성을 구현하기 위해",
        "C": "메모리 할당을 줄이기 위해",
        "D": "객체의 복제를 위해"
      },
      "correctAnswer": "B"
    },
    {
      "id": "u4m39",
      "type": "mcq",
      "question": "객체의 형변환 시, 부모 클래스의 참조변수가 자식 객체를 가리킬 수 있는 이유는 무엇인가?",
      "options": {
        "A": "자식 객체는 부모 클래스의 모든 멤버를 포함하기 때문이다.",
        "B": "자식 객체는 별도의 메모리 영역을 갖는다.",
        "C": "부모 객체는 항상 자식 객체보다 작다.",
        "D": "형변환은 자동으로 이루어진다."
      },
      "correctAnswer": "C"
    },
    {
      "id": "u4m40",
      "type": "mcq",
      "question": "접근제한자와 관련하여, private 멤버는 어디에서 접근 가능한가?",
      "options": {
        "A": "모든 클래스에서",
        "B": "같은 패키지 내에서",
        "C": "자식 클래스에서",
        "D": "해당 클래스 내부에서만"
      },
      "correctAnswer": "D"
    },
    {
      "id": "u4m41",
      "type": "mcq",
      "question": "객체 형변환 시, 명시적 형변환 문법의 기본 구조는 무엇인가?",
      "options": {
        "A": "(타입) 객체",
        "B": "타입(객체)",
        "C": "객체 as 타입",
        "D": "타입 객체"
      },
      "correctAnswer": "A"
    },
    {
      "id": "u4m42",
      "type": "mcq",
      "question": "자바에서 static 키워드가 붙은 메서드는 어떤 방식으로 호출되는가?",
      "options": {
        "A": "객체 생성 후 호출한다.",
        "B": "클래스 이름으로 직접 호출한다.",
        "C": "반드시 인스턴스 메서드를 통해 호출한다.",
        "D": "생성자 내에서만 호출된다."
      },
      "correctAnswer": "B"
    },
    {
      "id": "u4m43",
      "type": "mcq",
      "question": "접근제한자를 사용하여 멤버의 외부 노출을 제한할 때, 가장 강력한 제한자는 무엇인가?",
      "options": {
        "A": "public",
        "B": "protected",
        "C": "default",
        "D": "private"
      },
      "correctAnswer": "D"
    },
    {
      "id": "u4m44",
      "type": "mcq",
      "question": "다형성을 구현하는 데 있어 메서드 오버라이딩의 역할은 무엇인가?",
      "options": {
        "A": "동일한 이름의 메서드를 여러 개 정의한다.",
        "B": "부모 클래스의 메서드를 재정의하여 자식 클래스의 동작을 구현한다.",
        "C": "메서드 호출 시 컴파일 타임에 결정된다.",
        "D": "메서드의 접근제한자를 변경한다."
      },
      "correctAnswer": "B"
    },
    {
      "id": "u4m45",
      "type": "mcq",
      "question": "객체 형변환 시, 명시적 형변환이 필요한 이유는 무엇인가?",
      "options": {
        "A": "컴파일러가 자동 변환하지 않기 때문이다.",
        "B": "객체의 실제 타입을 변경하기 위해서이다.",
        "C": "반드시 업캐스팅 후에만 필요하다.",
        "D": "형변환은 런타임에만 이루어진다."
      },
      "correctAnswer": "A"
    },
    {
      "id": "u4m46",
      "type": "mcq",
      "question": "접근제한자 중, 같은 패키지 내에서만 접근 가능한 것은 무엇인가?",
      "options": {
        "A": "public",
        "B": "protected",
        "C": "default",
        "D": "private"
      },
      "correctAnswer": "C"
    },
    {
      "id": "u4m47",
      "type": "mcq",
      "question": "다형성의 개념을 통해 얻을 수 있는 주요 이점은 무엇인가?",
      "options": {
        "A": "코드 재사용성 향상",
        "B": "메모리 절약",
        "C": "컴파일 속도 증가",
        "D": "객체 생성 시간 단축"
      },
      "correctAnswer": "A"
    },
    {
      "id": "u4m48",
      "type": "mcq",
      "question": "자바에서 다운캐스팅 시 주의할 점은 무엇인가?",
      "options": {
        "A": "반드시 업캐스팅을 먼저 수행해야 한다.",
        "B": "자동 형변환이 이루어진다.",
        "C": "형변환 후 객체의 타입은 변경되지 않는다.",
        "D": "잘못된 형변환은 ClassCastException을 발생시킨다."
      },
      "correctAnswer": "D"
    },
    {
      "id": "u4m49",
      "type": "mcq",
      "question": "객체 형변환 시, 부모 클래스의 참조변수에 자식 객체를 할당하는 것을 무엇이라 하는가?",
      "options": {
        "A": "다운캐스팅",
        "B": "업캐스팅",
        "C": "명시적 형변환",
        "D": "자동 형변환"
      },
      "correctAnswer": "B"
    },
    {
      "id": "u4m50",
      "type": "mcq",
      "question": "접근제한자, 다형성, 객체의 형변환 관련 개념을 종합할 때, 올바른 설명은 무엇인가?",
      "options": {
        "A": "접근제한자는 데이터 은닉, 다형성은 코드 재사용, 형변환은 객체 간 호환성을 제공한다.",
        "B": "접근제한자는 캡슐화를, 다형성은 상속을, 형변환은 메서드 오버로딩을 의미한다.",
        "C": "모든 객체는 자동으로 형변환되며, 접근제한자는 중요하지 않다.",
        "D": "접근제한자와 형변환은 다형성 구현에 아무런 영향을 주지 않는다."
      },
      "correctAnswer": "A"
    },
    {
      "id": "u4c1",
      "type": "code",
      "question": "싱글턴 디자인 패턴에서 객체 생성을 제한하기 위해, instance 필드의 접근제한자로 적절한 키워드를 채워 넣으시오.",
      "codeSnippet": "public class Singleton {\n    __ static Singleton instance = new Singleton();\n    \n    private Singleton() { }\n    \n    public static Singleton getInstance() {\n        return instance;\n    }\n}",
      "answers": ["private"]
    },
    {
      "id": "u4c2",
      "type": "code",
      "question": "싱글턴 디자인 패턴에서 생성자의 접근제한자를 설정하여 외부에서 직접 객체 생성을 방지하기 위해, 생성자 선언에 적절한 접근제한자를 채워 넣으시오.",
      "codeSnippet": "public class Singleton {\n    private static Singleton instance = new Singleton();\n    \n    __ Singleton() {\n        // 초기화 작업\n    }\n    \n    public static Singleton getInstance() {\n        return instance;\n    }\n}",
      "answers": ["private"]
    },
    {
      "id": "u4c3",
      "type": "code",
      "question": "데이터 은닉을 위해, 다음 코드에서 멤버 변수에 사용해야 하는 접근제한자를 채워 넣으시오.",
      "codeSnippet": "public class Person {\n    __ String name;\n    \n    public Person(String name) {\n        this.name = name;\n    }\n    \n    public String getName() {\n        return name;\n    }\n}",
      "answers": ["private"]
    },
    {
      "id": "u4c4",
      "type": "code",
      "question": "다음 코드에서, 입력받은 잔액을 멤버 변수에 저장하기 위한 올바른 할당문을 채워 넣으시오.",
      "codeSnippet": "public class Account {\n    private double balance;\n    \n    public double getBalance() {\n        return balance;\n    }\n    \n    public void setBalance(double balance) {\n        if (balance < 0) {\n            throw new IllegalArgumentException(\"잔액은 음수가 될 수 없습니다.\");\n        }\n        __.__ = __;\n    }\n}",
      "answers": ["this", "balance", "balance"]
    },
    {
      "id": "u4c5",
      "type": "code",
      "question": "다음 코드에서 상수를 정의하기 위해, MAX_SIZE 변수 선언에 추가되어야 하는 키워드를 채워 넣으시오.",
      "codeSnippet": "public class Constants {\n    public static __ int MAX_SIZE = 100;\n}",
      "answers": ["final"]
    },
    {
      "id": "u4c6",
      "type": "code",
      "question": "다형성을 활용하여 Animal 타입의 변수 a를 Dog 객체로 형변환 후, Dog 클래스에만 있는 메서드를 호출하는 코드에서 빈칸에 들어갈 메서드 이름을 채워 넣으시오.",
      "codeSnippet": "class Animal {\n    public void sound() {\n        System.out.println(\"Animal sound\");\n    }\n}\n\nclass Dog extends Animal {\n    public void sound() {\n        System.out.println(\"Bark\");\n    }\n    \n    public void wagTail() {\n        System.out.println(\"Wagging tail\");\n    }\n}\n\npublic class Test {\n    public static void main(String[] args) {\n        Animal a = new Dog();\n        a.sound();\n        ((Dog) a).__();\n    }\n}",
      "answers": ["wagTail"]
    },
    {
      "id": "u4c7",
      "type": "code",
      "question": "다음 코드에서 instanceof 연산자를 이용하여, Vehicle 타입의 변수 v가 Car 객체임을 확인 후, Car 클래스의 메서드를 호출하는 빈칸에 들어갈 메서드 이름을 채워 넣으시오.",
      "codeSnippet": "class Vehicle {}\nclass Car extends Vehicle {\n    public void drive() {\n        System.out.println(\"Driving\");\n    }\n}\n\npublic class Test {\n    public static void main(String[] args) {\n        Vehicle v = new Car();\n        if (v instanceof Car) {\n            Car c = (Car) v;\n            c.__();\n        }\n    }\n}",
      "answers": ["drive"]
    },
    {
      "id": "u4c8",
      "type": "code",
      "question": "다음 코드에서, 정적 메서드를 선언할 때 반드시 사용해야 하는 키워드를 채워 넣으시오.",
      "codeSnippet": "class Parent {\n    public static void display() {\n        System.out.println(\"Parent display\");\n    }\n}\n\nclass Child extends Parent {\n    public __ void display() {\n        System.out.println(\"Child display\");\n    }\n}",
      "answers": ["static"]
    },
    {
      "id": "u4c9",
      "type": "code",
      "question": "명시적 형변환을 사용하여 Object 타입의 변수 obj를 String 타입으로 변환하는 코드에서, 빈칸에 들어갈 타입 이름을 채워 넣으시오.",
      "codeSnippet": "Object obj = \"Hello\";\nString str = ( __ ) obj;\nSystem.out.println(str);",
      "answers": ["String"]
    },
    {
      "id": "u4c10",
      "type": "code",
      "question": "다형성을 활용한 메서드 호출 예제에서, 참조 변수 s를 통해 호출되는 실제 메서드 이름을 채워 넣으시오.",
      "codeSnippet": "class Shape {\n    public void draw() {\n        System.out.println(\"Drawing Shape\");\n    }\n}\n\nclass Circle extends Shape {\n    @Override\n    public void draw() {\n        System.out.println(\"Drawing Circle\");\n    }\n}\n\npublic class Test {\n    public static void main(String[] args) {\n        Shape s = new Circle();\n        s.__();\n    }\n}",
      "answers": ["draw"]
    },
    {
      "id": "u4c11",
      "type": "code",
      "question": "다음 코드에서, 멤버 변수를 외부에서 직접 접근하지 못하도록 하기 위해 적절한 접근제한자를 채워 넣으시오.",
      "codeSnippet": "public class Bank {\n    __ int accountNumber;\n    \n    public Bank(int accountNumber) {\n        this.accountNumber = accountNumber;\n    }\n}",
      "answers": ["private"]
    },
    {
      "id": "u4c12",
      "type": "code",
      "question": "다음 코드에서, lazy initialization을 위한 조건문에서 instance가 아직 생성되지 않았음을 확인하기 위해, 빈칸에 들어갈 연산자를 채워 넣으시오.",
      "codeSnippet": "public class LazySingleton {\n    private static LazySingleton instance;\n    \n    private LazySingleton() { }\n    \n    public static LazySingleton getInstance() {\n        if (instance __ null) {\n            instance = new LazySingleton();\n        }\n        return instance;\n    }\n}",
      "answers": ["=="]
    },
    {
      "id": "u4c13",
      "type": "code",
      "question": "다음 코드에서, 캡슐화 원칙을 적용하여, private 멤버 변수 id의 값을 반환하는 getter 메서드를 완성하시오.",
      "codeSnippet": "public class Student {\n    private String id;\n    \n    public Student(String id) {\n        this.id = id;\n    }\n    \n    public String getId() {\n        return __;\n    }\n}",
      "answers": ["id"]
    },
    {
      "id": "u4c14",
      "type": "code",
      "question": "다음 코드에서, 온도를 설정하기 위한 setter 메서드 내에서 멤버 변수를 올바르게 할당하기 위해 빈칸에 들어갈 변수명을 채워 넣으시오.",
      "codeSnippet": "public class Temperature {\n    private double celsius;\n    \n    public void setCelsius(double celsius) {\n        if (celsius < -273.15) {\n            throw new IllegalArgumentException(\"온도는 절대 영도보다 낮을 수 없습니다.\");\n        }\n        this.__ = celsius;\n    }\n}",
      "answers": ["celsius"]
    },
    {
      "id": "u4c15",
      "type": "code",
      "question": "다음 코드에서, 자식 클래스에서 부모 클래스의 protected 메서드를 호출하기 위해, 빈칸에 들어갈 메서드 이름을 채워 넣으시오.",
      "codeSnippet": "class Parent {\n    protected void display() {\n        System.out.println(\"Parent display\");\n    }\n}\n\nclass Child extends Parent {\n    public void show() {\n        __();\n    }\n}",
      "answers": ["display"]
    },
    {
      "id": "u4c16",
      "type": "code",
      "question": "다음 코드에서, 객체 생성 없이 클래스 이름을 통해 정적 메서드를 호출하기 위해, 빈칸에 들어갈 메서드 이름을 채워 넣으시오.",
      "codeSnippet": "public class MathUtil {\n    public static int add(int a, int b) {\n        return a + b;\n    }\n}\n\npublic class Test {\n    public static void main(String[] args) {\n        int sum = MathUtil.__(3, 4);\n        System.out.println(sum);\n    }\n}",
      "answers": ["add"]
    },
    {
      "id": "u4c17",
      "type": "code",
      "question": "다음 코드에서, 다형성을 활용하여 자식 클래스의 오버라이딩된 메서드가 호출되도록 하기 위해, 빈칸에 들어갈 메서드 이름을 채워 넣으시오.",
      "codeSnippet": "class Vehicle {\n    public void move() {\n        System.out.println(\"Vehicle moves\");\n    }\n}\n\nclass Bike extends Vehicle {\n    @Override\n    public void move() {\n        System.out.println(\"Bike moves\");\n    }\n}\n\npublic class Test {\n    public static void main(String[] args) {\n        Vehicle v = new Bike();\n        v.__();\n    }\n}",
      "answers": ["move"]
    },
    {
      "id": "u4c18",
      "type": "code",
      "question": "다음 코드에서, instanceof 연산자를 사용하여 obj가 Integer 타입임을 확인하기 위해, 빈칸에 들어갈 타입명을 채워 넣으시오.",
      "codeSnippet": "public class Test {\n    public static void main(String[] args) {\n        Object obj = new Integer(10);\n        if (obj instanceof __) {\n            Integer num = (Integer) obj;\n            System.out.println(num);\n        }\n    }\n}",
      "answers": ["Integer"]
    },
    {
      "id": "u4c19",
      "type": "code",
      "question": "다음 코드에서, 다형성을 활용하여 부모 클래스 타입의 변수 f를 통해 호출되는 메서드 이름을 채워 넣으시오.",
      "codeSnippet": "class Fruit {\n    public void taste() {\n        System.out.println(\"Generic fruit taste\");\n    }\n}\n\nclass Apple extends Fruit {\n    @Override\n    public void taste() {\n        System.out.println(\"Sweet apple\");\n    }\n}\n\npublic class Test {\n    public static void main(String[] args) {\n        Apple a = new Apple();\n        Fruit f = a; // upcasting\n        f.__();\n    }\n}",
      "answers": ["taste"]
    },
    {
      "id": "u4c20",
      "type": "code",
      "question": "다음 Singleton 패턴 구현 예제에서, 멤버 변수 SIZE의 초기화 순서를 보장하기 위해, 빈칸에 들어갈 키워드를 채워 넣으시오.",
      "codeSnippet": "public class Singleton {\n    public __ static int SIZE = 10;\n    private int[] array;\n    \n    private static Singleton instance = new Singleton();\n    \n    private Singleton() {\n        array = new int[SIZE];\n    }\n    \n    public static Singleton getInstance() {\n        return instance;\n    }\n    \n    public int getArrayLength() {\n        return array.length;\n    }\n}",
      "answers": ["final"]
    },
    {
      "id": "u4c21",
      "type": "code",
      "question": "다음 생성자에서, 멤버 변수와 매개변수를 구분하기 위해 빈칸에 들어갈 키워드를 채워 넣으시오.",
      "codeSnippet": "public class Person {\n    private String name;\n    \n    public Person(String name) {\n        __.name = name;\n    }\n}",
      "answers": ["this"]
    },
    {
      "id": "u4c22",
      "type": "code",
      "question": "데이터 보호를 위해, 멤버 변수 password의 접근제한자로 적절한 키워드를 채워 넣으시오.",
      "codeSnippet": "public class User {\n    __ String password;\n    \n    public String getPassword() {\n        return password;\n    }\n}",
      "answers": ["private"]
    },
    {
      "id": "u4c23",
      "type": "code",
      "question": "JDK 16부터 도입된 instanceof 패턴 매칭 문법을 사용하여, obj가 String 타입일 때 변수를 s로 선언하는 코드에서 빈칸에 들어갈 내용을 채워 넣으시오.",
      "codeSnippet": "public class Test {\n    public static void main(String[] args) {\n        Object obj = \"Hello\";\n        if (obj instanceof __) {\n            System.out.println(s.length());\n        }\n    }\n}",
      "answers": ["String s"]
    },
    {
      "id": "u4c24",
      "type": "code",
      "question": "다음 코드에서, 자식 클래스 Dog의 생성자에서 부모 클래스의 생성자를 호출하기 위해, 빈칸에 들어갈 키워드를 채워 넣으시오.",
      "codeSnippet": "class Animal {\n    public Animal(String name) {\n        System.out.println(\"Animal: \" + name);\n    }\n}\n\nclass Dog extends Animal {\n    public Dog(String name) {\n        __(name);\n    }\n}",
      "answers": ["super"]
    },
    {
      "id": "u4c25",
      "type": "code",
      "question": "다음 코드에서, 메서드 오버라이딩 시 부모 클래스보다 접근 제한자를 축소할 수 없음을 보이기 위해, 빈칸에 들어갈 키워드를 채워 넣으시오.",
      "codeSnippet": "class Base {\n    public void perform() {\n        System.out.println(\"Base perform\");\n    }\n}\n\nclass Derived extends Base {\n    __ void perform() {\n        System.out.println(\"Derived perform\");\n    }\n}",
      "answers": ["public"]
    },
    {
      "id": "u4s1",
      "type": "subjective",
      "question": "자바의 접근제한자(public, protected, default, private)의 차이점과 각각의 용도를 설명하시오.",
      "correctAnswer": "public: 모든 곳에서 접근 가능, protected: 같은 패키지와 자식 클래스에서 접근 가능, default: 같은 패키지 내에서만, private: 클래스 내부에서만 접근 가능하다."
    },
    {
      "id": "u4s2",
      "type": "subjective",
      "question": "다형성(polymorphism)의 개념과 이를 활용한 객체지향 프로그래밍의 장점을 설명하시오.",
      "correctAnswer": "다형성은 하나의 인터페이스로 여러 종류의 객체를 처리할 수 있게 하여 코드 재사용성과 확장성을 높인다."
    },
    {
      "id": "u4s3",
      "type": "subjective",
      "question": "객체 형변환(upcasting과 downcasting)의 차이점과 주의할 점에 대해 서술하시오.",
      "correctAnswer": "업캐스팅은 자동으로 이루어지며 안정적이지만, 다운캐스팅은 명시적으로 수행해야 하며 실제 객체 타입과 일치하지 않으면 ClassCastException이 발생할 수 있다."
    },
    {
      "id": "u4s4",
      "type": "subjective",
      "question": "접근제한자를 활용하여 캡슐화를 구현하는 방법과 그 장점을 설명하시오.",
      "correctAnswer": "멤버 변수를 private으로 선언하고 public getter/setter를 제공하여 데이터 보호와 내부 구현 변경에 따른 외부 영향 최소화를 이룬다."
    },
    {
      "id": "u4s5",
      "type": "subjective",
      "question": "다형성을 통해 객체를 다루는 방법과 그로 인한 코드 확장성의 이점을 설명하시오.",
      "correctAnswer": "부모 클래스 타입의 참조변수로 자식 객체를 다루면, 새로운 객체 추가 시 기존 코드를 수정할 필요 없이 다형성을 활용하여 유연하게 처리할 수 있다."
    },
    {
      "id": "u4s6",
      "type": "subjective",
      "question": "객체 형변환 시 명시적 형변환의 문법과 주의사항에 대해 서술하시오.",
      "correctAnswer": "명시적 형변환은 (타입) 객체 형태로 사용하며, 실제 객체 타입과 일치하지 않으면 ClassCastException이 발생할 수 있으므로 instanceof 연산자로 안전성을 확인해야 한다."
    },
    {
      "id": "u4s7",
      "type": "subjective",
      "question": "정적 메서드와 인스턴스 메서드의 차이점과 사용 목적에 대해 설명하시오.",
      "correctAnswer": "정적 메서드는 클래스 수준에서 호출되며 객체 상태에 의존하지 않고, 인스턴스 메서드는 객체별로 호출되어 해당 객체의 상태를 처리한다."
    },
    {
      "id": "u4s8",
      "type": "subjective",
      "question": "객체 형변환이 다형성 구현에 미치는 역할과 그 중요성에 대해 논하시오.",
      "correctAnswer": "형변환을 통해 부모 클래스 참조변수로 자식 객체를 다루면 런타임 다형성이 구현되어 다양한 객체의 동작을 통일적으로 처리할 수 있다."
    },
    {
      "id": "u4s9",
      "type": "subjective",
      "question": "접근제한자를 올바르게 사용함으로써 얻을 수 있는 보안상의 이점에 대해 서술하시오.",
      "correctAnswer": "접근제한자는 내부 데이터에 대한 직접 접근을 막아 데이터 무결성과 보안을 강화하며, 외부의 잘못된 접근으로부터 객체를 보호한다."
    },
    {
      "id": "u4s10",
      "type": "subjective",
      "question": "업캐스팅과 다운캐스팅의 사용 시 주의사항 및 그 필요성에 대해 설명하시오.",
      "correctAnswer": "업캐스팅은 자동으로 이루어지지만, 다운캐스팅은 명시적으로 수행해야 하며 실제 객체 타입을 확인하여 안전하게 형변환해야 한다."
    },
    {
      "id": "u4s11",
      "type": "subjective",
      "question": "다형성이 소프트웨어 유지보수에 미치는 긍정적 효과에 대해 설명하시오.",
      "correctAnswer": "다형성을 사용하면 인터페이스를 통해 여러 클래스의 동작을 통일시킬 수 있어, 기능 확장이나 수정 시 기존 코드를 최소한으로 변경할 수 있다."
    },
    {
      "id": "u4s12",
      "type": "subjective",
      "question": "접근제한자 default의 의미와 사용 시 주의사항에 대해 서술하시오.",
      "correctAnswer": "default 접근제한자는 명시적으로 접근제한자를 지정하지 않은 경우로, 같은 패키지 내에서만 접근 가능하므로 패키지 구성에 주의해야 한다."
    },
    {
      "id": "u4s13",
      "type": "subjective",
      "question": "객체의 형변환이 잘못되었을 때 발생하는 문제와 그 해결 방법에 대해 설명하시오.",
      "correctAnswer": "잘못된 형변환은 ClassCastException을 발생시키며, 이를 방지하기 위해 instanceof 연산자를 사용하여 객체 타입을 확인한 후 명시적 형변환을 수행해야 한다."
    },
    {
      "id": "u4s14",
      "type": "subjective",
      "question": "정적 멤버 변수와 인스턴스 멤버 변수의 차이점 및 각각의 장단점에 대해 설명하시오.",
      "correctAnswer": "정적 멤버 변수는 클래스 전체에서 공유되며 메모리 사용을 줄이지만, 객체별 개별 상태 표현이 어렵고, 인스턴스 멤버 변수는 각 객체마다 개별적으로 존재하여 고유 상태를 표현할 수 있다."
    },
    {
      "id": "u4s15",
      "type": "subjective",
      "question": "객체의 형변환과 관련된 문법적 특징 및 주의사항에 대해 서술하시오.",
      "correctAnswer": "객체 형변환은 (타입) 객체 형태로 수행되며, 실제 객체 타입과 일치하지 않으면 ClassCastException이 발생할 수 있으므로, 반드시 instanceof 연산자로 확인해야 한다."
    },
    {
      "id": "u4s16",
      "type": "subjective",
      "question": "다형성을 구현하기 위해 부모 클래스의 메서드를 오버라이딩하는 것이 왜 중요한지 설명하시오.",
      "correctAnswer": "오버라이딩을 통해 자식 클래스는 부모 클래스의 메서드를 자신의 방식으로 재정의하여, 런타임에 올바른 메서드가 호출되도록 함으로써 다형성을 구현한다."
    },
    {
      "id": "u4s17",
      "type": "subjective",
      "question": "접근제한자와 캡슐화가 객체지향 프로그래밍에 미치는 긍정적 효과에 대해 설명하시오.",
      "correctAnswer": "접근제한자는 클래스 내부의 데이터를 외부로부터 보호하여 캡슐화를 구현하고, 이를 통해 코드의 안정성과 보안이 강화된다."
    },
    {
      "id": "u4s18",
      "type": "subjective",
      "question": "업캐스팅과 다운캐스팅의 개념 및 각각의 사용 사례에 대해 서술하시오.",
      "correctAnswer": "업캐스팅은 자식 객체를 부모 타입으로 변환하여 공통 기능을 호출하는 데 유리하며, 다운캐스팅은 자식 클래스의 고유 기능을 사용하기 위해 명시적으로 수행된다."
    },
    {
      "id": "u4s19",
      "type": "subjective",
      "question": "자바에서 static 메서드가 가지는 특징과 그 한계에 대해 설명하시오.",
      "correctAnswer": "static 메서드는 객체 생성 없이 클래스 이름으로 호출되지만, 객체 상태에 접근할 수 없어 인스턴스별 동작 구현에 한계가 있다."
    },
    {
      "id": "u4s20",
      "type": "subjective",
      "question": "객체의 형변환을 통해 다형성을 구현하는 과정과 그 중요성에 대해 서술하시오.",
      "correctAnswer": "형변환을 통해 부모 클래스 참조변수에 자식 객체를 할당하면, 런타임 다형성이 구현되어 다양한 객체의 특성에 따라 적절한 메서드가 호출된다."
    },
    {
      "id": "u4s21",
      "type": "subjective",
      "question": "접근제한자, 다형성, 객체 형변환 개념이 소프트웨어 설계에 미치는 전반적인 영향을 정리하시오.",
      "correctAnswer": "이들 개념은 데이터 보호, 코드 재사용, 확장성 및 유지보수성을 향상시켜, 견고하고 유연한 소프트웨어 설계를 가능하게 한다."
    },
    {
      "id": "u4s22",
      "type": "subjective",
      "question": "객체 형변환에서 발생할 수 있는 오류와 이를 방지하기 위한 방법을 설명하시오.",
      "correctAnswer": "잘못된 형변환은 ClassCastException을 발생시킬 수 있으므로, 반드시 instanceof 연산자로 타입을 확인한 후 명시적 형변환을 수행해야 한다."
    },
    {
      "id": "u4s23",
      "type": "subjective",
      "question": "접근제한자의 적절한 사용이 클래스 간 결합도를 어떻게 낮추는지 설명하시오.",
      "correctAnswer": "접근제한자를 사용하면 클래스 내부의 구현을 감추고, 외부에는 필요한 인터페이스만 노출되어 결합도가 낮아진다."
    },
    {
      "id": "u4s24",
      "type": "subjective",
      "question": "다형성과 객체 형변환을 통해 얻을 수 있는 코드 확장성의 이점을 구체적인 예와 함께 설명하시오.",
      "correctAnswer": "부모 클래스 참조변수로 여러 자식 객체를 처리하면, 새로운 클래스 추가 시 기존 코드를 수정하지 않고 확장이 가능해진다."
    },
    {
      "id": "u4s25",
      "type": "subjective",
      "question": "접근제한자, 다형성, 객체 형변환 개념이 객체지향 프로그래밍 전반에 미치는 긍정적 효과를 요약하시오.",
      "correctAnswer": "이들 개념은 데이터 보호, 코드 재사용 및 확장을 가능하게 하여, 유지보수가 쉽고 유연한 소프트웨어 설계를 지원한다."
    }
  ],
  "unit5": [
    {
      "id": "u5m1",
      "type": "mcq",
      "question": "추상 클래스란 무엇인가?",
      "options": {
        "A": "인스턴스화할 수 없는 클래스",
        "B": "모든 메서드가 구현된 클래스",
        "C": "객체 생성이 가능한 클래스",
        "D": "오직 정적 메서드만 가진 클래스"
      },
      "correctAnswer": "A"
    },
    {
      "id": "u5m2",
      "type": "mcq",
      "question": "인터페이스란 무엇인가?",
      "options": {
        "A": "모든 메서드가 디폴트 메서드인 클래스",
        "B": "모든 메서드가 추상 메서드이며, 상수 필드만 포함하는 타입",
        "C": "객체 생성이 가능한 클래스",
        "D": "메서드 구현과 인스턴스 필드를 모두 포함하는 클래스"
      },
      "correctAnswer": "B"
    },
    {
      "id": "u5m3",
      "type": "mcq",
      "question": "추상 클래스와 인터페이스의 주요 차이점은 무엇인가?",
      "options": {
        "A": "추상 클래스는 다중 상속이 가능하다.",
        "B": "인터페이스는 모든 메서드가 구현되어 있다.",
        "C": "추상 클래스는 상태(멤버 변수)를 가질 수 있으나, 인터페이스는 상수만 가질 수 있다.",
        "D": "인터페이스는 객체 생성이 가능하다."
      },
      "correctAnswer": "C"
    },
    {
      "id": "u5m4",
      "type": "mcq",
      "question": "자바 8 이후 인터페이스에 추가된 기능은 무엇인가?",
      "options": {
        "A": "추상 메서드만 선언 가능하다.",
        "B": "정적 메서드만 추가되었다.",
        "C": "디폴트 메서드가 추가되었다.",
        "D": "디폴트 메서드와 정적 메서드가 모두 추가되었다."
      },
      "correctAnswer": "D"
    },
    {
      "id": "u5m5",
      "type": "mcq",
      "question": "추상 메서드를 포함한 클래스는 반드시 어떤 키워드로 선언되어야 하는가?",
      "options": {
        "A": "abstract",
        "B": "final",
        "C": "static",
        "D": "private"
      },
      "correctAnswer": "A"
    },
    {
      "id": "u5m6",
      "type": "mcq",
      "question": "인터페이스의 필드는 기본적으로 어떤 성질을 가지는가?",
      "options": {
        "A": "인스턴스 변수",
        "B": "public static final 상수",
        "C": "private 변수",
        "D": "변경 가능한 변수"
      },
      "correctAnswer": "B"
    },
    {
      "id": "u5m7",
      "type": "mcq",
      "question": "추상 클래스는 왜 인스턴스화할 수 없는가?",
      "options": {
        "A": "모든 메서드가 구현되어 있기 때문이다.",
        "B": "객체 생성이 메모리 부족으로 불가능하다.",
        "C": "미완성인 추상 메서드를 포함하고 있기 때문이다.",
        "D": "모든 멤버가 정적이기 때문이다."
      },
      "correctAnswer": "C"
    },
    {
      "id": "u5m8",
      "type": "mcq",
      "question": "인터페이스에 디폴트 메서드를 추가한 주된 목적은 무엇인가?",
      "options": {
        "A": "기존 인터페이스를 모두 제거하기 위해",
        "B": "모든 클래스를 강제 구현하게 하기 위해",
        "C": "메서드 오버라이딩을 제한하기 위해",
        "D": "기존 인터페이스를 변경하지 않고도 새로운 메서드를 추가할 수 있도록 하기 위해"
      },
      "correctAnswer": "D"
    },
    {
      "id": "u5m9",
      "type": "mcq",
      "question": "왜 추상 클래스는 인스턴스화할 수 없는가?",
      "options": {
        "A": "추상 메서드를 포함하여 완전한 구현이 없기 때문이다.",
        "B": "메모리 할당이 불가능하기 때문이다.",
        "C": "모든 메서드가 정적이기 때문이다.",
        "D": "인터페이스와 동일하다."
      },
      "correctAnswer": "A"
    },
    {
      "id": "u5m10",
      "type": "mcq",
      "question": "인터페이스는 다중 구현이 가능한 이유는 무엇인가?",
      "options": {
        "A": "자바는 다중 상속을 지원하기 때문이다.",
        "B": "자바는 다중 상속을 지원하지 않지만, 다중 인터페이스 구현은 가능하기 때문이다.",
        "C": "인터페이스는 클래스와 동일하게 동작하기 때문이다.",
        "D": "모든 인터페이스는 자동으로 추상 클래스가 된다."
      },
      "correctAnswer": "B"
    },
    {
      "id": "u5m11",
      "type": "mcq",
      "question": "추상 클래스에서 추상 메서드는 어떻게 선언되는가?",
      "options": {
        "A": "구현부를 포함한 메서드로 선언된다.",
        "B": "정적 메서드로 선언된다.",
        "C": "구현부 없이 선언만 된다.",
        "D": "일반 메서드와 동일하게 선언된다."
      },
      "correctAnswer": "C"
    },
    {
      "id": "u5m12",
      "type": "mcq",
      "question": "인터페이스에 선언된 메서드의 기본 접근제한자는 무엇인가?",
      "options": {
        "A": "private",
        "B": "default",
        "C": "protected",
        "D": "public abstract"
      },
      "correctAnswer": "D"
    },
    {
      "id": "u5m13",
      "type": "mcq",
      "question": "추상 클래스와 인터페이스 중 상태(멤버 변수)를 가질 수 있는 것은?",
      "options": {
        "A": "추상 클래스",
        "B": "인터페이스",
        "C": "둘 다",
        "D": "둘 다 불가능하다"
      },
      "correctAnswer": "A"
    },
    {
      "id": "u5m14",
      "type": "mcq",
      "question": "인터페이스는 다중 상속이 가능한가?",
      "options": {
        "A": "아니요, 불가능하다.",
        "B": "예, 여러 인터페이스를 구현할 수 있다.",
        "C": "조건부로 가능하다.",
        "D": "인터페이스는 상속이 불가능하다."
      },
      "correctAnswer": "B"
    },
    {
      "id": "u5m15",
      "type": "mcq",
      "question": "추상 클래스의 생성자는 주로 어떤 역할을 하는가?",
      "options": {
        "A": "객체 생성을 금지한다.",
        "B": "정적 메서드를 초기화한다.",
        "C": "객체의 상태를 초기화한다.",
        "D": "메모리를 해제한다."
      },
      "correctAnswer": "C"
    },
    {
      "id": "u5m16",
      "type": "mcq",
      "question": "자바 인터페이스는 왜 다중 구현이 가능한가?",
      "options": {
        "A": "인터페이스는 추상 클래스와 동일하기 때문이다.",
        "B": "클래스의 다중 상속이 가능하기 때문이다.",
        "C": "인터페이스는 상속이 불가능하다.",
        "D": "자바는 다중 상속을 지원하지 않지만, 인터페이스는 다중 구현이 가능하기 때문이다."
      },
      "correctAnswer": "D"
    },
    {
      "id": "u5m17",
      "type": "mcq",
      "question": "추상 클래스의 추상 메서드는 반드시 어떤 키워드로 선언되어야 하는가?",
      "options": {
        "A": "final",
        "B": "static",
        "C": "abstract",
        "D": "private"
      },
      "correctAnswer": "C"
    },
    {
      "id": "u5m18",
      "type": "mcq",
      "question": "인터페이스에서 정적 메서드의 도입 목적은 무엇인가?",
      "options": {
        "A": "모든 메서드를 추상화하기 위해",
        "B": "인터페이스 내에서 유틸리티 메서드를 제공하기 위해",
        "C": "객체 생성 없이 메서드를 호출하기 위해",
        "D": "메서드 오버라이딩을 가능하게 하기 위해"
      },
      "correctAnswer": "B"
    },
    {
      "id": "u5m19",
      "type": "mcq",
      "question": "추상 클래스와 인터페이스의 공통점은 무엇인가?",
      "options": {
        "A": "둘 다 인스턴스화할 수 있다.",
        "B": "둘 다 모든 메서드를 구현해야 한다.",
        "C": "둘 다 직접 인스턴스화할 수 없다.",
        "D": "둘 다 상속이 불가능하다."
      },
      "correctAnswer": "C"
    },
    {
      "id": "u5m20",
      "type": "mcq",
      "question": "인터페이스의 메서드는 기본적으로 어떤 성격을 갖는가?",
      "options": {
        "A": "구현부를 포함한다.",
        "B": "디폴트 메서드만 포함한다.",
        "C": "정적 메서드만 포함한다.",
        "D": "추상 메서드이다."
      },
      "correctAnswer": "D"
    },
    {
      "id": "u5m21",
      "type": "mcq",
      "question": "추상 클래스가 인스턴스화할 수 없는 이유는 무엇인가?",
      "options": {
        "A": "추상 메서드를 포함하고 있기 때문이다.",
        "B": "모든 메서드가 정적이기 때문이다.",
        "C": "인터페이스와 동일하기 때문이다.",
        "D": "클래스 상속이 불가능하기 때문이다."
      },
      "correctAnswer": "A"
    },
    {
      "id": "u5m22",
      "type": "mcq",
      "question": "인터페이스는 왜 객체 생성이 불가능한가?",
      "options": {
        "A": "모든 메서드가 구현되어 있기 때문이다.",
        "B": "추상 메서드와 상수만 포함하기 때문이다.",
        "C": "상속받은 클래스가 없기 때문이다.",
        "D": "컴파일러가 자동으로 인터페이스로 변환하기 때문이다."
      },
      "correctAnswer": "B"
    },
    {
      "id": "u5m23",
      "type": "mcq",
      "question": "자바 9 이후 인터페이스에서 추가된 기능 중 하나는 무엇인가?",
      "options": {
        "A": "정적 필드의 추가",
        "B": "디폴트 메서드의 제거",
        "C": "private 메서드의 추가",
        "D": "추상 메서드의 자동 구현"
      },
      "correctAnswer": "C"
    },
    {
      "id": "u5m24",
      "type": "mcq",
      "question": "추상 클래스의 주요 목적은 무엇인가?",
      "options": {
        "A": "객체 생성을 위해",
        "B": "모든 메서드를 구현하기 위해",
        "C": "상태를 감추기 위해",
        "D": "공통 기능을 정의하고, 일부 메서드를 추상화하여 하위 클래스에서 구현하도록 하기 위해"
      },
      "correctAnswer": "D"
    },
    {
      "id": "u5m25",
      "type": "mcq",
      "question": "인터페이스를 구현하는 클래스는 반드시 어떤 메서드를 구현해야 하는가?",
      "options": {
        "A": "모든 디폴트 메서드",
        "B": "모든 정적 메서드",
        "C": "모든 추상 메서드",
        "D": "모든 private 메서드"
      },
      "correctAnswer": "C"
    },
    {
      "id": "u5m26",
      "type": "mcq",
      "question": "추상 클래스와 인터페이스의 상속 관계에서 인터페이스는 어떤 상속을 지원하는가?",
      "options": {
        "A": "단일 상속만 지원한다.",
        "B": "다중 상속을 지원한다.",
        "C": "상속을 지원하지 않는다.",
        "D": "자동 상속된다."
      },
      "correctAnswer": "B"
    },
    {
      "id": "u5m27",
      "type": "mcq",
      "question": "인터페이스 내에서 선언된 필드는 반드시 어떤 성질을 가져야 하는가?",
      "options": {
        "A": "변경 가능하다.",
        "B": "인스턴스 변수이다.",
        "C": "public static final이다.",
        "D": "private이다."
      },
      "correctAnswer": "C"
    },
    {
      "id": "u5m28",
      "type": "mcq",
      "question": "추상 클래스가 일반 클래스보다 갖는 주요 장점은 무엇인가?",
      "options": {
        "A": "더 빠른 실행 속도",
        "B": "더 적은 메모리 사용",
        "C": "객체 생성이 자유롭다",
        "D": "공통 기능을 미리 구현하여 코드 재사용을 촉진한다"
      },
      "correctAnswer": "D"
    },
    {
      "id": "u5m29",
      "type": "mcq",
      "question": "인터페이스에 디폴트 메서드를 사용하면 얻을 수 있는 이점은 무엇인가?",
      "options": {
        "A": "기존 인터페이스를 변경하지 않고 새로운 기능을 추가할 수 있다.",
        "B": "객체 생성 속도가 빨라진다.",
        "C": "메모리 사용량이 줄어든다.",
        "D": "모든 메서드가 자동으로 구현된다."
      },
      "correctAnswer": "A"
    },
    {
      "id": "u5m30",
      "type": "mcq",
      "question": "추상 클래스의 생성자는 주로 어떤 역할을 수행하는가?",
      "options": {
        "A": "객체를 반환한다.",
        "B": "객체의 초기화를 담당한다.",
        "C": "메서드를 오버라이딩한다.",
        "D": "정적 멤버를 초기화한다."
      },
      "correctAnswer": "B"
    },
    {
      "id": "u5m31",
      "type": "mcq",
      "question": "인터페이스에서 선언된 메서드는 기본적으로 어떤 형태로 선언되는가?",
      "options": {
        "A": "구현부가 포함된 메서드",
        "B": "디폴트 메서드만",
        "C": "추상 메서드로 선언된다",
        "D": "정적 메서드만"
      },
      "correctAnswer": "C"
    },
    {
      "id": "u5m32",
      "type": "mcq",
      "question": "자바에서 인터페이스의 다중 구현이 가능한 이유는 무엇인가?",
      "options": {
        "A": "인터페이스는 클래스와 동일하다.",
        "B": "메모리 절약 효과가 있다.",
        "C": "인터페이스는 단일 상속만 지원한다.",
        "D": "자바는 다중 상속을 허용하지 않지만, 인터페이스는 다중 구현이 가능하다."
      },
      "correctAnswer": "D"
    },
    {
      "id": "u5m33",
      "type": "mcq",
      "question": "추상 클래스의 추상 메서드는 반드시 어떤 키워드로 선언되어야 하는가?",
      "options": {
        "A": "final",
        "B": "static",
        "C": "abstract",
        "D": "private"
      },
      "correctAnswer": "C"
    },
    {
      "id": "u5m34",
      "type": "mcq",
      "question": "인터페이스에서 정적 메서드의 도입 목적은 무엇인가?",
      "options": {
        "A": "모든 메서드를 추상화하기 위해",
        "B": "인터페이스 내에서 유틸리티 메서드를 제공하기 위해",
        "C": "객체 생성 없이 메서드를 호출하기 위해",
        "D": "메서드 오버라이딩을 가능하게 하기 위해"
      },
      "correctAnswer": "B"
    },
    {
      "id": "u5m35",
      "type": "mcq",
      "question": "추상 클래스와 인터페이스의 공통점은 무엇인가?",
      "options": {
        "A": "둘 다 인스턴스화할 수 있다.",
        "B": "둘 다 모든 메서드가 구현되어 있다.",
        "C": "둘 다 직접 인스턴스화할 수 없다.",
        "D": "둘 다 상속이 불가능하다."
      },
      "correctAnswer": "C"
    },
    {
      "id": "u5m36",
      "type": "mcq",
      "question": "인터페이스에서 모든 필드는 암시적으로 어떤 성질을 갖는가?",
      "options": {
        "A": "non-static",
        "B": "변경 가능하다",
        "C": "인스턴스 변수이다",
        "D": "public static final"
      },
      "correctAnswer": "D"
    },
    {
      "id": "u5m37",
      "type": "mcq",
      "question": "추상 클래스의 주요 목적은 무엇인가?",
      "options": {
        "A": "공통 기능의 정의와 일부 메서드의 추상화를 통해 하위 클래스에서 구현을 강제하기 위해",
        "B": "객체 생성 시간을 단축하기 위해",
        "C": "메모리 사용량을 줄이기 위해",
        "D": "모든 메서드를 자동으로 구현하기 위해"
      },
      "correctAnswer": "A"
    },
    {
      "id": "u5m38",
      "type": "mcq",
      "question": "추상 클래스와 인터페이스의 차이점 중 올바른 설명은 무엇인가?",
      "options": {
        "A": "인터페이스는 객체 생성이 가능하다.",
        "B": "추상 클래스는 상태(멤버 변수)를 가질 수 있으나, 인터페이스는 상수만 가질 수 있다.",
        "C": "둘 다 모든 메서드를 추상적으로 선언한다.",
        "D": "추상 클래스는 다중 상속을 지원한다."
      },
      "correctAnswer": "B"
    },
    {
      "id": "u5m39",
      "type": "mcq",
      "question": "인터페이스를 구현하는 클래스는 반드시 무엇을 구현해야 하는가?",
      "options": {
        "A": "디폴트 메서드",
        "B": "정적 메서드",
        "C": "추상 메서드",
        "D": "모든 멤버 변수"
      },
      "correctAnswer": "C"
    },
    {
      "id": "u5m40",
      "type": "mcq",
      "question": "추상 클래스와 인터페이스를 사용하는 공통 목표는 무엇인가?",
      "options": {
        "A": "객체 생성을 위한 메모리 확보",
        "B": "데이터 보호",
        "C": "메모리 최적화",
        "D": "코드 재사용과 다형성 구현"
      },
      "correctAnswer": "D"
    },
    {
      "id": "u5m41",
      "type": "mcq",
      "question": "자바 인터페이스의 메서드는 기본적으로 어떤 성격을 갖는가?",
      "options": {
        "A": "추상 메서드",
        "B": "디폴트 메서드",
        "C": "정적 메서드",
        "D": "구현이 포함된 메서드"
      },
      "correctAnswer": "A"
    },
    {
      "id": "u5m42",
      "type": "mcq",
      "question": "추상 클래스는 일반 클래스와 달리 어떤 특징을 갖는가?",
      "options": {
        "A": "모든 메서드가 정적이다.",
        "B": "인스턴스화할 수 없다.",
        "C": "모든 필드가 final이다.",
        "D": "모든 메서드가 추상 메서드이다."
      },
      "correctAnswer": "B"
    },
    {
      "id": "u5m43",
      "type": "mcq",
      "question": "인터페이스에서 구현된 디폴트 메서드는 무엇을 가능하게 하는가?",
      "options": {
        "A": "기존 인터페이스를 모두 제거한다.",
        "B": "모든 메서드를 강제로 구현하게 한다.",
        "C": "기존 인터페이스를 변경하지 않고도 새로운 기능을 추가할 수 있게 한다.",
        "D": "추상 메서드로 자동 변환된다."
      },
      "correctAnswer": "C"
    },
    {
      "id": "u5m44",
      "type": "mcq",
      "question": "추상 클래스에서 일반 메서드와 추상 메서드를 동시에 정의할 수 있는가?",
      "options": {
        "A": "불가능하다.",
        "B": "가능하지만 모든 메서드를 추상으로 선언해야 한다.",
        "C": "가능하다, 단 추상 메서드는 반드시 abstract 키워드를 사용해야 한다.",
        "D": "가능하며, 일반 메서드는 구현을 포함할 수 있다."
      },
      "correctAnswer": "D"
    },
    {
      "id": "u5m45",
      "type": "mcq",
      "question": "자바 9 이후 인터페이스에 새로 추가된 기능 중 하나는 무엇인가?",
      "options": {
        "A": "private 메서드",
        "B": "추상 생성자",
        "C": "인스턴스 필드",
        "D": "정적 블록"
      },
      "correctAnswer": "A"
    },
    {
      "id": "u5m46",
      "type": "mcq",
      "question": "추상 클래스와 인터페이스를 선택할 때 고려해야 할 주요 요소는 무엇인가?",
      "options": {
        "A": "메모리 사용량",
        "B": "코드 재사용 및 확장성",
        "C": "컴파일 속도",
        "D": "오버라이딩의 유무"
      },
      "correctAnswer": "B"
    },
    {
      "id": "u5m47",
      "type": "mcq",
      "question": "인터페이스를 구현하는 클래스는 반드시 어떤 메서드를 구현해야 하는가?",
      "options": {
        "A": "디폴트 메서드",
        "B": "정적 메서드",
        "C": "추상 메서드",
        "D": "private 메서드"
      },
      "correctAnswer": "C"
    },
    {
      "id": "u5m48",
      "type": "mcq",
      "question": "왜 추상 클래스는 인스턴스화할 수 없는가?",
      "options": {
        "A": "모든 메서드가 구현되어 있기 때문이다.",
        "B": "메모리 부족 문제 때문이다.",
        "C": "컴파일러가 이를 금지하기 때문이다.",
        "D": "추상 메서드를 포함하여 완전한 구현이 없기 때문이다."
      },
      "correctAnswer": "D"
    },
    {
      "id": "u5m49",
      "type": "mcq",
      "question": "자바에서 인터페이스의 다중 구현이 가능한 이유는 무엇인가?",
      "options": {
        "A": "자바가 클래스의 다중 상속을 허용하기 때문이다.",
        "B": "인터페이스는 추상 클래스와 동일하다.",
        "C": "인터페이스는 모든 메서드가 디폴트이다.",
        "D": "자바는 다중 상속을 허용하지 않지만, 인터페이스는 다중 구현이 가능하다."
      },
      "correctAnswer": "D"
    },
    {
      "id": "u5m50",
      "type": "mcq",
      "question": "추상 클래스와 인터페이스를 활용한 객체지향 설계의 주요 목표는 무엇인가?",
      "options": {
        "A": "데이터 보호",
        "B": "메모리 최적화",
        "C": "객체 생성 시간 단축",
        "D": "코드 재사용과 다형성 구현"
      },
      "correctAnswer": "D"
    },
    {
      "id": "u5c1",
      "type": "code",
      "question": "Abstract 클래스로 선언하기 위해 클래스 선언부에 추가해야 하는 키워드를 채워 넣으시오.",
      "codeSnippet": "public __ class Vehicle {\n    // 공통 멤버와 메서드\n}",
      "answers": ["abstract"]
    },
    {
      "id": "u5c2",
      "type": "code",
      "question": "추상 메서드는 구현부가 없으므로, 메서드 선언 후 빈 구현 대신 사용할 키워드를 채워 넣으시오.",
      "codeSnippet": "public abstract class Vehicle {\n    public __ void addFuel();\n}",
      "answers": ["abstract"]
    },
    {
      "id": "u5c3",
      "type": "code",
      "question": "추상 클래스를 상속받은 자식 클래스에서, 추상 메서드를 재정의할 때 사용해야 하는 접근제한자를 채워 넣으시오.",
      "codeSnippet": "public abstract class Vehicle {\n    public abstract void addFuel();\n}\n\npublic class ElectricCar extends Vehicle {\n    @Override\n    __ void addFuel() {\n        System.out.println(\"Charging...\");\n    }\n}",
      "answers": ["public"]
    },
    {
      "id": "u5c4",
      "type": "code",
      "question": "인터페이스에서 메서드를 선언할 때, 생략 가능한 키워드 대신 명시적으로 작성할 수 있는 키워드를 채워 넣으시오.",
      "codeSnippet": "public interface Drivable {\n    ____ void drive();\n}",
      "answers": ["public", "abstract"]
    },
    {
      "id": "u5c5",
      "type": "code",
      "question": "인터페이스 내의 변수는 암묵적으로 상수로 취급되는데, 이를 명시하기 위해 추가할 수 있는 키워드를 채워 넣으시오.",
      "codeSnippet": "public interface Config {\n    ______ int TIMEOUT = 30;\n}",
      "answers": ["public", "static", "final"]
    },
    {
      "id": "u5c6",
      "type": "code",
      "question": "클래스가 인터페이스를 구현할 때 사용하는 키워드를 채워 넣으시오.",
      "codeSnippet": "public interface Flyable {\n    void fly();\n}\n\npublic class Airplane __ Flyable {\n    @Override\n    public void fly() {\n        System.out.println(\"Flying\");\n    }\n}",
      "answers": ["implements"]
    },
    {
      "id": "u5c7",
      "type": "code",
      "question": "추상 클래스 Vehicle을 상속받아, 구체적인 객체를 생성할 수 있는 DieselSUV 클래스를 사용하여 Vehicle 타입의 참조변수를 초기화하시오.",
      "codeSnippet": "public abstract class Vehicle {\n    public abstract void addFuel();\n}\n\npublic class DieselSUV extends Vehicle {\n    @Override\n    public void addFuel() {\n        System.out.println(\"Adding diesel\");\n    }\n}\n\npublic class VehicleTest {\n    public static void main(String[] args) {\n        Vehicle v = new __();\n        v.addFuel();\n    }\n}",
      "answers": ["DieselSUV"]
    },
    {
      "id": "u5c8",
      "type": "code",
      "question": "인터페이스에서 기본 메서드(default method)를 정의하기 위해 메서드 선언부에 추가할 키워드를 채워 넣으시오.",
      "codeSnippet": "public interface Operable {\n    __ void start() {\n        System.out.println(\"Starting operation\");\n    }\n}",
      "answers": ["default"]
    },
    {
      "id": "u5c9",
      "type": "code",
      "question": "인터페이스에 정의된 정적 메서드를 호출할 때 사용하는 메서드 이름을 채워 넣으시오.",
      "codeSnippet": "public interface Calculator {\n    static int add(int a, int b) {\n        return a + b;\n    }\n}\n\npublic class Test {\n    public static void main(String[] args) {\n        int sum = Calculator.__(3, 4);\n        System.out.println(sum);\n    }\n}",
      "answers": ["add"]
    },
    {
      "id": "u5c10",
      "type": "code",
      "question": "두 개 이상의 인터페이스를 구현할 때 사용하는 키워드를 채워 넣으시오.",
      "codeSnippet": "public interface Printable {\n    void print();\n}\n\npublic interface Scannable {\n    void scan();\n}\n\npublic class MultiFunctionPrinter __ Printable, Scannable {\n    @Override\n    public void print() {\n        System.out.println(\"Printing\");\n    }\n    @Override\n    public void scan() {\n        System.out.println(\"Scanning\");\n    }\n}",
      "answers": ["implements"]
    },

    {
      "id": "u5c11",
      "type": "code",
      "question": "여러 인터페이스에서 동일한 기본 메서드가 정의된 경우, 특정 인터페이스의 기본 메서드를 호출하기 위해 필요한 구문을 채워 넣으시오.",
      "codeSnippet": "public interface A {\n    default void show() {\n        System.out.println(\"A\");\n    }\n}\n\npublic interface B {\n    default void show() {\n        System.out.println(\"B\");\n    }\n}\n\npublic class Test implements A, B {\n    @Override\n    public void show() {\n        __.__.show(); // 호출: 인터페이스 A의 기본 메서드\n    }\n}\n",
      "answers": ["A", "super"]
    },
    {
      "id": "u5c12",
      "type": "code",
      "question": "추상 클래스의 메서드 호출 시, 상속받은 구체적 구현을 명시적으로 호출하기 위해 사용해야 하는 키워드를 채워 넣으시오.",
      "codeSnippet": "public abstract class Machine {\n    public void start() {\n        System.out.println(\"Machine starting\");\n    }\n    public abstract void stop();\n}\n\npublic class Computer extends Machine {\n    @Override\n    public void stop() {\n        System.out.println(\"Computer stopping\");\n    }\n    \n    public void restart() {\n        __.__; // 부모 클래스의 start() 메서드 호출\n        stop();\n    }\n}\n",
      "answers": ["super", "start()"]
    },

    {
      "id": "u5c13",
      "type": "code",
      "question": "추상 메서드 선언 시, 구현부 대신 사용해야 하는 기호를 채워 넣으시오.",
      "codeSnippet": "public abstract class Animal {\n    public abstract void makeSound() __\n}",
      "answers": [";"]
    },
    {
      "id": "u5c14",
      "type": "code",
      "question": "클래스가 인터페이스를 구현할 때, 인터페이스 이름 뒤에 추가해야 하는 키워드를 채워 넣으시오.",
      "codeSnippet": "public interface Operable {\n    void operate();\n}\n\npublic class Machine __ Operable {\n    @Override\n    public void operate() {\n        System.out.println(\"Operating machine\");\n    }\n}",
      "answers": ["implements"]
    },
    {
      "id": "u5c15",
      "type": "code",
      "question": "다형성을 활용하여, 추상 클래스의 구체적 메서드를 호출하는 예제에서 빈칸에 들어갈 메서드 이름을 채워 넣으시오.",
      "codeSnippet": "public abstract class Shape {\n    public abstract double area();\n    public void display() {\n        System.out.println(\"Displaying shape\");\n    }\n}\n\npublic class Circle extends Shape {\n    private double radius;\n    public Circle(double radius) {\n        this.radius = radius;\n    }\n    @Override\n    public double area() {\n        return Math.PI * radius * radius;\n    }\n}\n\npublic class Test {\n    public static void main(String[] args) {\n        Shape s = new Circle(5);\n        System.out.println(\"Area: \" + s.area());\n        s.__();\n    }\n}\n",
      "answers": ["display"]
    },
    {
      "id": "u5c16",
      "type": "code",
      "question": "인터페이스 상속 시, 상위 인터페이스의 메서드만 호출할 수 있는 상황에서, 변수 a로 호출 가능한 메서드를 채워 넣으시오.",
      "codeSnippet": "public interface A {\n    void methodA();\n}\npublic interface B extends A {\n    void methodB();\n}\npublic class C implements B {\n    @Override\n    public void methodA() {\n        System.out.println(\"A\");\n    }\n    @Override\n    public void methodB() {\n        System.out.println(\"B\");\n    }\n}\npublic class Test {\n    public static void main(String[] args) {\n        A a = new C();\n        a.__();\n    }\n}\n",
      "answers": ["methodA"]
    },
    {
      "id": "u5c17",
      "type": "code",
      "question": "추상 클래스를 상속받은 구체 클래스의 메서드를 호출하는 예제에서, 빈칸에 들어갈 메서드 이름을 채워 넣으시오.",
      "codeSnippet": "public abstract class Appliance {\n    public abstract void turnOn();\n}\n\npublic class Fan extends Appliance {\n    @Override\n    public void turnOn() {\n        System.out.println(\"Fan is on\");\n    }\n}\n\npublic class Test {\n    public static void main(String[] args) {\n        Appliance app = new Fan();\n        app.__();\n    }\n}\n",
      "answers": ["turnOn"]
    },
    {
      "id": "u5c18",
      "type": "code",
      "question": "여러 인터페이스에서 동일한 기본 메서드가 정의된 경우, 특정 인터페이스의 메서드를 호출하기 위한 구문을 채워 넣으시오.",
      "codeSnippet": "public interface X {\n    default void action() {\n        System.out.println(\"Action from X\");\n    }\n}\npublic interface Y {\n    default void action() {\n        System.out.println(\"Action from Y\");\n    }\n}\npublic class Z implements X, Y {\n    @Override\n    public void action() {\n        // 충돌 해결: X의 기본 메서드 호출\n        __.action();\n    }\n}\n",
      "answers": ["X.super"]
    },
    {
      "id": "u5c19",
      "type": "code",
      "question": "추상 클래스의 생성자에서, 자식 클래스의 생성자 호출을 위해 사용해야 하는 키워드를 채워 넣으시오.",
      "codeSnippet": "public abstract class Tool {\n    protected String name;\n    public Tool(String name) {\n        this.name = name;\n    }\n}\n\npublic class Hammer extends Tool {\n    public Hammer(String name) {\n        __;\n    }\n}\n",
      "answers": ["super(name)"]
    },
    {
      "id": "u5c20",
      "type": "code",
      "question": "인터페이스를 타입으로 사용하여, 구현 클래스의 메서드를 호출하는 예제에서 빈칸에 들어갈 메서드 이름을 채워 넣으시오.",
      "codeSnippet": "public interface Drivable {\n    void drive();\n}\n\npublic class Car implements Drivable {\n    @Override\n    public void drive() {\n        System.out.println(\"Car driving\");\n    }\n}\n\npublic class Test {\n    public static void main(String[] args) {\n        Drivable d = new Car();\n        d.__();\n    }\n}\n",
      "answers": ["drive"]
    },
    {
      "id": "u5c21",
      "type": "code",
      "question": "추상 클래스 Animal을 상속받은 자식 클래스에서, 추상 메서드를 재정의할 때 올바른 접근 제한자를 채워 넣으시오.",
      "codeSnippet": "public abstract class Animal {\n    public abstract void makeSound();\n}\n\npublic class Cat extends Animal {\n    @Override\n    public __ void makeSound() {\n        System.out.println(\"Meow\");\n    }\n}\n",
      "answers": ["public"]
    },
    {
      "id": "u5c22",
      "type": "code",
      "question": "인터페이스를 선언할 때, 인터페이스임을 나타내는 키워드를 채워 넣으시오.",
      "codeSnippet": "public __ Drawable {\n    void draw();\n}\n",
      "answers": ["interface"]
    },
    {
      "id": "u5c23",
      "type": "code",
      "question": "인터페이스 상속 시, 하위 인터페이스가 상위 인터페이스의 기능을 포함하도록 선언할 때 사용하는 키워드를 채워 넣으시오.",
      "codeSnippet": "public interface First {\n    void firstMethod();\n}\n\npublic interface Second {\n    void secondMethod();\n}\n\npublic interface Combined __ First, Second {\n    // Combined 인터페이스는 First와 Second의 기능을 모두 포함함\n}\n",
      "answers": ["extends"]
    },
    {
      "id": "u5c24",
      "type": "code",
      "question": "추상 클래스의 자식 클래스에서, 부모 클래스의 생성자를 호출하기 위해 사용해야 하는 키워드를 채워 넣으시오.",
      "codeSnippet": "public abstract class AbstractEntity {\n    protected int id;\n    public AbstractEntity(int id) {\n        this.id = id;\n    }\n}\n\npublic class UserEntity extends AbstractEntity {\n    public UserEntity(int id) {\n        __;\n    }\n}\n",
      "answers": ["super(id)"]
    },
    {
      "id": "u5c25",
      "type": "code",
      "question": "인터페이스 내에 메서드를 정의할 때, 모든 메서드가 암묵적으로 갖는 접근제한자를 명시적으로 작성하려면 어떤 키워드를 사용해야 하는지 채워 넣으시오.",
      "codeSnippet": "public interface Sample {\n    ____ void execute();\n}\n",
      "answers": ["public", "abstract"]
    },
    {
      "id": "u5s1",
      "type": "subjective",
      "question": "추상 클래스의 개념과 사용 목적에 대해 설명하시오.",
      "correctAnswer": "추상 클래스는 인스턴스화할 수 없는 클래스이며, 공통 기능의 일부를 구현하고 하위 클래스에서 구체적인 구현을 강제하기 위해 사용된다."
    },
    {
      "id": "u5s2",
      "type": "subjective",
      "question": "인터페이스의 주요 특징과 활용 방안에 대해 서술하시오.",
      "correctAnswer": "인터페이스는 오직 추상 메서드와 상수만을 포함하여, 다중 구현을 통해 클래스 간의 계약을 정의하고, 다형성을 구현하는 데 사용된다."
    },
    {
      "id": "u5s3",
      "type": "subjective",
      "question": "추상 메서드와 일반 메서드의 차이점을 설명하시오.",
      "correctAnswer": "추상 메서드는 선언만 있고 구현이 없으며, 일반 메서드는 구현부를 포함하여 동작을 정의한다."
    },
    {
      "id": "u5s4",
      "type": "subjective",
      "question": "자바에서 추상 클래스와 인터페이스 중 언제 각각을 사용하는지 설명하시오.",
      "correctAnswer": "추상 클래스는 공통 상태와 메서드 구현이 필요한 경우, 인터페이스는 다양한 클래스에서 공통된 계약을 강제하고 다중 구현이 필요한 경우 사용한다."
    },
    {
      "id": "u5s5",
      "type": "subjective",
      "question": "인터페이스에 디폴트 메서드가 도입된 배경과 그 장점에 대해 설명하시오.",
      "correctAnswer": "디폴트 메서드는 기존 인터페이스를 변경하지 않고도 새로운 메서드를 추가할 수 있게 하여, 기존 구현체와의 호환성을 유지하면서 기능 확장이 가능하게 한다."
    },
    {
      "id": "u5s6",
      "type": "subjective",
      "question": "추상 클래스와 인터페이스의 상속 관계에 대해 설명하시오.",
      "correctAnswer": "추상 클래스는 단일 상속을 통해 하위 클래스에 공통 기능을 물려주고, 인터페이스는 다중 구현이 가능하여 여러 계약을 동시에 만족시킬 수 있다."
    },
    {
      "id": "u5s7",
      "type": "subjective",
      "question": "자바 인터페이스의 다중 구현이 가능한 이유와 그 장점을 서술하시오.",
      "correctAnswer": "자바는 클래스의 다중 상속은 지원하지 않지만, 인터페이스의 다중 구현을 통해 다양한 기능을 조합할 수 있어 유연하고 확장성 있는 설계가 가능하다."
    },
    {
      "id": "u5s8",
      "type": "subjective",
      "question": "추상 클래스에서 생성자의 역할과 필요성에 대해 설명하시오.",
      "correctAnswer": "추상 클래스의 생성자는 하위 클래스에서 공통적으로 사용되는 멤버 변수 초기화 및 기본 상태 설정을 담당하여, 객체의 일관된 초기화를 보장한다."
    },
    {
      "id": "u5s9",
      "type": "subjective",
      "question": "인터페이스에 선언된 메서드를 구현하는 클래스의 책임에 대해 논하시오.",
      "correctAnswer": "인터페이스를 구현하는 클래스는 인터페이스에 선언된 모든 추상 메서드를 구현하여, 해당 계약을 충족시키고 다형성을 실현해야 한다."
    },
    {
      "id": "u5s10",
      "type": "subjective",
      "question": "추상 메서드를 포함한 클래스 디자인의 장점과 단점에 대해 설명하시오.",
      "correctAnswer": "추상 메서드를 포함한 클래스는 공통 기능을 정의하고 하위 클래스에 구현을 강제하여 코드 재사용성을 높이지만, 잘못 사용하면 유연성이 떨어질 수 있다."
    },
    {
      "id": "u5s11",
      "type": "subjective",
      "question": "인터페이스와 추상 클래스의 유사점과 차이점을 비교하시오.",
      "correctAnswer": "둘 다 객체를 직접 생성할 수 없고, 공통 기능을 정의하는 역할을 하지만, 추상 클래스는 상태와 구현을 가질 수 있고, 인터페이스는 오직 상수와 추상 메서드(디폴트/정적 메서드 포함)만 가진다."
    },
    {
      "id": "u5s12",
      "type": "subjective",
      "question": "디폴트 메서드와 정적 메서드의 차이점에 대해 설명하시오.",
      "correctAnswer": "디폴트 메서드는 인스턴스 메서드처럼 동작하며 오버라이딩이 가능하지만, 정적 메서드는 클래스 이름으로 호출되고 오버라이딩할 수 없다."
    },
    {
      "id": "u5s13",
      "type": "subjective",
      "question": "자바 9 이후 인터페이스의 개선 사항에 대해 서술하시오.",
      "correctAnswer": "자바 9에서는 인터페이스에 private 메서드가 도입되어, 디폴트 메서드의 중복 코드를 줄이고 내부 구현을 캡슐화할 수 있게 되었다."
    },
    {
      "id": "u5s14",
      "type": "subjective",
      "question": "추상 클래스의 상속을 통한 코드 재사용의 이점과 한계에 대해 논하시오.",
      "correctAnswer": "추상 클래스는 공통 기능을 재사용하여 코드 중복을 줄이지만, 단일 상속만 지원하므로 클래스 계층 구조가 복잡해지면 결합도가 높아지는 한계가 있다."
    },
    {
      "id": "u5s15",
      "type": "subjective",
      "question": "인터페이스 구현 시 다형성 구현의 중요성에 대해 설명하시오.",
      "correctAnswer": "인터페이스를 통해 여러 클래스의 동작을 통일된 방식으로 처리할 수 있어, 코드의 유연성과 확장성을 크게 향상시킨다."
    },
    {
      "id": "u5s16",
      "type": "subjective",
      "question": "추상 클래스와 인터페이스 중 어느 것을 선택할지 결정할 때 고려해야 할 사항은 무엇이며, 그 이유는 무엇인가?",
      "correctAnswer": "클래스에 공통 상태와 구현이 필요한 경우 추상 클래스를, 여러 클래스로부터 동일한 계약을 강제하고자 할 때 인터페이스를 선택한다."
    },
    {
      "id": "u5s17",
      "type": "subjective",
      "question": "인터페이스에 상수를 선언하는 이유와 그 효과에 대해 설명하시오.",
      "correctAnswer": "인터페이스의 상수는 모든 구현체에서 공통적으로 사용할 수 있는 불변 값을 제공하여, 코드의 일관성과 안전성을 높인다."
    },
    {
      "id": "u5s18",
      "type": "subjective",
      "question": "추상 메서드의 선언이 클래스 디자인에 미치는 영향에 대해 서술하시오.",
      "correctAnswer": "추상 메서드 선언은 하위 클래스에서 반드시 구현하도록 강제하여, 클래스 설계의 일관성과 확장성을 높이는 역할을 한다."
    },
    {
      "id": "u5s19",
      "type": "subjective",
      "question": "인터페이스를 통한 다중 상속이 객체지향 설계에 미치는 이점에 대해 설명하시오.",
      "correctAnswer": "다중 인터페이스 구현을 통해 하나의 클래스가 여러 계약을 동시에 만족시킬 수 있어, 유연하고 확장 가능한 설계가 가능하다."
    },
    {
      "id": "u5s20",
      "type": "subjective",
      "question": "추상 클래스와 인터페이스가 제공하는 캡슐화 효과에 대해 논하시오.",
      "correctAnswer": "두 개념 모두 내부 구현을 감추고 외부에는 필요한 인터페이스만 노출하여, 데이터 보호와 유지보수성을 향상시킨다."
    },
    {
      "id": "u5s21",
      "type": "subjective",
      "question": "디폴트 메서드를 사용하여 인터페이스 확장의 유연성을 어떻게 확보할 수 있는지 설명하시오.",
      "correctAnswer": "디폴트 메서드는 기존 인터페이스에 변경 없이 새로운 기능을 추가할 수 있어, 구현체의 호환성을 유지하면서 기능 확장이 가능하다."
    },
    {
      "id": "u5s22",
      "type": "subjective",
      "question": "추상 클래스의 추상 메서드가 하위 클래스에 미치는 강제성에 대해 논하시오.",
      "correctAnswer": "추상 메서드는 하위 클래스에서 반드시 구현해야 하므로, 클래스 설계 시 일관성과 필수 기능 구현을 보장한다."
    },
    {
      "id": "u5s23",
      "type": "subjective",
      "question": "인터페이스 구현 시 나타나는 일반적인 문제점과 그 해결 방법에 대해 설명하시오.",
      "correctAnswer": "인터페이스 구현 시 중복 코드나 불필요한 강제 구현 문제가 발생할 수 있으며, 디폴트 메서드와 추상 클래스를 적절히 혼용하여 해결할 수 있다."
    },
    {
      "id": "u5s24",
      "type": "subjective",
      "question": "추상 클래스와 인터페이스의 활용 예를 들어, 실제 애플리케이션 설계에 미치는 영향을 설명하시오.",
      "correctAnswer": "예를 들어, GUI 프레임워크에서는 추상 클래스를 통해 기본 위젯 기능을 제공하고, 인터페이스를 통해 이벤트 처리 계약을 정의하여 유연한 확장을 가능하게 한다."
    },
    {
      "id": "u5s25",
      "type": "subjective",
      "question": "자바에서 추상 클래스와 인터페이스를 함께 사용할 때의 장점과 단점에 대해 논하시오.",
      "correctAnswer": "추상 클래스와 인터페이스를 함께 사용하면, 공통 기능과 계약을 분리하여 코드 재사용성과 유연성을 높일 수 있지만, 설계가 복잡해지고 클래스 간 결합도가 증가할 위험이 있다."
    }
  ],
  "unit6": [
    {
      "id": "u6m1",
      "type": "mcq",
      "question": "제너릭의 주 목적은 무엇인가?",
      "options": {
        "A": "코드 재사용",
        "B": "타입 안전성 향상",
        "C": "런타임 성능 개선",
        "D": "디자인 패턴 구현"
      },
      "correctAnswer": "B"
    },
    {
      "id": "u6m2",
      "type": "mcq",
      "question": "제너릭 클래스 선언 시, 타입 파라미터를 감싸는 기호는 무엇인가?",
      "options": {
        "A": "()",
        "B": "[]",
        "C": "<>",
        "D": "{}"
      },
      "correctAnswer": "C"
    },
    {
      "id": "u6m3",
      "type": "mcq",
      "question": "Raw Type이란 무엇인가?",
      "options": {
        "A": "타입 파라미터가 없는 제너릭 클래스",
        "B": "타입 파라미터가 명시된 클래스",
        "C": "모든 타입 파라미터를 Object로 처리하는 타입",
        "D": "컴파일 타임에 에러가 나는 타입"
      },
      "correctAnswer": "A"
    },
    {
      "id": "u6m4",
      "type": "mcq",
      "question": "제너릭에서 Type Erasure의 의미는 무엇인가?",
      "options": {
        "A": "타입 정보가 런타임에 유지된다",
        "B": "타입 정보가 컴파일 타임에 삭제된다",
        "C": "타입 파라미터가 자동으로 변환된다",
        "D": "타입 파라미터가 static 멤버로 전환된다"
      },
      "correctAnswer": "B"
    },
    {
      "id": "u6m5",
      "type": "mcq",
      "question": "제너릭 메서드에서 타입 파라미터는 어디에 선언되는가?",
      "options": {
        "A": "메서드 리턴 타입 앞",
        "B": "클래스 이름 뒤",
        "C": "메서드 이름 뒤",
        "D": "매개변수 앞"
      },
      "correctAnswer": "A"
    },
    {
      "id": "u6m6",
      "type": "mcq",
      "question": "제너릭 배열 생성이 불가능한 이유는 무엇인가?",
      "options": {
        "A": "배열은 런타임에 타입 정보를 유지하기 때문이다",
        "B": "배열은 런타임에 타입 정보가 소거되기 때문이다",
        "C": "배열은 동적 크기를 가지기 때문이다",
        "D": "컴파일러가 지원하지 않기 때문이다"
      },
      "correctAnswer": "B"
    },
    {
      "id": "u6m7",
      "type": "mcq",
      "question": "와일드카드 '?'의 주 목적은 무엇인가?",
      "options": {
        "A": "타입 제한을 제거하기 위해",
        "B": "어떤 타입이든 허용하기 위해",
        "C": "특정 타입만 허용하기 위해",
        "D": "컴파일러 오류를 방지하기 위해"
      },
      "correctAnswer": "B"
    },
    {
      "id": "u6m8",
      "type": "mcq",
      "question": "PECS 원칙에서 'Producer Extends'는 무엇을 의미하는가?",
      "options": {
        "A": "데이터를 소비하는 역할",
        "B": "데이터를 생산하는 역할",
        "C": "타입을 확장하는 역할",
        "D": "타입을 제한하는 역할"
      },
      "correctAnswer": "B"
    },
    {
      "id": "u6m9",
      "type": "mcq",
      "question": "PECS 원칙에서 'Consumer Super'는 무엇을 의미하는가?",
      "options": {
        "A": "데이터를 생산하는 역할",
        "B": "데이터를 소비하는 역할",
        "C": "타입의 상위를 제한하는 역할",
        "D": "타입 안전성을 향상시키는 역할"
      },
      "correctAnswer": "B"
    },
    {
      "id": "u6m10",
      "type": "mcq",
      "question": "다음 중 올바른 제너릭 클래스 선언은?",
      "options": {
        "A": "public class Box<T> {}",
        "B": "public class Box<T> () {}",
        "C": "public class Box<T> [] {}",
        "D": "public class Box<T> {}[]"
      },
      "correctAnswer": "A"
    },
    {
      "id": "u6m11",
      "type": "mcq",
      "question": "제너릭 인터페이스의 예로 알맞은 것은?",
      "options": {
        "A": "public interface List<E> {}",
        "B": "public interface List<E> () {}",
        "C": "public interface List<E> [] {}",
        "D": "public interface List<E> {}[]"
      },
      "correctAnswer": "A"
    },
    {
      "id": "u6m12",
      "type": "mcq",
      "question": "Raw Type 사용 시 컴파일러 경고를 억제하기 위한 어노테이션은?",
      "options": {
        "A": "@Override",
        "B": "@SuppressWarnings",
        "C": "@Deprecated",
        "D": "@SafeVarargs"
      },
      "correctAnswer": "B"
    },
    {
      "id": "u6m13",
      "type": "mcq",
      "question": "제너릭 메서드 선언에서 올바른 형태는?",
      "options": {
        "A": "public static <T> T method(T t) {}",
        "B": "public <T> T method(T t) {}",
        "C": "static <T> T method(T t) {}",
        "D": "모두 올바르다"
      },
      "correctAnswer": "D"
    },
    {
      "id": "u6m14",
      "type": "mcq",
      "question": "제너릭에서 bounded type parameter를 지정할 때 사용하는 키워드는?",
      "options": {
        "A": "extends",
        "B": "implements",
        "C": "super",
        "D": "instanceof"
      },
      "correctAnswer": "A"
    },
    {
      "id": "u6m15",
      "type": "mcq",
      "question": "다음 중 enum의 특징으로 올바른 것은?",
      "options": {
        "A": "enum은 클래스 상속을 허용한다.",
        "B": "enum은 객체 생성이 가능하다.",
        "C": "enum 상수는 모두 public static final이다.",
        "D": "enum은 오직 추상 메서드만 포함할 수 있다."
      },
      "correctAnswer": "C"
    },
    {
      "id": "u6m16",
      "type": "mcq",
      "question": "enum 타입에서 열거 상수의 순서를 반환하는 메서드는?",
      "options": {
        "A": "name()",
        "B": "ordinal()",
        "C": "compareTo()",
        "D": "valueOf()"
      },
      "correctAnswer": "B"
    },
    {
      "id": "u6m17",
      "type": "mcq",
      "question": "enum에서 열거 상수의 이름을 문자열로 반환하는 메서드는?",
      "options": {
        "A": "toString()",
        "B": "name()",
        "C": "ordinal()",
        "D": "valueOf()"
      },
      "correctAnswer": "B"
    },
    {
      "id": "u6m18",
      "type": "mcq",
      "question": "enum 상수를 배열로 반환하는 메서드는?",
      "options": {
        "A": "values()",
        "B": "toArray()",
        "C": "list()",
        "D": "convert()"
      },
      "correctAnswer": "A"
    },
    {
      "id": "u6m19",
      "type": "mcq",
      "question": "다음 중 enum의 생성자는 어떤 접근 제어자인가?",
      "options": {
        "A": "public",
        "B": "protected",
        "C": "private",
        "D": "default"
      },
      "correctAnswer": "C"
    },
    {
      "id": "u6m20",
      "type": "mcq",
      "question": "enum을 이용하여 switch-case문을 사용할 때 주의할 점은?",
      "options": {
        "A": "case에 enum 상수 앞에 enum 타입 이름을 붙여야 한다.",
        "B": "case에 enum 상수만 사용해야 한다.",
        "C": "switch 변수는 반드시 int 타입이어야 한다.",
        "D": "enum은 switch-case에서 사용할 수 없다."
      },
      "correctAnswer": "B"
    },
    {
      "id": "u6m21",
      "type": "mcq",
      "question": "다음 중 annotation의 기능으로 옳은 것은?",
      "options": {
        "A": "코드 실행 시 동작을 변경한다.",
        "B": "컴파일러에게 정보를 제공한다.",
        "C": "메모리 사용량을 줄인다.",
        "D": "런타임 성능을 향상시킨다."
      },
      "correctAnswer": "B"
    },
    {
      "id": "u6m22",
      "type": "mcq",
      "question": "자바의 기본 제공 annotation 중 해당 메서드가 재정의되었음을 알리는 것은?",
      "options": {
        "A": "@Override",
        "B": "@Deprecated",
        "C": "@SuppressWarnings",
        "D": "@FunctionalInterface"
      },
      "correctAnswer": "A"
    },
    {
      "id": "u6m23",
      "type": "mcq",
      "question": "자바 annotation에서 @Retention의 용도로 옳은 것은?",
      "options": {
        "A": "어노테이션이 적용될 대상 지정",
        "B": "어노테이션의 유지 기간 결정",
        "C": "어노테이션의 이름 변경",
        "D": "어노테이션의 값을 수정"
      },
      "correctAnswer": "B"
    },
    {
      "id": "u6m24",
      "type": "mcq",
      "question": "어노테이션을 문서화에 포함시키기 위해 사용하는 메타 어노테이션은?",
      "options": {
        "A": "@Documented",
        "B": "@Inherited",
        "C": "@Retention",
        "D": "@Target"
      },
      "correctAnswer": "A"
    },
    {
      "id": "u6m25",
      "type": "mcq",
      "question": "어노테이션에서 여러 개의 값을 반복해서 적용할 수 있게 해주는 어노테이션은?",
      "options": {
        "A": "@Inherited",
        "B": "@Repeatable",
        "C": "@Override",
        "D": "@Deprecated"
      },
      "correctAnswer": "B"
    },
    {
      "id": "u6m26",
      "type": "mcq",
      "question": "다음 중 제너릭 타입의 타입 파라미터로 사용할 수 없는 것은?",
      "options": {
        "A": "클래스",
        "B": "인터페이스",
        "C": "기본형",
        "D": "열거형"
      },
      "correctAnswer": "C"
    },
    {
      "id": "u6m27",
      "type": "mcq",
      "question": "다음 중 와일드카드의 올바른 사용 예시로 옳은 것은?",
      "options": {
        "A": "List<?>",
        "B": "List<? extends Number>",
        "C": "List<? super Integer>",
        "D": "모두 옳다"
      },
      "correctAnswer": "D"
    },
    {
      "id": "u6m28",
      "type": "mcq",
      "question": "제너릭 메서드를 호출할 때 타입 인자를 생략할 수 있는 이유는?",
      "options": {
        "A": "타입 추론 기능이 있기 때문이다.",
        "B": "런타임에 타입 정보가 없기 때문이다.",
        "C": "컴파일러가 기본 타입으로 대체하기 때문이다.",
        "D": "자바 버전 1.5부터 허용된다."
      },
      "correctAnswer": "A"
    },
    {
      "id": "u6m29",
      "type": "mcq",
      "question": "제너릭의 타입 파라미터는 어느 시점에 결정되는가?",
      "options": {
        "A": "컴파일 타임",
        "B": "런타임",
        "C": "배포 시",
        "D": "개발자에 의해"
      },
      "correctAnswer": "A"
    },
    {
      "id": "u6m30",
      "type": "mcq",
      "question": "다음 중 GenericBox<Integer>[] 와 같이 제너릭 배열을 생성할 수 없는 이유는?",
      "options": {
        "A": "배열은 런타임에 타입 정보를 유지하기 때문이다.",
        "B": "제너릭은 컴파일 타임에 타입 정보가 소거되기 때문이다.",
        "C": "자바가 다중 상속을 지원하지 않기 때문이다.",
        "D": "컴파일러가 이를 지원하지 않기 때문이다."
      },
      "correctAnswer": "B"
    },
    {
      "id": "u6m31",
      "type": "mcq",
      "question": "제너릭 메서드에서 타입 파라미터를 선언하는 위치는 어디인가?",
      "options": {
        "A": "메서드 이름 앞",
        "B": "리턴 타입 뒤",
        "C": "매개변수 목록 앞",
        "D": "메서드 블록 내부"
      },
      "correctAnswer": "A"
    },
    {
      "id": "u6m32",
      "type": "mcq",
      "question": "다음 중 제너릭의 한정형 형인자를 선언할 때 올바른 문법은?",
      "options": {
        "A": "public <T extends Number> void method()",
        "B": "public <T super Number> void method()",
        "C": "public <T: Number> void method()",
        "D": "public <T implements Number> void method()"
      },
      "correctAnswer": "A"
    },
    {
      "id": "u6m33",
      "type": "mcq",
      "question": "제너릭을 사용함으로써 얻을 수 있는 이점이 아닌 것은?",
      "options": {
        "A": "타입 안전성 보장",
        "B": "코드 재사용성 향상",
        "C": "컴파일 타임에 오류 발견",
        "D": "런타임 성능 향상"
      },
      "correctAnswer": "D"
    },
    {
      "id": "u6m34",
      "type": "mcq",
      "question": "Enum 타입은 기본적으로 어떤 클래스를 상속받는가?",
      "options": {
        "A": "java.lang.Object",
        "B": "java.lang.Enum",
        "C": "java.lang.String",
        "D": "java.lang.Number"
      },
      "correctAnswer": "B"
    },
    {
      "id": "u6m35",
      "type": "mcq",
      "question": "enum 상수에 추가 필드를 포함시키려면, 상수 선언 후 어떤 구분자를 사용해야 하는가?",
      "options": {
        "A": "콤마",
        "B": "세미콜론",
        "C": "콜론",
        "D": "대시"
      },
      "correctAnswer": "B"
    },
    {
      "id": "u6m36",
      "type": "mcq",
      "question": "enum에서 switch-case 문 사용 시, case 키워드에 사용되는 값은 무엇인가?",
      "options": {
        "A": "enum 타입 전체",
        "B": "enum 상수 이름",
        "C": "enum 상수의 ordinal 값",
        "D": "enum 상수의 toString() 값"
      },
      "correctAnswer": "B"
    },
    {
      "id": "u6m37",
      "type": "mcq",
      "question": "Annotation의 RetentionPolicy 값 중 런타임까지 어노테이션 정보를 유지하는 것은?",
      "options": {
        "A": "SOURCE",
        "B": "CLASS",
        "C": "RUNTIME",
        "D": "DEBUG"
      },
      "correctAnswer": "C"
    },
    {
      "id": "u6m38",
      "type": "mcq",
      "question": "Annotation의 Target 어노테이션은 무엇을 지정하는가?",
      "options": {
        "A": "어노테이션이 적용될 요소",
        "B": "어노테이션의 유지 기간",
        "C": "어노테이션의 기본값",
        "D": "어노테이션의 상속 여부"
      },
      "correctAnswer": "A"
    },
    {
      "id": "u6m39",
      "type": "mcq",
      "question": "다음 중 올바른 어노테이션 선언은?",
      "options": {
        "A": "public @interface MyAnnotation {}",
        "B": "public annotation MyAnnotation {}",
        "C": "public interface MyAnnotation {}",
        "D": "public class MyAnnotation extends Annotation {}"
      },
      "correctAnswer": "A"
    },
    {
      "id": "u6m40",
      "type": "mcq",
      "question": "어노테이션을 반복해서 사용할 수 있게 하는 메타 어노테이션은?",
      "options": {
        "A": "@Inherited",
        "B": "@Documented",
        "C": "@Repeatable",
        "D": "@Target"
      },
      "correctAnswer": "C"
    },
    {
      "id": "u6m41",
      "type": "mcq",
      "question": "어노테이션에 대해 잘못된 설명은?",
      "options": {
        "A": "어노테이션은 메타 데이터를 제공한다.",
        "B": "어노테이션은 컴파일러에게 정보를 전달한다.",
        "C": "어노테이션은 실행 시 동적으로 변경할 수 있다.",
        "D": "어노테이션은 런타임까지 유지될 수 있다."
      },
      "correctAnswer": "C"
    },
    {
      "id": "u6m42",
      "type": "mcq",
      "question": "제너릭 클래스의 인스턴스 생성 시, 다이아몬드 연산자를 사용하는 이유는 무엇인가?",
      "options": {
        "A": "타입을 명시하지 않아도 되기 때문에",
        "B": "타입 추론을 통해 코드가 간결해지기 때문에",
        "C": "컴파일러가 자동으로 타입을 결정하기 때문에",
        "D": "모두 옳다"
      },
      "correctAnswer": "D"
    },
    {
      "id": "u6m43",
      "type": "mcq",
      "question": "제너릭에서 두 타입 파라미터 간에 상속 관계가 없을 경우, 서로 대입이 가능한가?",
      "options": {
        "A": "가능하다",
        "B": "불가능하다",
        "C": "조건부로 가능하다",
        "D": "런타임에 가능하다"
      },
      "correctAnswer": "B"
    },
    {
      "id": "u6m44",
      "type": "mcq",
      "question": "와일드카드 사용의 장점으로 옳은 것은?",
      "options": {
        "A": "모든 타입을 허용하여 유연성을 높인다",
        "B": "타입 안전성을 완전히 보장한다",
        "C": "컴파일 타임에 오류를 발생시킨다",
        "D": "런타임에 타입 체크를 생략한다"
      },
      "correctAnswer": "A"
    },
    {
      "id": "u6m45",
      "type": "mcq",
      "question": "enum과 일반 클래스를 비교할 때, enum이 가지는 고유의 장점은 무엇인가?",
      "options": {
        "A": "메모리 사용량 감소",
        "B": "타입 안전한 상수 집합 제공",
        "C": "더 빠른 실행 속도",
        "D": "동적 객체 생성 가능"
      },
      "correctAnswer": "B"
    },
    {
      "id": "u6m46",
      "type": "mcq",
      "question": "Annotation에서 @SuppressWarnings 어노테이션의 주 용도는 무엇인가?",
      "options": {
        "A": "컴파일러 경고를 억제하기 위해",
        "B": "어노테이션 정보를 유지하기 위해",
        "C": "런타임 오류를 방지하기 위해",
        "D": "코드 실행을 최적화하기 위해"
      },
      "correctAnswer": "A"
    },
    {
      "id": "u6m47",
      "type": "mcq",
      "question": "Generic 타입에서 와일드카드 <?>에 대한 올바른 설명은?",
      "options": {
        "A": "<?>는 아무런 타입 제한 없이 모든 타입을 의미한다.",
        "B": "<?>는 기본형만 허용한다.",
        "C": "<?>는 오직 Object 타입만 의미한다.",
        "D": "<?>는 컴파일 시 에러를 발생시킨다."
      },
      "correctAnswer": "A"
    },
    {
      "id": "u6m48",
      "type": "mcq",
      "question": "다음 중 제너릭에서 상한 제한(Upper Bounded Wildcards)의 올바른 예시는?",
      "options": {
        "A": "List<? extends Number>",
        "B": "List<? super Number>",
        "C": "List<?>",
        "D": "List<? extends Object>"
      },
      "correctAnswer": "A"
    },
    {
      "id": "u6m49",
      "type": "mcq",
      "question": "다음 중 제너릭에서 하한 제한(Lower Bounded Wildcards)의 올바른 예시는?",
      "options": {
        "A": "List<? extends Integer>",
        "B": "List<? super Integer>",
        "C": "List<? super Number>",
        "D": "List<?>"
      },
      "correctAnswer": "B"
    },
    {
      "id": "u6m50",
      "type": "mcq",
      "question": "Generic을 사용하여 코드 재사용성을 높이는 주요 이유는 무엇인가?",
      "options": {
        "A": "코드 길이를 줄이기 위해",
        "B": "타입 안전성을 보장하기 위해",
        "C": "런타임 속도를 높이기 위해",
        "D": "메모리 사용을 줄이기 위해"
      },
      "correctAnswer": "B"
    },
    {
      "id": "u6c1",
      "type": "code",
      "question": "제너릭 클래스를 선언할 때, 타입 파라미터를 감싸는 기호는 __이다.",
      "codeSnippet": "public class Box<__> {\n    // ...\n}",
      "answers": ["T"]
    },
    {
      "id": "u6c2",
      "type": "code",
      "question": "다음 코드는 제너릭 메서드를 선언하는 예제이다. 빈칸에 들어갈 코드를 채워 넣으시오.",
      "codeSnippet": "public static <__> __ method(__ param) {\n    return param;\n}",
      "answers": ["T", "T", "T"]
    },
    {
      "id": "u6c3",
      "type": "code",
      "question": "제너릭 클래스에서 Raw Type을 사용하지 않도록 하기 위해, 타입 파라미터를 반드시 명시해야 한다. 다음 코드에서 빈칸을 채워 넣으시오.",
      "codeSnippet": "Box<__> box = new Box<>();",
      "answers": ["String"]
    },
    {
      "id": "u6c4",
      "type": "code",
      "question": "다음 코드는 bounded type parameter를 사용하는 예제이다. 빈칸에 들어갈 키워드를 채워 넣으시오.",
      "codeSnippet": "public class NumberBox<T __ Number> {\n    private T value;\n    public NumberBox(T value) { this.value = value; }\n}",
      "answers": ["extends"]
    },
    {
      "id": "u6c5",
      "type": "code",
      "question": "다음 코드는 와일드카드를 사용하는 예제이다. 빈칸에 들어갈 코드를 채워 넣으시오.",
      "codeSnippet": "List<? __ Number> list = new ArrayList<>();",
      "answers": ["extends"]
    },
    {
      "id": "u6c6",
      "type": "code",
      "question": "다음 코드는 하한 제한을 사용한 예제이다. 빈칸에 들어갈 키워드를 채워 넣으시오.",
      "codeSnippet": "List<? __ Integer> list = new ArrayList<>();",
      "answers": ["super"]
    },
    {
      "id": "u6c7",
      "type": "code",
      "question": "enum 키워드를 사용하여 열거형을 선언할 때, 클래스 선언 대신 __를 사용한다.",
      "codeSnippet": "public __ Color {\n    RED, GREEN, BLUE;\n}",
      "answers": ["enum"]
    },
    {
      "id": "u6c8",
      "type": "code",
      "question": "다음 코드는 enum의 메서드를 사용하는 예제이다. 빈칸에 들어갈 메서드를 채워 넣으시오.",
      "codeSnippet": "Color c = Color.RED;\nint index = c.__();",
      "answers": ["ordinal"]
    },
    {
      "id": "u6c9",
      "type": "code",
      "question": "어노테이션을 선언할 때, 올바른 키워드를 채워 넣으시오.",
      "codeSnippet": "public __ MyAnnotation {\n    // ...\n}",
      "answers": ["@interface"]
    },
    {
      "id": "u6c10",
      "type": "code",
      "question": "다음 코드는 어노테이션의 Retention을 지정하는 예제이다. 빈칸에 들어갈 코드를 채워 넣으시오.",
      "codeSnippet": "@Retention(__.RUNTIME)\npublic @interface MyAnnotation {\n    // ...\n}",
      "answers": ["RetentionPolicy"]
    },
    {
      "id": "u6c11",
      "type": "code",
      "question": "다음 코드는 어노테이션의 Target을 지정하는 예제이다. 빈칸에 들어갈 코드를 채워 넣으시오.",
      "codeSnippet": "@Target({ __.TYPE, __.METHOD })\npublic @interface MyAnnotation {\n    // ...\n}",
      "answers": ["ElementType", "ElementType"]
    },
    {
      "id": "u6c12",
      "type": "code",
      "question": "제너릭 메서드 선언 시, 메서드 이름 앞에 타입 파라미터를 선언하는 문법은 __이다.",
      "codeSnippet": "public static <__> void print(__ value) {\n    System.out.println(value);\n}",
      "answers": ["T", "T"]
    },
    {
      "id": "u6c13",
      "type": "code",
      "question": "다이아몬드 연산자를 사용할 때, 생성자에서 타입 파라미터를 생략하는 것을 __라 한다.",
      "codeSnippet": "List<String> list = new ArrayList<__>();",
      "answers": ["다이아몬드 연산자"]
    },
    {
      "id": "u6c14",
      "type": "code",
      "question": "제너릭 클래스에서 static 멤버에 타입 파라미터를 사용할 수 없는 이유는 __ 때문이다.",
      "codeSnippet": "public class Box<T> {\n    // static T value; // 올바르지 않음\n}",
      "answers": ["인스턴스 레벨에서 결정되므로"]
    },
    {
      "id": "u6c15",
      "type": "code",
      "question": "다음 코드는 제너릭 메서드의 타입 추론을 보여준다. 빈칸에 들어갈 값을 채워 넣으시오.",
      "codeSnippet": "public static <T> T identity(T t) {\n    return t;\n}\nString s = identity(__);",
      "answers": ["\"Hello\""]
    },
    {
      "id": "u6c16",
      "type": "code",
      "question": "다음 코드는 제너릭 메서드 호출 예제이다. 빈칸에 들어갈 타입 인자를 채워 넣으시오.",
      "codeSnippet": "Integer i = GenericMethod.<__>identity(10);",
      "answers": ["Integer"]
    },
    {
      "id": "u6c17",
      "type": "code",
      "question": "다음 코드는 상한 제한을 사용한 제너릭 메서드 예제이다. 빈칸에 들어갈 키워드를 채워 넣으시오.",
      "codeSnippet": "public static <T __ Number> double add(T a, T b) {\n    return a.doubleValue() + b.doubleValue();\n}",
      "answers": ["extends"]
    },
    {
      "id": "u6c18",
      "type": "code",
      "question": "다음 코드는 와일드카드를 사용하는 메서드 예제이다. 빈칸에 들어갈 내용을 채워 넣으시오.",
      "codeSnippet": "public void copy(List<? __ T> src, List<T> dest) {\n    dest.addAll(src);\n}",
      "answers": ["extends"]
    },
    {
      "id": "u6c19",
      "type": "code",
      "question": "다음 코드는 제너릭 컬렉션에 요소를 추가하는 예제이다. 빈칸에 들어갈 타입 인자를 채워 넣으시오.",
      "codeSnippet": "List<__> list = new ArrayList<>();\nlist.add(new String(\"Hello\"));",
      "answers": ["String"]
    },
    {
      "id": "u6c20",
      "type": "code",
      "question": "다음 코드는 enum의 values() 메서드를 사용하는 예제이다. 빈칸에 들어갈 메서드를 채워 넣으시오.",
      "codeSnippet": "Grade[] grades = Grade.__();",
      "answers": ["values"]
    },
    {
      "id": "u6c21",
      "type": "code",
      "question": "다음 코드는 어노테이션의 @SuppressWarnings 사용 예제이다. 빈칸에 들어갈 경고 타입을 채워 넣으시오.",
      "codeSnippet": "@SuppressWarnings({ __ })\npublic void method() {}",
      "answers": ["\"unchecked\""]
    },
    {
      "id": "u6c22",
      "type": "code",
      "question": "다음 코드는 어노테이션을 적용한 메서드 예제이다. 빈칸에 들어갈 어노테이션을 채워 넣으시오.",
      "codeSnippet": "__\npublic void method() {}",
      "answers": ["@Override"]
    },
    {
      "id": "u6c23",
      "type": "code",
      "question": "다음 코드는 enum 상수의 이름을 반환하는 메서드를 사용하는 예제이다. 빈칸에 들어갈 메서드를 채워 넣으시오.",
      "codeSnippet": "Color c = Color.BLUE;\nString name = c.__();",
      "answers": ["name"]
    },
    {
      "id": "u6c24",
      "type": "code",
      "question": "다음 코드는 제너릭 인터페이스를 구현한 클래스의 선언 예제이다. 빈칸에 들어갈 내용을 채워 넣으시오.",
      "codeSnippet": "public class MyList implements List<__> {\n    // 구현 생략\n}",
      "answers": ["String"]
    },
    {
      "id": "u6c25",
      "type": "code",
      "question": "다음 코드는 어노테이션의 @Retention 정책을 설정하는 예제이다. 빈칸에 들어갈 값을 채워 넣으시오.",
      "codeSnippet": "@Retention(__.RUNTIME)\npublic @interface MyAnnotation {}",
      "answers": ["RetentionPolicy"]
    },
    {
      "id": "u6s1",
      "type": "subjective",
      "question": "제너릭을 사용하는 이유와 그 장점에 대해 서술하시오.",
      "correctAnswer": "타입 안전성과 코드 재사용성을 높이기 위해 사용된다. 이를 통해 컴파일 시 오류를 줄이고, 코드의 재사용성을 향상시킬 수 있다."
    },
    {
      "id": "u6s2",
      "type": "subjective",
      "question": "Raw Type이 왜 사용되지 않아야 하는지 설명하시오.",
      "correctAnswer": "Raw Type은 타입 안전성을 보장하지 못해 런타임 시 ClassCastException과 같은 오류를 발생시킬 수 있으므로 사용을 피해야 한다."
    },
    {
      "id": "u6s3",
      "type": "subjective",
      "question": "Type Erasure가 제너릭에서 어떤 역할을 하는지 서술하시오.",
      "correctAnswer": "Type Erasure는 컴파일 타임에 제너릭 타입 정보를 제거하여 런타임에는 Object 타입으로 동작하도록 하는 메커니즘이다. 이를 통해 이전 버전과의 호환성을 유지할 수 있다."
    },
    {
      "id": "u6s4",
      "type": "subjective",
      "question": "와일드카드 '?'의 용도와 사용 예시에 대해 설명하시오.",
      "correctAnswer": "와일드카드 '?'는 특정 타입을 명시하지 않고, 다양한 타입을 허용하기 위해 사용된다. Producer Extends와 Consumer Super를 통해 입력과 출력에 대해 타입 제한을 설정할 수 있다."
    },
    {
      "id": "u6s5",
      "type": "subjective",
      "question": "제너릭 메서드와 일반 메서드의 차이점을 서술하시오.",
      "correctAnswer": "제너릭 메서드는 메서드 선언부에 타입 파라미터를 명시하여 호출 시 타입을 유추할 수 있도록 하는 반면, 일반 메서드는 타입 파라미터가 없어 고정된 타입만 다룬다."
    },
    {
      "id": "u6s6",
      "type": "subjective",
      "question": "bounded type parameter란 무엇이며, 왜 사용하는지 설명하시오.",
      "correctAnswer": "bounded type parameter는 타입 파라미터에 상한을 지정하여 특정 클래스나 인터페이스의 하위 타입만 허용하도록 제한하는 것이다. 이를 통해 보다 안전한 타입 제약을 제공할 수 있다."
    },
    {
      "id": "u6s7",
      "type": "subjective",
      "question": "다이아몬드 연산자의 장점에 대해 설명하시오.",
      "correctAnswer": "다이아몬드 연산자는 생성자 호출 시 타입 파라미터를 생략할 수 있게 하여 코드가 간결해지고, 컴파일러가 타입을 추론함으로써 타입 오류를 줄일 수 있다."
    },
    {
      "id": "u6s8",
      "type": "subjective",
      "question": "enum의 특징과 사용 장점을 서술하시오.",
      "correctAnswer": "enum은 한정된 상수 집합을 타입 안전하게 정의할 수 있으며, switch-case문에서 사용하기 쉽고, 코드의 가독성을 높여준다."
    },
    {
      "id": "u6s9",
      "type": "subjective",
      "question": "enum에서 ordinal() 메서드의 역할과 주의사항에 대해 설명하시오.",
      "correctAnswer": "ordinal() 메서드는 열거 상수의 선언 순서를 0부터 반환한다. 그러나 이 값은 상수의 순서가 변경되면 달라지므로, 비즈니스 로직에서는 사용에 주의해야 한다."
    },
    {
      "id": "u6s10",
      "type": "subjective",
      "question": "enum의 values() 메서드의 용도에 대해 서술하시오.",
      "correctAnswer": "values() 메서드는 해당 enum 타입에 선언된 모든 열거 상수를 배열로 반환하여 반복문 등을 통해 열거 상수를 손쉽게 다룰 수 있도록 한다."
    },
    {
      "id": "u6s11",
      "type": "subjective",
      "question": "어노테이션의 @Retention 정책에 대해 설명하시오.",
      "correctAnswer": "Retention 정책은 어노테이션이 얼마나 오래 유지될지를 결정하며, SOURCE, CLASS, RUNTIME 중 하나로 설정하여 컴파일 타임이나 런타임 시 어노테이션 정보를 사용할 수 있게 한다."
    },
    {
      "id": "u6s12",
      "type": "subjective",
      "question": "어노테이션의 @Target 어노테이션의 역할을 설명하시오.",
      "correctAnswer": "@Target은 어노테이션이 적용될 수 있는 프로그램 요소(클래스, 메서드, 필드 등)를 제한하여, 잘못된 위치에 어노테이션이 사용되는 것을 방지한다."
    },
    {
      "id": "u6s13",
      "type": "subjective",
      "question": "메타 어노테이션이란 무엇이며, 대표적인 예를 서술하시오.",
      "correctAnswer": "메타 어노테이션은 다른 어노테이션을 정의할 때 사용하는 어노테이션으로, @Retention, @Target, @Inherited, @Documented 등이 대표적이다."
    },
    {
      "id": "u6s14",
      "type": "subjective",
      "question": "어노테이션의 @Inherited의 기능과 한계에 대해 설명하시오.",
      "correctAnswer": "@Inherited는 어노테이션이 상속되도록 하지만, 메서드나 필드와 같이 클래스 내부의 요소에는 적용되지 않는 한계가 있다."
    },
    {
      "id": "u6s15",
      "type": "subjective",
      "question": "제너릭을 사용할 때 발생할 수 있는 ClassCastException의 원인에 대해 서술하시오.",
      "correctAnswer": "제너릭 타입 정보가 런타임에 소거되어 잘못된 타입으로 캐스팅할 경우 발생할 수 있으며, 이는 주로 Raw Type 사용이나 잘못된 타입 변환으로 인해 발생한다."
    },
    {
      "id": "u6s16",
      "type": "subjective",
      "question": "Generic을 사용한 컬렉션에서 형변환이 필요 없게 되는 이유를 설명하시오.",
      "correctAnswer": "컴파일 타임에 타입이 체크되기 때문에, 잘못된 타입의 데이터가 추가되는 것을 막아 별도의 형변환 없이 안전하게 데이터를 사용할 수 있다."
    },
    {
      "id": "u6s17",
      "type": "subjective",
      "question": "제너릭에서 와일드카드의 Producer Extends와 Consumer Super의 차이점을 서술하시오.",
      "correctAnswer": "Producer Extends는 데이터를 반환할 때 사용하며, Consumer Super는 데이터를 소비(추가, 수정)할 때 사용하여, 각각의 상황에 맞게 타입의 상한 또는 하한을 제한한다."
    },
    {
      "id": "u6s18",
      "type": "subjective",
      "question": "Raw Type 사용 시 발생할 수 있는 문제점에 대해 설명하시오.",
      "correctAnswer": "Raw Type은 컴파일 타임의 타입 체크를 우회하여 런타임에 ClassCastException을 발생시킬 수 있으며, 코드의 가독성과 유지보수성을 떨어뜨린다."
    },
    {
      "id": "u6s19",
      "type": "subjective",
      "question": "제너릭 메서드의 타입 추론이 어떻게 이루어지는지 설명하시오.",
      "correctAnswer": "컴파일러가 메서드 호출 시 전달된 인수의 타입을 분석하여, 메서드 선언부의 타입 파라미터를 자동으로 결정하는 과정을 말한다."
    },
    {
      "id": "u6s20",
      "type": "subjective",
      "question": "enum 상수에 추가 메서드나 필드를 정의할 때 주의해야 할 점을 서술하시오.",
      "correctAnswer": "열거 상수 선언 후 반드시 세미콜론(;)을 사용하여 선언부와 멤버를 구분해야 하며, 상수마다 고유의 상태를 부여할 때는 생성자와 필드를 적절히 정의해야 한다."
    },
    {
      "id": "u6s21",
      "type": "subjective",
      "question": "어노테이션의 @SuppressWarnings 어노테이션 사용 시 주의사항에 대해 설명하시오.",
      "correctAnswer": "불필요하게 경고를 억제하면 실제 문제가 있는 코드를 놓칠 수 있으므로, 최소한으로 사용하고 필요한 경우에만 적용해야 한다."
    },
    {
      "id": "u6s22",
      "type": "subjective",
      "question": "제너릭을 활용하여 코드의 재사용성을 높이는 방법에 대해 서술하시오.",
      "correctAnswer": "제너릭을 사용하면 하나의 코드로 다양한 타입을 처리할 수 있어 중복 코드를 줄이고, 타입 안정성을 보장함으로써 재사용성을 높일 수 있다."
    },
    {
      "id": "u6s23",
      "type": "subjective",
      "question": "enum의 compareTo() 메서드가 어떻게 동작하는지 설명하시오.",
      "correctAnswer": "compareTo() 메서드는 두 열거 상수의 ordinal 값을 비교하여, 그 차이를 정수 값으로 반환한다. 이를 통해 열거 상수 간의 순서를 비교할 수 있다."
    },
    {
      "id": "u6s24",
      "type": "subjective",
      "question": "어노테이션 프로세서를 사용하여 어노테이션 정보를 처리하는 방법에 대해 설명하시오.",
      "correctAnswer": "어노테이션 프로세서는 컴파일 타임에 소스코드를 분석하여 어노테이션 정보를 기반으로 코드 생성, 검증, 혹은 문서화를 자동화하는 도구이다."
    },
    {
      "id": "u6s25",
      "type": "subjective",
      "question": "제너릭, enum, annotation이 객체지향 프로그래밍에서 가지는 중요성에 대해 서술하시오.",
      "correctAnswer": "이들은 타입 안전성을 확보하고, 코드의 재사용성을 높이며, 메타데이터를 통해 프로그램의 구조와 동작을 명확하게 표현할 수 있게 해 객체지향 프로그래밍의 견고성과 유지보수성을 향상시킨다."
    }
  ],
  "unit7": [
    {
      "id": "u7m1",
      "type": "mcq",
      "question": "자료구조란 무엇인가?",
      "options": {
        "A": "단순히 데이터를 저장하는 방법",
        "B": "데이터를 조직, 관리, 저장하는 방식과 데이터 간의 관계 및 연산을 포함하는 개념",
        "C": "데이터베이스의 한 종류",
        "D": "프로그램의 실행 속도를 결정하는 알고리즘"
      },
      "correctAnswer": "B"
    },
    {
      "id": "u7m2",
      "type": "mcq",
      "question": "배열의 주요 특징은 무엇인가?",
      "options": {
        "A": "모든 데이터가 동일한 타입이어야 한다",
        "B": "동적 크기를 가진다",
        "C": "데이터 삽입과 삭제가 용이하다",
        "D": "내부적으로 연결 리스트로 구현된다"
      },
      "correctAnswer": "A"
    },
    {
      "id": "u7m3",
      "type": "mcq",
      "question": "List 인터페이스의 특징으로 옳은 것은?",
      "options": {
        "A": "입력 순서를 유지하며 중복을 허용한다",
        "B": "중복을 허용하지 않는다",
        "C": "순서가 없고 중복을 허용하지 않는다",
        "D": "정렬된 상태를 항상 유지한다"
      },
      "correctAnswer": "A"
    },
    {
      "id": "u7m4",
      "type": "mcq",
      "question": "Set 인터페이스의 주요 특징은?",
      "options": {
        "A": "입력 순서를 유지한다",
        "B": "중복된 데이터를 허용하지 않는다",
        "C": "인덱스 기반 접근을 제공한다",
        "D": "모든 요소가 정렬되어 저장된다"
      },
      "correctAnswer": "B"
    },
    {
      "id": "u7m5",
      "type": "mcq",
      "question": "Map 인터페이스에서 Key의 특징은 무엇인가?",
      "options": {
        "A": "중복을 허용한다",
        "B": "순서를 유지한다",
        "C": "유일해야 하며 중복을 허용하지 않는다",
        "D": "정렬되어 저장된다"
      },
      "correctAnswer": "C"
    },
    {
      "id": "u7m6",
      "type": "mcq",
      "question": "ArrayList의 단점으로 옳은 것은?",
      "options": {
        "A": "고정된 크기를 가진다",
        "B": "요소 삽입/삭제 시 요소 이동에 따른 비용이 발생한다",
        "C": "빠른 랜덤 접근이 불가능하다",
        "D": "메모리 사용이 과도하다"
      },
      "correctAnswer": "B"
    },
    {
      "id": "u7m7",
      "type": "mcq",
      "question": "LinkedList의 장점으로 옳은 것은?",
      "options": {
        "A": "빠른 인덱스 접근",
        "B": "동적 요소 삽입 및 삭제가 빠르다",
        "C": "배열보다 메모리 사용이 적다",
        "D": "자동 정렬 기능을 제공한다"
      },
      "correctAnswer": "B"
    },
    {
      "id": "u7m8",
      "type": "mcq",
      "question": "List에서 요소 삭제 시 인덱스 감소가 필요한 이유는 무엇인가?",
      "options": {
        "A": "요소가 삭제되면 인덱스가 자동으로 재배치되기 때문",
        "B": "메모리 누수가 발생하기 때문",
        "C": "삭제된 요소의 자리가 null로 채워지기 때문",
        "D": "요소가 삭제될 때마다 리스트가 재정렬되기 때문"
      },
      "correctAnswer": "A"
    },
    {
      "id": "u7m9",
      "type": "mcq",
      "question": "LinkedList의 내부 구조는 무엇으로 구성되는가?",
      "options": {
        "A": "배열",
        "B": "노드와 포인터(링크)",
        "C": "해시 테이블",
        "D": "트리 구조"
      },
      "correctAnswer": "B"
    },
    {
      "id": "u7m10",
      "type": "mcq",
      "question": "ArrayList와 LinkedList 중 랜덤 접근이 빠른 것은?",
      "options": {
        "A": "ArrayList",
        "B": "LinkedList",
        "C": "둘 다 같다",
        "D": "둘 다 느리다"
      },
      "correctAnswer": "A"
    },
    {
      "id": "u7m11",
      "type": "mcq",
      "question": "Set 인터페이스의 주된 목적은 무엇인가?",
      "options": {
        "A": "데이터의 순서를 유지하기 위해",
        "B": "중복된 데이터를 제거하기 위해",
        "C": "빠른 인덱스 접근을 제공하기 위해",
        "D": "데이터를 정렬하기 위해"
      },
      "correctAnswer": "B"
    },
    {
      "id": "u7m12",
      "type": "mcq",
      "question": "List 인터페이스의 구현체 중 배열 기반으로 동작하는 것은?",
      "options": {
        "A": "LinkedList",
        "B": "ArrayList",
        "C": "Vector",
        "D": "Stack"
      },
      "correctAnswer": "B"
    },
    {
      "id": "u7m13",
      "type": "mcq",
      "question": "List 인터페이스의 구현체 중 링크드 리스트 기반은?",
      "options": {
        "A": "ArrayList",
        "B": "LinkedList",
        "C": "HashSet",
        "D": "TreeSet"
      },
      "correctAnswer": "B"
    },
    {
      "id": "u7m14",
      "type": "mcq",
      "question": "CRUD는 무엇의 약자인가?",
      "options": {
        "A": "Create, Read, Update, Delete",
        "B": "Copy, Remove, Update, Delete",
        "C": "Create, Remove, Undo, Delete",
        "D": "Compile, Run, Update, Delete"
      },
      "correctAnswer": "A"
    },
    {
      "id": "u7m15",
      "type": "mcq",
      "question": "자료구조 선택 시 고려해야 할 주요 요소는 무엇인가?",
      "options": {
        "A": "삽입/삭제 속도",
        "B": "랜덤 접근 속도",
        "C": "메모리 사용량",
        "D": "모두 해당된다"
      },
      "correctAnswer": "D"
    },
    {
      "id": "u7m16",
      "type": "mcq",
      "question": "Collections.sort()를 사용하기 위해 요소들은 어떤 인터페이스를 구현해야 하는가?",
      "options": {
        "A": "Comparator",
        "B": "Comparable",
        "C": "Iterable",
        "D": "Serializable"
      },
      "correctAnswer": "B"
    },
    {
      "id": "u7m17",
      "type": "mcq",
      "question": "사용자 정의 정렬 기준을 제공하기 위한 인터페이스는?",
      "options": {
        "A": "Comparable",
        "B": "Comparator",
        "C": "Runnable",
        "D": "Iterable"
      },
      "correctAnswer": "B"
    },
    {
      "id": "u7m18",
      "type": "mcq",
      "question": "리스트에서 요소 삭제 시 for문을 역순으로 실행하는 이유는?",
      "options": {
        "A": "요소 삭제 시 인덱스가 재배치되기 때문",
        "B": "메모리 누수를 방지하기 위해",
        "C": "정렬을 유지하기 위해",
        "D": "삭제 후 오류가 발생하지 않기 위해"
      },
      "correctAnswer": "A"
    },
    {
      "id": "u7m19",
      "type": "mcq",
      "question": "Iterator의 주요 기능은 무엇인가?",
      "options": {
        "A": "요소를 순회하며 처리한다",
        "B": "요소를 정렬한다",
        "C": "요소를 추가한다",
        "D": "요소를 삭제하지 못한다"
      },
      "correctAnswer": "A"
    },
    {
      "id": "u7m20",
      "type": "mcq",
      "question": "ArrayList에서 요소 추가 시, 내부 배열이 부족할 경우 발생하는 작업은?",
      "options": {
        "A": "예외 발생",
        "B": "새로운 배열로 복사하여 확장",
        "C": "자동 삭제",
        "D": "무시되고 추가되지 않음"
      },
      "correctAnswer": "B"
    },
    {
      "id": "u7m21",
      "type": "mcq",
      "question": "LinkedList의 단점은 무엇인가?",
      "options": {
        "A": "랜덤 접근 속도가 느리다",
        "B": "삽입/삭제가 느리다",
        "C": "메모리 사용이 적다",
        "D": "내부적으로 배열을 사용한다"
      },
      "correctAnswer": "A"
    },
    {
      "id": "u7m22",
      "type": "mcq",
      "question": "TreeSet의 주요 특징은 무엇인가?",
      "options": {
        "A": "중복을 허용하며 순서를 유지한다",
        "B": "중복을 제거하고 정렬된 상태로 저장한다",
        "C": "빠른 인덱스 접근을 제공한다",
        "D": "해시 테이블 기반으로 동작한다"
      },
      "correctAnswer": "B"
    },
    {
      "id": "u7m23",
      "type": "mcq",
      "question": "HashMap에서 key 충돌을 해결하는 방법은?",
      "options": {
        "A": "체이닝(Chaining)",
        "B": "오픈 어드레싱(Open Addressing)",
        "C": "둘 다 사용된다",
        "D": "충돌을 허용하지 않는다"
      },
      "correctAnswer": "C"
    },
    {
      "id": "u7m24",
      "type": "mcq",
      "question": "Map 인터페이스에서 key와 value의 한 쌍을 저장하는 단위는?",
      "options": {
        "A": "Pair",
        "B": "Entry",
        "C": "Tuple",
        "D": "Node"
      },
      "correctAnswer": "B"
    },
    {
      "id": "u7m25",
      "type": "mcq",
      "question": "HashSet은 데이터를 어떤 방식으로 저장하는가?",
      "options": {
        "A": "배열",
        "B": "링크드 리스트",
        "C": "해시 테이블",
        "D": "트리"
      },
      "correctAnswer": "C"
    },
    {
      "id": "u7m26",
      "type": "mcq",
      "question": "Iterator의 remove() 메서드의 주 용도는 무엇인가?",
      "options": {
        "A": "요소 추가",
        "B": "요소 삭제",
        "C": "요소 변경",
        "D": "순회 중단"
      },
      "correctAnswer": "B"
    },
    {
      "id": "u7m27",
      "type": "mcq",
      "question": "Collections.reverse() 메서드가 수행하는 작업은?",
      "options": {
        "A": "리스트의 요소를 정렬한다",
        "B": "리스트의 요소 순서를 반전시킨다",
        "C": "리스트의 요소를 복사한다",
        "D": "리스트의 요소를 삭제한다"
      },
      "correctAnswer": "B"
    },
    {
      "id": "u7m28",
      "type": "mcq",
      "question": "Comparable 인터페이스를 구현할 때 필수로 재정의해야 하는 메서드는?",
      "options": {
        "A": "compare()",
        "B": "compareTo()",
        "C": "equals()",
        "D": "hashCode()"
      },
      "correctAnswer": "B"
    },
    {
      "id": "u7m29",
      "type": "mcq",
      "question": "Comparator 인터페이스의 주요 메서드는 무엇인가?",
      "options": {
        "A": "compare()",
        "B": "compareTo()",
        "C": "equals()",
        "D": "toString()"
      },
      "correctAnswer": "A"
    },
    {
      "id": "u7m30",
      "type": "mcq",
      "question": "LinkedHashSet의 주요 장점은 무엇인가?",
      "options": {
        "A": "중복 제거와 함께 삽입 순서를 유지한다",
        "B": "자동 정렬된다",
        "C": "빠른 인덱스 접근을 제공한다",
        "D": "메모리 사용이 최소화된다"
      },
      "correctAnswer": "A"
    },
    {
      "id": "u7m31",
      "type": "mcq",
      "question": "TreeMap의 주요 특징은 무엇인가?",
      "options": {
        "A": "키와 값이 해시 테이블에 저장된다",
        "B": "키를 기준으로 정렬되어 저장된다",
        "C": "삽입 순서를 유지한다",
        "D": "동기화를 지원한다"
      },
      "correctAnswer": "B"
    },
    {
      "id": "u7m32",
      "type": "mcq",
      "question": "Iterator와 for-each 루프의 차이점은 무엇인가?",
      "options": {
        "A": "Iterator는 요소 삭제가 가능하다",
        "B": "for-each 루프는 요소 삭제가 가능하다",
        "C": "둘 다 요소 삭제가 가능하다",
        "D": "Iterator는 순회 중 요소를 추가할 수 있다"
      },
      "correctAnswer": "A"
    },
    {
      "id": "u7m33",
      "type": "mcq",
      "question": "Collections.binarySearch() 메서드를 사용하려면 리스트의 요소들이 무엇을 구현해야 하는가?",
      "options": {
        "A": "Comparable",
        "B": "Comparator",
        "C": "Iterable",
        "D": "Serializable"
      },
      "correctAnswer": "A"
    },
    {
      "id": "u7m34",
      "type": "mcq",
      "question": "자료구조에서 '중복 제거' 기능은 주로 어느 인터페이스에서 제공되는가?",
      "options": {
        "A": "List",
        "B": "Set",
        "C": "Map",
        "D": "Queue"
      },
      "correctAnswer": "B"
    },
    {
      "id": "u7m35",
      "type": "mcq",
      "question": "ArrayList와 LinkedList의 선택 기준 중 올바른 것은?",
      "options": {
        "A": "데이터 조회가 많다면 ArrayList, 삽입/삭제가 많다면 LinkedList",
        "B": "데이터 조회가 많다면 LinkedList, 삽입/삭제가 많다면 ArrayList",
        "C": "둘 다 동일하다",
        "D": "상황에 관계없이 ArrayList가 항상 빠르다"
      },
      "correctAnswer": "A"
    },
    {
      "id": "u7m36",
      "type": "mcq",
      "question": "LinkedList에서 요소를 삭제할 때 주의해야 하는 점은 무엇인가?",
      "options": {
        "A": "인덱스가 감소해야 한다",
        "B": "인덱스가 증가해야 한다",
        "C": "요소가 자동으로 null로 채워진다",
        "D": "요소가 정렬된다"
      },
      "correctAnswer": "A"
    },
    {
      "id": "u7m37",
      "type": "mcq",
      "question": "HashMap과 Hashtable의 주요 차이점은 무엇인가?",
      "options": {
        "A": "HashMap은 동기화를 지원하지 않으며 null 키와 null 값을 허용한다",
        "B": "Hashtable은 동기화를 지원하며 null 키와 null 값을 허용한다",
        "C": "HashMap은 동기화를 지원하며 null 키를 허용하지 않는다",
        "D": "둘은 완전히 동일하다"
      },
      "correctAnswer": "A"
    },
    {
      "id": "u7m38",
      "type": "mcq",
      "question": "LinkedHashMap의 특징은 무엇인가?",
      "options": {
        "A": "요소가 해시 테이블에 무작위로 저장된다",
        "B": "삽입 순서를 유지한다",
        "C": "키가 정렬되어 저장된다",
        "D": "동기화가 기본적으로 지원된다"
      },
      "correctAnswer": "B"
    },
    {
      "id": "u7m39",
      "type": "mcq",
      "question": "TreeSet은 어떤 기준으로 요소를 정렬하는가?",
      "options": {
        "A": "삽입 순서",
        "B": "요소의 해시 값",
        "C": "자연 순서 또는 Comparator에 의해 결정",
        "D": "랜덤 순서"
      },
      "correctAnswer": "C"
    },
    {
      "id": "u7m40",
      "type": "mcq",
      "question": "List 인터페이스에서 요소를 대체하는 메서드는 무엇인가?",
      "options": {
        "A": "add()",
        "B": "set()",
        "C": "replace()",
        "D": "update()"
      },
      "correctAnswer": "B"
    },
    {
      "id": "u7m41",
      "type": "mcq",
      "question": "자료구조에서 '정렬'이란 무엇을 의미하는가?",
      "options": {
        "A": "요소를 삽입 순서대로 유지하는 것",
        "B": "요소를 특정 기준에 따라 순서대로 배치하는 것",
        "C": "중복 요소를 제거하는 것",
        "D": "요소를 삭제하는 것"
      },
      "correctAnswer": "B"
    },
    {
      "id": "u7m42",
      "type": "mcq",
      "question": "Iterator를 사용하여 컬렉션의 요소를 순회할 때 발생할 수 있는 예외는?",
      "options": {
        "A": "NullPointerException",
        "B": "IndexOutOfBoundsException",
        "C": "ConcurrentModificationException",
        "D": "ClassCastException"
      },
      "correctAnswer": "C"
    },
    {
      "id": "u7m43",
      "type": "mcq",
      "question": "Collections.sort() 메서드를 사용할 때, 리스트의 요소들이 반드시 구현해야 하는 인터페이스는?",
      "options": {
        "A": "Comparator",
        "B": "Comparable",
        "C": "Iterable",
        "D": "Serializable"
      },
      "correctAnswer": "B"
    },
    {
      "id": "u7m44",
      "type": "mcq",
      "question": "Map 인터페이스에서 값을 저장할 때, key와 value를 함께 저장하는 단위는 무엇으로 불리는가?",
      "options": {
        "A": "Pair",
        "B": "Entry",
        "C": "Tuple",
        "D": "Node"
      },
      "correctAnswer": "B"
    },
    {
      "id": "u7m45",
      "type": "mcq",
      "question": "LinkedList와 ArrayList의 선택 시 가장 중요한 고려 사항은 무엇인가?",
      "options": {
        "A": "요소의 추가/삭제 빈도",
        "B": "요소의 랜덤 접근 빈도",
        "C": "메모리 사용량",
        "D": "A와 B 모두"
      },
      "correctAnswer": "D"
    },
    {
      "id": "u7m46",
      "type": "mcq",
      "question": "TreeMap은 어떤 방식으로 데이터를 정렬하는가?",
      "options": {
        "A": "키의 해시 값",
        "B": "키의 자연 순서 또는 제공된 Comparator에 따라",
        "C": "값의 크기",
        "D": "입력 순서"
      },
      "correctAnswer": "B"
    },
    {
      "id": "u7m47",
      "type": "mcq",
      "question": "HashSet의 내부 구조는 주로 어떤 데이터 구조를 사용하는가?",
      "options": {
        "A": "배열",
        "B": "연결 리스트",
        "C": "해시 테이블",
        "D": "트리"
      },
      "correctAnswer": "C"
    },
    {
      "id": "u7m48",
      "type": "mcq",
      "question": "자료구조 선택 시 가장 중요한 성능 지표 중 하나는 무엇인가?",
      "options": {
        "A": "삽입/삭제 속도",
        "B": "검색 속도",
        "C": "메모리 사용량",
        "D": "모두 해당된다"
      },
      "correctAnswer": "D"
    },
    {
      "id": "u7m49",
      "type": "mcq",
      "question": "Collection Framework의 주요 인터페이스에 포함되지 않는 것은?",
      "options": {
        "A": "List",
        "B": "Set",
        "C": "Map",
        "D": "Stack"
      },
      "correctAnswer": "D"
    },
    {
      "id": "u7m50",
      "type": "mcq",
      "question": "Collections Framework가 객체지향 프로그래밍에서 중요한 이유는 무엇인가?",
      "options": {
        "A": "표준화된 자료구조와 알고리즘을 제공하기 때문",
        "B": "모든 자료구조가 동일한 성능을 보장하기 때문",
        "C": "메모리 관리를 자동으로 수행하기 때문",
        "D": "데이터베이스와 직접 연결되기 때문"
      },
      "correctAnswer": "A"
    },
    {
      "id": "u7c1",
      "type": "code",
      "question": "ArrayList를 제너릭을 사용하여 선언하고, 문자열만 저장하도록 하는 코드를 완성하시오.",
      "codeSnippet": "List<__> list = new ArrayList<>();",
      "answers": ["String"]
    },
    {
      "id": "u7c2",
      "type": "code",
      "question": "LinkedList를 선언하여 정수 값을 저장하고, 10을 추가하는 코드를 완성하시오.",
      "codeSnippet": "List<Integer> list = new LinkedList<>();\nlist.add(__);",
      "answers": ["10"]
    },
    {
      "id": "u7c3",
      "type": "code",
      "question": "HashSet을 사용하여 중복 없는 문자열 집합을 생성하는 코드를 완성하시오.",
      "codeSnippet": "Set<__> set = new HashSet<>();",
      "answers": ["String"]
    },
    {
      "id": "u7c4",
      "type": "code",
      "question": "HashMap을 사용하여 키가 문자열, 값이 정수인 맵을 생성하는 코드를 완성하시오.",
      "codeSnippet": "Map<__, __> map = new HashMap<>();",
      "answers": ["String", "Integer"]
    },
    {
      "id": "u7c5",
      "type": "code",
      "question": "List에서 짝수 값을 삭제하는 코드를 작성할 때, 올바른 for문 순서를를 위한 코드를 작성하시오.",
      "codeSnippet": "for (int i = list.size() - 1; i >= 0; i--) {\n    if (list.get(i) % 2 == 0) {\n        list.remove(i);\n    }\n}",
      "answers": [""]
    },
    {
      "id": "u7c6",
      "type": "code",
      "question": "Collections.sort()를 사용하여 List를 오름차순으로 정렬하는 코드를 완성하시오.",
      "codeSnippet": "Collections.sort(__);",
      "answers": ["list"]
    },
    {
      "id": "u7c7",
      "type": "code",
      "question": "Comparable 인터페이스를 구현한 클래스에서 compareTo() 메서드를 재정의하는 예제에서 빈칸을 채워 넣으시오.",
      "codeSnippet": "public int compareTo(__ other) {\n    return this.value - other.value;\n}",
      "answers": ["MyClass"]
    },
    {
      "id": "u7c8",
      "type": "code",
      "question": "Comparator 인터페이스를 사용하여 두 객체를 비교하는 익명 클래스를 작성하는 예제에서 빈칸을 채워 넣으시오.",
      "codeSnippet": "Comparator<MyClass> comp = new Comparator<MyClass>() {\n    @Override\n    public int compare(MyClass o1, MyClass o2) {\n        return o1.value - o2.value;\n    }\n};",
      "answers": [""]
    },
    {
      "id": "u7c9",
      "type": "code",
      "question": "Iterator를 사용하여 List의 모든 요소를 출력하는 코드를 완성하시오.",
      "codeSnippet": "Iterator<__> it = list.iterator();\nwhile (it.hasNext()) {\n    System.out.println(it.next());\n}",
      "answers": ["Integer"]
    },
    {
      "id": "u7c10",
      "type": "code",
      "question": "ArrayList에서 인덱스를 이용하여 요소를 가져오는 코드를 완성하시오.",
      "codeSnippet": "E element = list.get(__);",
      "answers": ["index"]
    },
    {
      "id": "u7c11",
      "type": "code",
      "question": "LinkedList에서 요소를 추가하는 메서드의 이름을 채워 넣으시오.",
      "codeSnippet": "list.__(element);",
      "answers": ["add"]
    },
    {
      "id": "u7c12",
      "type": "code",
      "question": "HashSet에 요소를 추가하는 코드를 완성하시오.",
      "codeSnippet": "set.__(value);",
      "answers": ["add"]
    },
    {
      "id": "u7c13",
      "type": "code",
      "question": "TreeMap을 선언하여, 키가 String, 값이 Integer인 맵을 생성하는 코드를 완성하시오.",
      "codeSnippet": "Map<__, __> map = new TreeMap<>();",
      "answers": ["String", "Integer"]
    },
    {
      "id": "u7c14",
      "type": "code",
      "question": "Iterator의 remove() 메서드를 사용하여 요소를 제거하는 코드를 완성하시오.",
      "codeSnippet": "while(it.hasNext()) {\n    if (조건) {\n        it.__();\n    }\n}",
      "answers": ["remove"]
    },
    {
      "id": "u7c15",
      "type": "code",
      "question": "List에서 특정 인덱스에 요소를 삽입하는 메서드를 채워 넣으시오.",
      "codeSnippet": "list.__(index, element);",
      "answers": ["add"]
    },
    {
      "id": "u7c16",
      "type": "code",
      "question": "LinkedList에서 첫 번째 요소를 삭제하는 메서드의 이름은 무엇인가?",
      "codeSnippet": "list.__();",
      "answers": ["removeFirst"]
    },
    {
      "id": "u7c17",
      "type": "code",
      "question": "HashMap에서 특정 키에 대응하는 값을 가져오는 메서드를 채워 넣으시오.",
      "codeSnippet": "map.__(key);",
      "answers": ["get"]
    },
    {
      "id": "u7c18",
      "type": "code",
      "question": "ArrayList의 내부 배열이 가득 찼을 때 수행되는 작업을 설명하는 주석을 작성하시오.",
      "codeSnippet": "// 내부적으로 새로운 배열로 복사하여 확장한다.",
      "answers": [""]
    },
    {
      "id": "u7c19",
      "type": "code",
      "question": "Collections.reverse()를 사용하여 List의 순서를 반전하는 코드를 완성하시오.",
      "codeSnippet": "Collections.reverse(__);",
      "answers": ["list"]
    },
    {
      "id": "u7c20",
      "type": "code",
      "question": "Comparable 인터페이스의 compareTo() 메서드를 사용하여 두 객체를 비교하는 코드를 완성하시오.",
      "codeSnippet": "int result = obj1.compareTo(__);",
      "answers": ["obj2"]
    },
    {
      "id": "u7c21",
      "type": "code",
      "question": "TreeSet은 요소를 정렬하여 저장하는 컬렉션이다. TreeSet을 선언하는 코드를 완성하시오.",
      "codeSnippet": "Set<__> set = new TreeSet<>();",
      "answers": ["Integer"]
    },
    {
      "id": "u7c22",
      "type": "code",
      "question": "LinkedHashSet은 삽입 순서를 유지하는 Set 구현체이다. 해당 Set을 선언하는 코드를 완성하시오.",
      "codeSnippet": "Set<__> set = new LinkedHashSet<>();",
      "answers": ["String"]
    },
    {
      "id": "u7c23",
      "type": "code",
      "question": "List의 요소들을 배열로 변환하는 메서드를 채워 넣으시오.",
      "codeSnippet": "Object[] arr = list.__();",
      "answers": ["toArray"]
    },
    {
      "id": "u7c24",
      "type": "code",
      "question": "Collections.binarySearch() 메서드를 사용하여 List에서 요소를 검색하는 코드를 완성하시오.",
      "codeSnippet": "int index = Collections.binarySearch(list, __);",
      "answers": ["target"]
    },
    {
      "id": "u7c25",
      "type": "code",
      "question": "List에서 요소를 대체하는 메서드를 채워 넣으시오.",
      "codeSnippet": "list.__(index, element);",
      "answers": ["set"]
    },
    {
      "id": "u7s1",
      "type": "subjective",
      "question": "자료 구조의 정의와 그 중요성에 대해 서술하시오.",
      "correctAnswer": "자료 구조는 데이터를 효율적으로 저장, 관리, 접근할 수 있도록 하는 방법으로, 프로그램의 성능과 유지보수성을 향상시킨다."
    },
    {
      "id": "u7s2",
      "type": "subjective",
      "question": "배열과 ArrayList의 장단점에 대해 서술하시오.",
      "correctAnswer": "배열은 고정된 크기와 빠른 인덱스 접근이 장점이지만, 크기 조절이 어려워 요소 추가/삭제에 불편함이 있다. 반면 ArrayList는 동적 크기를 지원하여 요소 추가/삭제가 용이하지만, 삽입/삭제 시 요소 이동으로 인한 성능 저하가 발생할 수 있다."
    },
    {
      "id": "u7s3",
      "type": "subjective",
      "question": "LinkedList의 내부 구조와 그 장단점에 대해 서술하시오.",
      "correctAnswer": "LinkedList는 각 요소가 노드 형태로 연결되어 있어 삽입과 삭제가 빠르지만, 인덱스 기반의 접근 속도가 느리다는 단점이 있다."
    },
    {
      "id": "u7s4",
      "type": "subjective",
      "question": "Set 인터페이스의 주요 특징과 활용 예에 대해 서술하시오.",
      "correctAnswer": "Set은 중복된 데이터를 허용하지 않으며, 중복 제거 및 집합 연산에 유용하다. HashSet, LinkedHashSet, TreeSet 등이 있으며 각각의 특성에 맞게 사용된다."
    },
    {
      "id": "u7s5",
      "type": "subjective",
      "question": "Map 인터페이스의 역할과 Key-Value 구조의 장점에 대해 설명하시오.",
      "correctAnswer": "Map은 데이터를 Key와 Value 쌍으로 저장하여, Key를 통해 빠르게 값을 검색할 수 있고, 각 Key가 유일하여 데이터 관리에 용이하다."
    },
    {
      "id": "u7s6",
      "type": "subjective",
      "question": "자료구조를 선택할 때 고려해야 할 성능 지표에 대해 서술하시오.",
      "correctAnswer": "자료구조 선택 시 삽입, 삭제, 검색 속도와 메모리 사용량을 고려해야 하며, 각 자료구조의 특성에 맞게 선택해야 한다."
    },
    {
      "id": "u7s7",
      "type": "subjective",
      "question": "Iterator와 for-each 루프의 차이점과 각각의 장단점에 대해 설명하시오.",
      "correctAnswer": "Iterator는 요소 삭제와 같은 추가 기능을 제공하며 명시적으로 순회할 수 있지만, for-each 루프는 코드가 간결하나 요소 삭제가 불가능하다."
    },
    {
      "id": "u7s8",
      "type": "subjective",
      "question": "Comparable과 Comparator 인터페이스의 차이점에 대해 설명하시오.",
      "correctAnswer": "Comparable은 객체 내부에 기본 정렬 기준을 제공하며 compareTo() 메서드를 구현하는 반면, Comparator는 외부에서 정렬 기준을 정의하여 compare() 메서드를 제공한다."
    },
    {
      "id": "u7s9",
      "type": "subjective",
      "question": "Collections.sort() 메서드의 작동 원리에 대해 서술하시오.",
      "correctAnswer": "Collections.sort()는 리스트의 요소들이 Comparable을 구현하거나 Comparator를 사용하여, 내부적으로 정렬 알고리즘을 적용해 요소들의 순서를 재배치한다."
    },
    {
      "id": "u7s10",
      "type": "subjective",
      "question": "ArrayList와 LinkedList의 성능 차이에 대해 논하시오.",
      "correctAnswer": "ArrayList는 인덱스 기반 접근이 빠르지만 삽입/삭제 시 배열 복사 비용이 발생하고, LinkedList는 삽입/삭제가 빠르지만 인덱스 접근이 느리다."
    },
    {
      "id": "u7s11",
      "type": "subjective",
      "question": "HashSet과 TreeSet의 차이점 및 각각의 장단점에 대해 서술하시오.",
      "correctAnswer": "HashSet은 빠른 검색을 제공하지만 정렬되지 않고, TreeSet은 정렬된 상태를 유지하므로 탐색은 느릴 수 있다."
    },
    {
      "id": "u7s12",
      "type": "subjective",
      "question": "LinkedHashSet이 HashSet과 구별되는 점과 사용 이유에 대해 서술하시오.",
      "correctAnswer": "LinkedHashSet은 요소의 삽입 순서를 유지하기 때문에, 순서가 중요한 경우에 사용된다."
    },
    {
      "id": "u7s13",
      "type": "subjective",
      "question": "HashMap과 Hashtable의 차이점에 대해 설명하시오.",
      "correctAnswer": "HashMap은 동기화를 지원하지 않아 성능이 좋고 null을 허용하는 반면, Hashtable은 동기화를 기본으로 하여 스레드 안전하지만 성능이 떨어지고 null을 허용하지 않는다."
    },
    {
      "id": "u7s14",
      "type": "subjective",
      "question": "Iterator의 remove() 메서드를 사용할 때 주의해야 할 점에 대해 설명하시오.",
      "correctAnswer": "Iterator의 remove() 메서드는 순회 중 안전하게 요소를 제거하기 위해 사용해야 하며, for-each 루프와 같이 직접 컬렉션에서 제거하면 ConcurrentModificationException이 발생할 수 있다."
    },
    {
      "id": "u7s15",
      "type": "subjective",
      "question": "Collections.reverse() 메서드가 리스트의 순서를 어떻게 변경하는지 서술하시오.",
      "correctAnswer": "Collections.reverse()는 리스트의 첫 번째 요소와 마지막 요소를 교환하고, 중간 요소들을 반전시켜 전체 순서를 역전시킨다."
    },
    {
      "id": "u7s16",
      "type": "subjective",
      "question": "List의 add() 메서드와 set() 메서드의 차이점에 대해 설명하시오.",
      "correctAnswer": "add()는 리스트에 새 요소를 추가하여 크기를 증가시키고, set()은 특정 인덱스의 요소를 대체하여 리스트의 크기는 변하지 않는다."
    },
    {
      "id": "u7s17",
      "type": "subjective",
      "question": "Comparable 인터페이스의 역할과 compareTo() 메서드의 중요성에 대해 서술하시오.",
      "correctAnswer": "Comparable 인터페이스는 객체 간의 자연 순서를 정의하며, compareTo() 메서드를 통해 객체를 비교할 수 있어 정렬 작업에 필수적이다."
    },
    {
      "id": "u7s18",
      "type": "subjective",
      "question": "Map에서 키의 중복이 허용되지 않는 이유에 대해 서술하시오.",
      "correctAnswer": "키의 중복이 허용되지 않음으로써, 각 키를 통해 유일하게 값을 검색할 수 있어 데이터의 일관성과 검색 효율성을 보장한다."
    },
    {
      "id": "u7s19",
      "type": "subjective",
      "question": "컬렉션에서 삽입 순서와 정렬 순서의 차이에 대해 설명하시오.",
      "correctAnswer": "삽입 순서는 데이터가 추가된 순서를 의미하며, 정렬 순서는 특정 기준(예: 오름차순, 내림차순)에 따라 재배치된 순서를 의미한다."
    },
    {
      "id": "u7s20",
      "type": "subjective",
      "question": "Comparator 인터페이스를 사용하여 사용자 정의 정렬 기준을 구현하는 방법에 대해 서술하시오.",
      "correctAnswer": "Comparator 인터페이스를 구현하거나 익명 클래스로 정의하여 compare() 메서드를 재정의하면, 원하는 기준에 따라 두 객체를 비교하여 정렬할 수 있다."
    },
    {
      "id": "u7s21",
      "type": "subjective",
      "question": "Collection Framework가 객체지향 프로그래밍에서 중요한 이유에 대해 논하시오.",
      "correctAnswer": "Collection Framework는 표준화된 자료구조와 알고리즘을 제공하여, 코드의 재사용성과 유지보수성을 높이고, 효율적인 데이터 처리를 가능하게 한다."
    },
    {
      "id": "u7s22",
      "type": "subjective",
      "question": "ArrayList의 내부 동작 원리와 그에 따른 장단점에 대해 서술하시오.",
      "correctAnswer": "ArrayList는 내부적으로 배열을 사용하여 데이터를 저장하므로 인덱스 접근이 빠르지만, 배열의 크기가 부족할 때 재할당 비용과 요소 이동 비용이 발생한다."
    },
    {
      "id": "u7s23",
      "type": "subjective",
      "question": "LinkedList의 구조와 삽입/삭제의 효율성이 왜 높은지 설명하시오.",
      "correctAnswer": "LinkedList는 각 요소가 노드로 연결되어 있어, 삽입/삭제 시 인접 노드의 포인터만 수정하면 되므로 빠른 작업이 가능하다."
    },
    {
      "id": "u7s24",
      "type": "subjective",
      "question": "TreeMap과 HashMap의 주요 차이점에 대해 서술하시오.",
      "correctAnswer": "TreeMap은 키를 정렬하여 저장하며, 정렬 기반 검색이 가능하지만 속도가 느릴 수 있고, HashMap은 해시 기반으로 빠른 검색을 지원하나 정렬되지 않는다."
    },
    {
      "id": "u7s25",
      "type": "subjective",
      "question": "Collection Framework가 객체지향 프로그래밍에서 중요한 역할을 하는 이유에 대해 서술하시오.",
      "correctAnswer": "Collection Framework는 다양한 자료구조와 알고리즘을 표준화하여 제공함으로써, 데이터의 효율적인 관리, 검색, 정렬 등을 가능하게 하여 소프트웨어 개발의 생산성과 유지보수성을 높인다."
    }
  ],
  "unit8": [
    {
      "id": "u8m1",
      "type": "mcq",
      "question": "람다 표현식이란 무엇인가?",
      "options": {
        "A": "익명 내부 클래스를 대체하는 간결한 함수형 코드 블록",
        "B": "데이터베이스 쿼리 언어",
        "C": "일반 메서드 호출 방식",
        "D": "객체지향 프로그래밍의 핵심 개념"
      },
      "correctAnswer": "A"
    },
    {
      "id": "u8m2",
      "type": "mcq",
      "question": "람다 표현식의 주요 장점은 무엇인가?",
      "options": {
        "A": "코드의 간결성 향상",
        "B": "익명 내부 클래스보다 가독성이 좋음",
        "C": "함수형 프로그래밍 패러다임을 지원",
        "D": "위 모두"
      },
      "correctAnswer": "D"
    },
    {
      "id": "u8m3",
      "type": "mcq",
      "question": "람다 표현식에서 '->' 기호의 역할은 무엇인가?",
      "options": {
        "A": "매개변수와 실행문을 구분한다",
        "B": "값을 할당한다",
        "C": "메서드를 호출한다",
        "D": "비교 연산을 수행한다"
      },
      "correctAnswer": "A"
    },
    {
      "id": "u8m4",
      "type": "mcq",
      "question": "람다 표현식이 할당되는 인터페이스는 어떤 조건을 만족해야 하는가?",
      "options": {
        "A": "추상 메서드가 반드시 하나만 존재해야 한다",
        "B": "모든 메서드가 구현되어 있어야 한다",
        "C": "두 개 이상의 추상 메서드를 가져야 한다",
        "D": "default 메서드만 있어야 한다"
      },
      "correctAnswer": "A"
    },
    {
      "id": "u8m5",
      "type": "mcq",
      "question": "자바에서 함수형 인터페이스를 명시하기 위해 사용하는 어노테이션은?",
      "options": {
        "A": "@Override",
        "B": "@FunctionalInterface",
        "C": "@Deprecated",
        "D": "@SuppressWarnings"
      },
      "correctAnswer": "B"
    },
    {
      "id": "u8m6",
      "type": "mcq",
      "question": "람다 표현식에서 매개변수의 타입을 생략할 수 있는 이유는 무엇인가?",
      "options": {
        "A": "타겟 타입이 추론되기 때문",
        "B": "컴파일러가 자동으로 결정하기 때문",
        "C": "코드의 간결성을 위해",
        "D": "위 모두"
      },
      "correctAnswer": "D"
    },
    {
      "id": "u8m7",
      "type": "mcq",
      "question": "람다 표현식에서 실행문이 하나일 경우 중괄호를 생략할 수 있는 이유는?",
      "options": {
        "A": "단일 표현식으로 처리되기 때문",
        "B": "리턴값이 없기 때문",
        "C": "익명 클래스와 동일하기 때문",
        "D": "매개변수의 타입이 Object로 고정되기 때문"
      },
      "correctAnswer": "A"
    },
    {
      "id": "u8m8",
      "type": "mcq",
      "question": "람다 표현식 내부에서 this 키워드가 참조하는 대상은?",
      "options": {
        "A": "람다 표현식 자신",
        "B": "익명 내부 클래스",
        "C": "외부 클래스의 인스턴스",
        "D": "매개변수"
      },
      "correctAnswer": "C"
    },
    {
      "id": "u8m9",
      "type": "mcq",
      "question": "함수형 인터페이스가 반드시 추상 메서드를 하나만 가져야 하는 이유는?",
      "options": {
        "A": "타겟 타입 결정의 용이성",
        "B": "람다 표현식이 단일 메서드 구현으로 대체되기 때문",
        "C": "컴파일러가 함수형 인터페이스를 인식하기 위함",
        "D": "위 모두"
      },
      "correctAnswer": "D"
    },
    {
      "id": "u8m10",
      "type": "mcq",
      "question": "람다 표현식으로 표현할 수 없는 경우는?",
      "options": {
        "A": "익명 내부 클래스 사용 시",
        "B": "추상 메서드가 두 개 이상 있는 인터페이스",
        "C": "단일 메서드 인터페이스",
        "D": "정적 메서드 호출 시"
      },
      "correctAnswer": "B"
    },
    {
      "id": "u8m11",
      "type": "mcq",
      "question": "람다 표현식과 익명 내부 클래스의 차이점으로 올바른 것은?",
      "options": {
        "A": "코드 길이",
        "B": "this 키워드의 의미",
        "C": "가독성",
        "D": "위 모두"
      },
      "correctAnswer": "D"
    },
    {
      "id": "u8m12",
      "type": "mcq",
      "question": "단일 표현식으로 이루어진 람다 표현식에서 return 키워드를 생략할 수 있는 이유는?",
      "options": {
        "A": "컴파일러가 자동으로 리턴값을 처리하기 때문",
        "B": "리턴값이 없기 때문",
        "C": "람다 표현식은 항상 void를 리턴하기 때문",
        "D": "매개변수의 타입이 생략되기 때문"
      },
      "correctAnswer": "A"
    },
    {
      "id": "u8m13",
      "type": "mcq",
      "question": "람다 표현식에서 매개변수가 하나일 때 괄호를 생략할 수 있는가?",
      "options": {
        "A": "예",
        "B": "아니오",
        "C": "조건부로 가능하다",
        "D": "매개변수 타입에 따라 다르다"
      },
      "correctAnswer": "A"
    },
    {
      "id": "u8m14",
      "type": "mcq",
      "question": "람다 표현식의 간결함이 주는 가장 큰 장점은 무엇인가?",
      "options": {
        "A": "코드 중복 제거",
        "B": "가독성 향상",
        "C": "익명 클래스의 복잡성 감소",
        "D": "위 모두"
      },
      "correctAnswer": "D"
    },
    {
      "id": "u8m15",
      "type": "mcq",
      "question": "람다 표현식에서 '클래스명::new' 형식은 무엇을 의미하는가?",
      "options": {
        "A": "정적 메서드 참조",
        "B": "생성자 참조",
        "C": "인스턴스 메서드 참조",
        "D": "메서드 오버라이딩"
      },
      "correctAnswer": "B"
    },
    {
      "id": "u8m16",
      "type": "mcq",
      "question": "람다 표현식에서 '객체::인스턴스메서드' 형식의 예로 올바른 것은?",
      "options": {
        "A": "System.out::println",
        "B": "Math::max",
        "C": "String::length",
        "D": "Integer::parseInt"
      },
      "correctAnswer": "A"
    },
    {
      "id": "u8m17",
      "type": "mcq",
      "question": "람다 표현식에서 '클래스::정적메서드' 형식의 예로 옳은 것은?",
      "options": {
        "A": "Math::abs",
        "B": "this::toString",
        "C": "System.out::println",
        "D": "new String"
      },
      "correctAnswer": "A"
    },
    {
      "id": "u8m18",
      "type": "mcq",
      "question": "람다 표현식의 타겟 타입은 언제 결정되는가?",
      "options": {
        "A": "컴파일 타임",
        "B": "런타임",
        "C": "배포 시",
        "D": "실행 시"
      },
      "correctAnswer": "A"
    },
    {
      "id": "u8m19",
      "type": "mcq",
      "question": "람다 표현식에서 매개변수가 없는 경우 괄호는 어떻게 표현하는가?",
      "options": {
        "A": "생략한다",
        "B": "()로 표현한다",
        "C": "( )와 {}를 동시에 사용한다",
        "D": "매개변수가 없으면 오류가 발생한다"
      },
      "correctAnswer": "B"
    },
    {
      "id": "u8m20",
      "type": "mcq",
      "question": "람다 표현식의 간결한 문법이 개선하는 점은 무엇인가?",
      "options": {
        "A": "코드 가독성",
        "B": "코드 작성 시간",
        "C": "익명 내부 클래스의 복잡성",
        "D": "위 모두"
      },
      "correctAnswer": "D"
    },
    {
      "id": "u8m21",
      "type": "mcq",
      "question": "Stream API는 어느 Java 버전부터 도입되었는가?",
      "options": {
        "A": "Java 6",
        "B": "Java 7",
        "C": "Java 8",
        "D": "Java 9"
      },
      "correctAnswer": "C"
    },
    {
      "id": "u8m22",
      "type": "mcq",
      "question": "Stream API의 주요 특징 중 틀린 것은?",
      "options": {
        "A": "데이터 소스를 직접 변경한다",
        "B": "중간 연산과 최종 연산으로 구성된다",
        "C": "병렬 처리를 지원한다",
        "D": "내부 반복자를 사용한다"
      },
      "correctAnswer": "A"
    },
    {
      "id": "u8m23",
      "type": "mcq",
      "question": "Stream API에서 요소를 필터링할 때 사용되는 메서드는?",
      "options": {
        "A": "map()",
        "B": "filter()",
        "C": "reduce()",
        "D": "collect()"
      },
      "correctAnswer": "B"
    },
    {
      "id": "u8m24",
      "type": "mcq",
      "question": "Stream API의 distinct() 메서드는 어떤 기능을 수행하는가?",
      "options": {
        "A": "스트림의 요소를 정렬한다",
        "B": "중복된 요소를 제거한다",
        "C": "스트림의 요소를 복제한다",
        "D": "스트림의 요소를 필터링한다"
      },
      "correctAnswer": "B"
    },
    {
      "id": "u8m25",
      "type": "mcq",
      "question": "Stream API에서 limit() 메서드의 역할은 무엇인가?",
      "options": {
        "A": "스트림의 첫 n개 요소만 남긴다",
        "B": "스트림의 요소를 건너뛴다",
        "C": "스트림의 중복 요소를 제거한다",
        "D": "스트림의 요소를 정렬한다"
      },
      "correctAnswer": "A"
    },
    {
      "id": "u8m26",
      "type": "mcq",
      "question": "Stream API에서 skip() 메서드의 역할은 무엇인가?",
      "options": {
        "A": "앞의 n개 요소를 건너뛴다",
        "B": "요소를 정렬한다",
        "C": "요소의 합계를 구한다",
        "D": "요소를 복제한다"
      },
      "correctAnswer": "A"
    },
    {
      "id": "u8m27",
      "type": "mcq",
      "question": "Stream API의 map() 메서드는 주로 어떤 기능을 수행하는가?",
      "options": {
        "A": "요소 변환",
        "B": "요소 필터링",
        "C": "요소 집계",
        "D": "요소 반복"
      },
      "correctAnswer": "A"
    },
    {
      "id": "u8m28",
      "type": "mcq",
      "question": "Stream API의 reduce() 메서드는 무엇을 수행하는가?",
      "options": {
        "A": "요소를 하나로 결합하여 결과를 생성한다",
        "B": "스트림의 요소를 필터링한다",
        "C": "스트림의 요소를 정렬한다",
        "D": "스트림을 배열로 변환한다"
      },
      "correctAnswer": "A"
    },
    {
      "id": "u8m29",
      "type": "mcq",
      "question": "Stream API의 forEach() 메서드는 최종 연산에 속하는가?",
      "options": {
        "A": "예",
        "B": "아니오",
        "C": "조건부로",
        "D": "스트림에 따라 다르다"
      },
      "correctAnswer": "A"
    },
    {
      "id": "u8m30",
      "type": "mcq",
      "question": "Stream API에서 parallelStream() 메서드의 목적은 무엇인가?",
      "options": {
        "A": "스트림 요소를 병렬로 처리한다",
        "B": "스트림 요소를 순차적으로 처리한다",
        "C": "스트림 요소를 정렬한다",
        "D": "스트림 요소를 필터링한다"
      },
      "correctAnswer": "A"
    },
    {
      "id": "u8m31",
      "type": "mcq",
      "question": "Stream API에서 forEach() 메서드의 파라미터로 사용되는 함수형 인터페이스는 무엇인가?",
      "options": {
        "A": "Function",
        "B": "Predicate",
        "C": "Consumer",
        "D": "Supplier"
      },
      "correctAnswer": "C"
    },
    {
      "id": "u8m32",
      "type": "mcq",
      "question": "Stream API에서 reduce() 메서드의 파라미터로 주로 사용되는 함수형 인터페이스는 무엇인가?",
      "options": {
        "A": "BinaryOperator",
        "B": "UnaryOperator",
        "C": "BiFunction",
        "D": "Comparator"
      },
      "correctAnswer": "A"
    },
    {
      "id": "u8m33",
      "type": "mcq",
      "question": "Stream API의 collect() 메서드는 어떤 종류의 연산인가?",
      "options": {
        "A": "중간 연산",
        "B": "최종 연산",
        "C": "스트림 생성 연산",
        "D": "변환 연산"
      },
      "correctAnswer": "B"
    },
    {
      "id": "u8m34",
      "type": "mcq",
      "question": "람다 표현식과 메서드 참조 중, 메서드 참조가 주로 사용되는 이유는 무엇인가?",
      "options": {
        "A": "더 간결한 코드 작성",
        "B": "코드 중복 제거",
        "C": "가독성 향상",
        "D": "위 모두"
      },
      "correctAnswer": "D"
    },
    {
      "id": "u8m35",
      "type": "mcq",
      "question": "Stream API의 sorted() 메서드는 기본적으로 어떤 정렬을 수행하는가?",
      "options": {
        "A": "내림차순",
        "B": "오름차순",
        "C": "무작위",
        "D": "정렬하지 않는다"
      },
      "correctAnswer": "B"
    },
    {
      "id": "u8m36",
      "type": "mcq",
      "question": "Stream API의 toArray() 메서드는 무엇을 반환하는가?",
      "options": {
        "A": "List",
        "B": "배열",
        "C": "Set",
        "D": "Map"
      },
      "correctAnswer": "B"
    },
    {
      "id": "u8m37",
      "type": "mcq",
      "question": "람다 표현식에서 여러 문장이 있는 실행 블록은 반드시 무엇으로 감싸야 하는가?",
      "options": {
        "A": "대괄호 []",
        "B": "소괄호 ()",
        "C": "중괄호 {}",
        "D": "따옴표 \"\""
      },
      "correctAnswer": "C"
    },
    {
      "id": "u8m38",
      "type": "mcq",
      "question": "Stream API에서 flatMap() 메서드의 주된 역할은 무엇인가?",
      "options": {
        "A": "각 요소를 평탄화하여 하나의 스트림으로 합친다",
        "B": "스트림의 요소를 필터링한다",
        "C": "스트림의 요소를 정렬한다",
        "D": "스트림의 요소를 그룹화한다"
      },
      "correctAnswer": "A"
    },
    {
      "id": "u8m39",
      "type": "mcq",
      "question": "람다 표현식의 단점으로 옳지 않은 것은?",
      "options": {
        "A": "디버깅이 어렵다",
        "B": "코드가 지나치게 간결해져 가독성이 떨어질 수 있다",
        "C": "복잡한 로직을 표현하기에 부적합하다",
        "D": "모든 경우에 성능이 크게 저하된다"
      },
      "correctAnswer": "D"
    },
    {
      "id": "u8m40",
      "type": "mcq",
      "question": "Stream API의 collect() 메서드를 사용할 때, 결과를 누적하는 Collector를 제공하는 클래스는?",
      "options": {
        "A": "Collectors",
        "B": "Collection",
        "C": "Arrays",
        "D": "Stream"
      },
      "correctAnswer": "A"
    },
    {
      "id": "u8m41",
      "type": "mcq",
      "question": "람다 표현식과 Stream API가 도입된 주요 이유는 무엇인가?",
      "options": {
        "A": "코드의 간결성과 가독성 향상",
        "B": "병렬 처리를 쉽게 구현하기 위해",
        "C": "함수형 프로그래밍 패러다임을 도입하기 위해",
        "D": "위 모두"
      },
      "correctAnswer": "D"
    },
    {
      "id": "u8m42",
      "type": "mcq",
      "question": "Stream API에서 parallelStream()과 stream()의 차이는 무엇인가?",
      "options": {
        "A": "parallelStream()은 병렬 처리를 지원한다",
        "B": "stream()은 병렬 처리를 지원한다",
        "C": "둘은 동일하다",
        "D": "둘 다 병렬 처리를 지원하지 않는다"
      },
      "correctAnswer": "A"
    },
    {
      "id": "u8m43",
      "type": "mcq",
      "question": "람다 표현식에서 's -> System.out.println(s)'와 'System.out::println'의 차이점은?",
      "options": {
        "A": "전자는 람다 표현식, 후자는 메서드 참조이다",
        "B": "둘은 기능상 동일하다",
        "C": "전자는 실행 블록이 필요하다",
        "D": "후자는 익명 클래스이다"
      },
      "correctAnswer": "B"
    },
    {
      "id": "u8m44",
      "type": "mcq",
      "question": "람다 표현식에서 return 문을 생략할 수 있는 조건은 무엇인가?",
      "options": {
        "A": "실행문이 단일 표현식일 때",
        "B": "매개변수가 없을 때",
        "C": "타입이 자동 추론될 때",
        "D": "항상 생략할 수 있다"
      },
      "correctAnswer": "A"
    },
    {
      "id": "u8m45",
      "type": "mcq",
      "question": "Stream API의 distinct() 메서드는 내부적으로 어떤 메서드를 이용하여 중복을 제거하는가?",
      "options": {
        "A": "equals()와 hashCode()",
        "B": "compareTo()",
        "C": "toString()",
        "D": "size()"
      },
      "correctAnswer": "A"
    },
    {
      "id": "u8m46",
      "type": "mcq",
      "question": "Stream API의 collect() 메서드는 스트림을 어떤 결과로 변환하는가?",
      "options": {
        "A": "배열",
        "B": "컬렉션 또는 다른 결과",
        "C": "정수",
        "D": "문자열"
      },
      "correctAnswer": "B"
    },
    {
      "id": "u8m47",
      "type": "mcq",
      "question": "람다 표현식에서 여러 문장이 있을 때 중괄호를 반드시 사용해야 하는 이유는?",
      "options": {
        "A": "여러 문장을 구분하기 위해",
        "B": "컴파일러 오류를 방지하기 위해",
        "C": "명시적으로 코드 블록을 나타내기 위해",
        "D": "위 모두"
      },
      "correctAnswer": "D"
    },
    {
      "id": "u8m48",
      "type": "mcq",
      "question": "Stream API의 sorted() 메서드를 사용하면 기본적으로 어떤 정렬 기준을 따른는가?",
      "options": {
        "A": "내림차순",
        "B": "오름차순",
        "C": "무작위",
        "D": "정렬하지 않는다"
      },
      "correctAnswer": "B"
    },
    {
      "id": "u8m49",
      "type": "mcq",
      "question": "람다 표현식에서 메서드 참조의 형식 '클래스명::정적메서드'는 어떤 특징이 있는가?",
      "options": {
        "A": "코드가 더욱 간결해진다",
        "B": "타입 추론이 불가능하다",
        "C": "익명 내부 클래스보다 느리다",
        "D": "메서드 참조는 사용할 수 없다"
      },
      "correctAnswer": "A"
    },
    {
      "id": "u8m50",
      "type": "mcq",
      "question": "Stream API를 사용하여 병렬 처리를 구현할 때, 주의해야 할 점은 무엇인가?",
      "options": {
        "A": "상태 없는 연산을 사용해야 한다",
        "B": "순서 보장이 필요하지 않은 경우에 사용해야 한다",
        "C": "데이터 소스가 스레드 안전해야 한다",
        "D": "위 모두"
      },
      "correctAnswer": "D"
    },
    {
      "id": "u8c1",
      "type": "code",
      "question": "람다 표현식을 사용하여 문자열을 출력하는 Runnable을 작성하시오.",
      "codeSnippet": "Runnable r = () -> __;\nr.run();",
      "answers": ["System.out.println(\"Hello Lambda\")"]
    },
    {
      "id": "u8c2",
      "type": "code",
      "question": "람다 표현식을 사용하여 두 수의 합을 반환하는 BiFunction을 작성하시오.",
      "codeSnippet": "BiFunction<Integer, Integer, Integer> add = (a, b) -> __;\nint result = add.apply(5, 3);",
      "answers": ["a + b"]
    },
    {
      "id": "u8c3",
      "type": "code",
      "question": "람다 표현식을 사용하여 리스트의 모든 요소를 출력하는 코드를 작성하시오.",
      "codeSnippet": "list.forEach(item -> __);",
      "answers": ["System.out.println(item)"]
    },
    {
      "id": "u8c4",
      "type": "code",
      "question": "메서드 참조를 사용하여 문자열 배열을 정렬하는 코드를 작성하시오.",
      "codeSnippet": "Arrays.sort(arr, String::__);",
      "answers": ["compareTo"]
    },
    {
      "id": "u8c5",
      "type": "code",
      "question": "람다 표현식에서 매개변수가 하나인 경우 괄호를 생략한 예제를 작성하시오.",
      "codeSnippet": "Consumer<String> printer = __ -> System.out.println(__);\nprinter.accept(\"Test\");",
      "answers": ["s", "s"]
    },
    {
      "id": "u8c6",
      "type": "code",
      "question": "람다 표현식에서 여러 문장을 실행할 때 사용하는 블록 구문을 작성하시오.",
      "codeSnippet": "Runnable r = () -> { __; __; };\nr.run();",
      "answers": [
        "System.out.println(\"Line1\")",
        "System.out.println(\"Line2\")"
      ]
    },
    {
      "id": "u8c7",
      "type": "code",
      "question": "람다 표현식에서 return문이 포함된 Function을 작성하시오.",
      "codeSnippet": "Function<Integer, Integer> doubleValue = x -> { __; };\nint result = doubleValue.apply(4);",
      "answers": ["return x * 2"]
    },
    {
      "id": "u8c8",
      "type": "code",
      "question": "메서드 참조를 사용하여 Math 클래스의 정적 메서드 random()을 호출하는 코드를 작성하시오.",
      "codeSnippet": "Supplier<Double> sup = Math::__;\ndouble d = sup.get();",
      "answers": ["random"]
    },
    {
      "id": "u8c9",
      "type": "code",
      "question": "람다 표현식에서 인스턴스 메서드 참조를 사용하여 문자열의 길이를 구하는 코드를 작성하시오.",
      "codeSnippet": "Function<String, Integer> func = __::length;\nint len = func.apply(\"Lambda\");",
      "answers": ["String"]
    },
    {
      "id": "u8c10",
      "type": "code",
      "question": "람다 표현식 내부에서 외부 클래스의 멤버 변수를 참조하는 예제를 작성하시오.",
      "codeSnippet": "class Outer {\n    int value = 10;\n    void test() {\n        Runnable r = () -> { __; };\n        r.run();\n    }\n}\n",
      "answers": ["System.out.println(this.value)"]
    },
    {
      "id": "u8c11",
      "type": "code",
      "question": "Stream API를 사용하여 문자열 리스트에서 길이가 4 이상인 요소만 필터링하는 코드를 작성하시오.",
      "codeSnippet": "List<String> result = list.stream().filter(s -> __).collect(Collectors.toList());",
      "answers": ["s.length() >= 4"]
    },
    {
      "id": "u8c12",
      "type": "code",
      "question": "Stream API를 사용하여 0부터 100까지 정수 중 짝수의 합을 구하는 코드를 작성하시오.",
      "codeSnippet": "int sum = IntStream.range(0, 100).filter(n -> __).sum();",
      "answers": ["n % 2 == 0"]
    },
    {
      "id": "u8c13",
      "type": "code",
      "question": "Stream API의 limit() 메서드를 사용하여 스트림의 첫 5개 요소만 출력하는 코드를 작성하시오.",
      "codeSnippet": "list.stream().limit(__).forEach(System.out::println);",
      "answers": ["5"]
    },
    {
      "id": "u8c14",
      "type": "code",
      "question": "Stream API의 skip() 메서드를 사용하여 스트림의 첫 3개 요소를 건너뛰고 출력하는 코드를 작성하시오.",
      "codeSnippet": "list.stream().skip(__).forEach(System.out::println);",
      "answers": ["3"]
    },
    {
      "id": "u8c15",
      "type": "code",
      "question": "Stream API의 map() 메서드를 사용하여 문자열 리스트의 모든 요소를 대문자로 변환하는 코드를 작성하시오.",
      "codeSnippet": "List<String> upper = list.stream().map(s -> __).collect(Collectors.toList());",
      "answers": ["s.toUpperCase()"]
    },
    {
      "id": "u8c16",
      "type": "code",
      "question": "Stream API의 reduce() 메서드를 사용하여 리스트의 모든 요소의 합을 구하는 코드를 작성하시오.",
      "codeSnippet": "int total = list.stream().reduce(0, (a, b) -> __);",
      "answers": ["a + b"]
    },
    {
      "id": "u8c17",
      "type": "code",
      "question": "Stream API의 forEach() 메서드를 사용하여 각 요소를 출력하는 코드를 작성하시오.",
      "codeSnippet": "list.stream().forEach(__::println);",
      "answers": ["System.out"]
    },
    {
      "id": "u8c18",
      "type": "code",
      "question": "Stream API를 사용하여 문자열 리스트의 중복 요소를 제거하는 코드를 작성하시오.",
      "codeSnippet": "List<String> unique = list.stream().__().collect(Collectors.toList());",
      "answers": ["distinct"]
    },
    {
      "id": "u8c19",
      "type": "code",
      "question": "Stream API의 collect() 메서드를 사용하여 스트림을 리스트로 변환하는 코드를 작성하시오.",
      "codeSnippet": "List<String> newList = stream.collect(__.toList());",
      "answers": ["Collectors"]
    },
    {
      "id": "u8c20",
      "type": "code",
      "question": "람다 표현식에서 매개변수가 없는 경우, 빈 괄호를 사용한 예제를 작성하시오.",
      "codeSnippet": "Supplier<String> sup = () -> __;\nString s = sup.get();",
      "answers": ["\"Hello\""]
    },
    {
      "id": "u8c21",
      "type": "code",
      "question": "Stream API의 IntStream.range() 메서드를 사용하여 0부터 9까지의 정수 스트림을 생성하는 코드를 작성하시오.",
      "codeSnippet": "IntStream stream = IntStream.range(__, __);",
      "answers": ["0", "10"]
    },
    {
      "id": "u8c22",
      "type": "code",
      "question": "람다 표현식에서 매개변수가 하나인 경우 괄호를 생략한 예제를 작성하시오.",
      "codeSnippet": "Consumer<Integer> cons = __ -> System.out.println(__);\ncons.accept(5);",
      "answers": ["n", "n"]
    },
    {
      "id": "u8c23",
      "type": "code",
      "question": "Arrays 클래스의 stream() 메서드를 사용하여 문자열 배열을 스트림으로 변환하는 코드를 작성하시오.",
      "codeSnippet": "Stream<String> stream = Arrays.__(arr);",
      "answers": ["stream"]
    },
    {
      "id": "u8c24",
      "type": "code",
      "question": "Stream API의 sorted() 메서드를 사용하여 스트림을 오름차순으로 정렬하는 코드를 작성하시오.",
      "codeSnippet": "List<String> sorted = list.stream().__().collect(Collectors.toList());",
      "answers": ["sorted"]
    },
    {
      "id": "u8c25",
      "type": "code",
      "question": "람다 표현식에서 여러 문장이 있을 경우 중괄호를 사용하여 코드를 작성하는 예제를 작성하시오.",
      "codeSnippet": "Runnable r = () -> { __; __; };\nr.run();",
      "answers": [
        "System.out.println(\"Start\")",
        "System.out.println(\"End\")"
      ]
    },
    {
      "id": "u8s1",
      "type": "subjective",
      "question": "람다 표현식의 정의와 그 장점에 대해 서술하시오.",
      "correctAnswer": "람다 표현식은 익명 함수 형태로, 코드를 간결하게 작성할 수 있으며 익명 내부 클래스의 복잡성을 줄여 가독성을 향상시킨다."
    },
    {
      "id": "u8s2",
      "type": "subjective",
      "question": "함수형 인터페이스란 무엇이며, 람다 표현식과의 관계에 대해 설명하시오.",
      "correctAnswer": "함수형 인터페이스는 단 하나의 추상 메서드만을 가진 인터페이스로, 람다 표현식은 이 인터페이스의 구현으로 할당되어 간결하게 코드를 작성할 수 있게 해준다."
    },
    {
      "id": "u8s3",
      "type": "subjective",
      "question": "람다 표현식에서 매개변수의 타입이 생략되는 이유와 그 원리를 설명하시오.",
      "correctAnswer": "람다 표현식은 할당되는 함수형 인터페이스의 메서드 시그니처를 통해 매개변수의 타입을 컴파일러가 추론할 수 있기 때문에 타입을 생략할 수 있다."
    },
    {
      "id": "u8s4",
      "type": "subjective",
      "question": "람다 표현식 내부에서 this 키워드의 의미에 대해 설명하시오.",
      "correctAnswer": "람다 표현식 내부의 this는 해당 람다가 정의된 외부 클래스의 인스턴스를 참조한다."
    },
    {
      "id": "u8s5",
      "type": "subjective",
      "question": "메서드 참조와 람다 표현식의 차이점 및 각각의 장단점에 대해 서술하시오.",
      "correctAnswer": "메서드 참조는 기존 메서드를 간단히 호출할 수 있게 해주어 코드가 간결해지지만, 람다 표현식은 복잡한 로직 구현에 더 유연하다."
    },
    {
      "id": "u8s6",
      "type": "subjective",
      "question": "Stream API의 중간 연산과 최종 연산의 차이점에 대해 설명하시오.",
      "correctAnswer": "중간 연산은 스트림을 변환하는 작업으로 새로운 스트림을 반환하며, 최종 연산은 결과를 도출하고 스트림을 소모하여 재사용할 수 없다."
    },
    {
      "id": "u8s7",
      "type": "subjective",
      "question": "Stream API의 filter() 메서드가 어떻게 동작하는지 설명하시오.",
      "correctAnswer": "filter() 메서드는 Predicate 함수를 적용하여, 조건에 맞는 요소들만을 포함하는 새로운 스트림을 생성한다."
    },
    {
      "id": "u8s8",
      "type": "subjective",
      "question": "Stream API의 map() 메서드가 데이터를 어떻게 변환하는지 서술하시오.",
      "correctAnswer": "map() 메서드는 각 요소에 주어진 Function을 적용하여 변환된 결과를 포함하는 새로운 스트림을 반환한다."
    },
    {
      "id": "u8s9",
      "type": "subjective",
      "question": "Stream API의 reduce() 메서드의 활용 사례와 그 의미에 대해 서술하시오.",
      "correctAnswer": "reduce() 메서드는 스트림의 모든 요소를 하나의 결과로 축소(reduction)하는데 사용되며, 예를 들어 합계, 곱, 최대/최소 값을 구하는데 활용된다."
    },
    {
      "id": "u8s10",
      "type": "subjective",
      "question": "Stream API의 병렬 처리 기능의 장점과 단점에 대해 설명하시오.",
      "correctAnswer": "병렬 처리는 멀티코어 환경에서 성능을 향상시키지만, 스레드 안전하지 않은 연산에서는 문제가 발생할 수 있으며, 오버헤드가 발생할 수 있다."
    },
    {
      "id": "u8s11",
      "type": "subjective",
      "question": "람다 표현식과 Stream API가 Java 8에서 도입된 주요 이유와 그에 따른 프로그래밍 방식의 변화를 설명하시오.",
      "correctAnswer": "람다 표현식과 Stream API는 함수형 프로그래밍 패러다임을 도입하여 코드의 간결성과 가독성을 향상시키고, 병렬 처리와 내부 반복자 사용을 통해 생산성을 크게 높였다."
    },
    {
      "id": "u8s12",
      "type": "subjective",
      "question": "람다 표현식에서 단일 표현식의 경우 중괄호와 return 키워드를 생략할 수 있는 조건과 한계에 대해 설명하시오.",
      "correctAnswer": "단일 표현식만 존재할 경우 중괄호와 return 키워드를 생략할 수 있으나, 여러 문장이 있을 경우 반드시 중괄호로 감싸야 하며, 이 경우 return 키워드를 명시해야 한다."
    },
    {
      "id": "u8s13",
      "type": "subjective",
      "question": "람다 표현식과 익명 내부 클래스의 차이점에 대해 논하시오.",
      "correctAnswer": "람다 표현식은 코드가 간결하고 외부 클래스의 this를 그대로 참조하는 반면, 익명 내부 클래스는 별도의 클래스로 동작하며 this가 익명 클래스 자신을 참조한다."
    },
    {
      "id": "u8s14",
      "type": "subjective",
      "question": "Stream API의 distinct() 메서드의 내부 동작 방식과 활용 예에 대해 설명하시오.",
      "correctAnswer": "distinct() 메서드는 요소들의 equals()와 hashCode()를 이용해 중복 여부를 판단하여, 중복된 요소를 제거한 새로운 스트림을 반환한다."
    },
    {
      "id": "u8s15",
      "type": "subjective",
      "question": "Stream API의 skip()과 limit() 메서드를 함께 사용하여 특정 범위의 요소를 선택하는 방법에 대해 서술하시오.",
      "correctAnswer": "skip()은 앞의 n개 요소를 건너뛰고, limit()은 그 이후의 요소 중 지정한 개수만 남기므로, 두 메서드를 조합하면 원하는 범위의 요소만 선택할 수 있다."
    },
    {
      "id": "u8s16",
      "type": "subjective",
      "question": "Stream API의 forEach() 메서드와 전통적인 for문을 비교하여 각각의 장단점을 논하시오.",
      "correctAnswer": "forEach()는 코드가 간결하고 내부 반복자를 사용하여 구현되지만, 디버깅이 어렵고 반복 제어가 제한적이며, 전통적인 for문은 유연한 제어가 가능하다."
    },
    {
      "id": "u8s17",
      "type": "subjective",
      "question": "람다 표현식에서 변수 캡처(closure)의 개념과 그 제약 조건에 대해 설명하시오.",
      "correctAnswer": "람다 표현식은 외부의 final 또는 effectively final 변수들을 캡처할 수 있으며, 캡처된 변수는 수정할 수 없으므로 불변성을 유지해야 한다."
    },
    {
      "id": "u8s18",
      "type": "subjective",
      "question": "Stream API의 map()과 flatMap() 메서드의 차이점에 대해 논하시오.",
      "correctAnswer": "map()은 각 요소를 다른 값으로 변환하여 새로운 스트림을 만들고, flatMap()은 각 요소가 스트림을 반환할 때 이를 평탄화하여 하나의 단일 스트림으로 합친다."
    },
    {
      "id": "u8s19",
      "type": "subjective",
      "question": "람다 표현식에서 타입 추론이 이루어지는 원리를 설명하시오.",
      "correctAnswer": "컴파일러는 람다 표현식이 대입되는 함수형 인터페이스의 추상 메서드 시그니처를 기준으로 매개변수와 리턴 타입을 추론한다."
    },
    {
      "id": "u8s20",
      "type": "subjective",
      "question": "Stream API의 병렬 처리 기능을 사용할 때 고려해야 할 점에 대해 서술하시오.",
      "correctAnswer": "병렬 스트림은 상태 없는 연산과 스레드 안전한 자료구조를 사용해야 하며, 작업 분할 및 병합 과정에서 오버헤드가 발생할 수 있으므로 신중하게 사용해야 한다."
    },
    {
      "id": "u8s21",
      "type": "subjective",
      "question": "람다 표현식과 메서드 참조를 사용하여 코드 간결성을 높이는 방법에 대해 논하시오.",
      "correctAnswer": "람다 표현식은 익명 클래스를 대체하여 코드를 간결하게 만들고, 메서드 참조는 기존 메서드를 재사용하여 불필요한 중복 코드를 제거하는 데 기여한다."
    },
    {
      "id": "u8s22",
      "type": "subjective",
      "question": "Stream API의 distinct() 메서드가 내부적으로 어떻게 동작하는지 설명하시오.",
      "correctAnswer": "distinct()는 각 요소의 equals()와 hashCode() 메서드를 사용하여 중복 여부를 판단하고, 중복된 요소를 제거한 새로운 스트림을 반환한다."
    },
    {
      "id": "u8s23",
      "type": "subjective",
      "question": "Stream API의 collect() 메서드를 사용하여 스트림을 컬렉션으로 변환하는 과정을 설명하시오.",
      "correctAnswer": "collect() 메서드는 Collector 인터페이스를 통해 스트림의 요소를 누적하고, 최종적으로 리스트, 셋 등의 컬렉션으로 변환한다."
    },
    {
      "id": "u8s24",
      "type": "subjective",
      "question": "람다 표현식이 Java 8에 도입된 주요 이유와 그에 따른 프로그래밍 패러다임의 변화를 서술하시오.",
      "correctAnswer": "람다 표현식은 함수형 프로그래밍을 도입하여 코드의 간결성과 가독성을 향상시키고, 병렬 처리와 내부 반복자를 통해 생산성을 높이며, 기존의 익명 클래스를 대체하는 혁신적인 문법이다."
    },
    {
      "id": "u8s25",
      "type": "subjective",
      "question": "Stream API와 기존의 for문, Iterator 방식의 차이점과 그 장단점에 대해 논하시오.",
      "correctAnswer": "Stream API는 내부 반복자와 함수형 연산을 통해 코드가 간결하며 병렬 처리를 지원하지만, 디버깅이 어려울 수 있고, 한 번 최종 연산 후 재사용이 불가능하다. 반면, 전통적인 for문과 Iterator는 명시적 제어가 가능하나 코드가 장황하다."
    }
  ]
}
